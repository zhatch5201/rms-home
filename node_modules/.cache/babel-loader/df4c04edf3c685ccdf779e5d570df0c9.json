{"ast":null,"code":"'use strict';\n\nvar _regeneratorRuntime = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _objectSpread = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _asyncToGenerator = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _inherits = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _require = require('buffer'),\n    BufferConstants = _require.constants;\n\nvar stream = require('stream');\n\nvar _require2 = require('util'),\n    promisify = _require2.promisify;\n\nvar bufferStream = require('./buffer-stream');\n\nvar streamPipelinePromisified = promisify(stream.pipeline);\n\nvar MaxBufferError = /*#__PURE__*/function (_Error) {\n  _inherits(MaxBufferError, _Error);\n\n  var _super = _createSuper(MaxBufferError);\n\n  function MaxBufferError() {\n    var _this;\n\n    _classCallCheck(this, MaxBufferError);\n\n    _this = _super.call(this, 'maxBuffer exceeded');\n    _this.name = 'MaxBufferError';\n    return _this;\n  }\n\n  return MaxBufferError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nfunction getStream(_x, _x2) {\n  return _getStream.apply(this, arguments);\n}\n\nfunction _getStream() {\n  _getStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2(inputStream, options) {\n    var _options, maxBuffer, stream;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            if (inputStream) {\n              _context2.next = 2;\n              break;\n            }\n\n            throw new Error('Expected a stream');\n\n          case 2:\n            options = _objectSpread({\n              maxBuffer: Infinity\n            }, options);\n            _options = options, maxBuffer = _options.maxBuffer;\n            stream = bufferStream(options);\n            _context2.next = 7;\n            return new Promise(function (resolve, reject) {\n              var rejectPromise = function rejectPromise(error) {\n                // Don't retrieve an oversized buffer.\n                if (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n                  error.bufferedData = stream.getBufferedValue();\n                }\n\n                reject(error);\n              };\n\n              _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n                return _regeneratorRuntime.wrap(function _callee$(_context) {\n                  while (1) {\n                    switch (_context.prev = _context.next) {\n                      case 0:\n                        _context.prev = 0;\n                        _context.next = 3;\n                        return streamPipelinePromisified(inputStream, stream);\n\n                      case 3:\n                        resolve();\n                        _context.next = 9;\n                        break;\n\n                      case 6:\n                        _context.prev = 6;\n                        _context.t0 = _context[\"catch\"](0);\n                        rejectPromise(_context.t0);\n\n                      case 9:\n                      case \"end\":\n                        return _context.stop();\n                    }\n                  }\n                }, _callee, null, [[0, 6]]);\n              }))();\n\n              stream.on('data', function () {\n                if (stream.getBufferedLength() > maxBuffer) {\n                  rejectPromise(new MaxBufferError());\n                }\n              });\n            });\n\n          case 7:\n            return _context2.abrupt(\"return\", stream.getBufferedValue());\n\n          case 8:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n  return _getStream.apply(this, arguments);\n}\n\nmodule.exports = getStream;\n\nmodule.exports.buffer = function (stream, options) {\n  return getStream(stream, _objectSpread(_objectSpread({}, options), {}, {\n    encoding: 'buffer'\n  }));\n};\n\nmodule.exports.array = function (stream, options) {\n  return getStream(stream, _objectSpread(_objectSpread({}, options), {}, {\n    array: true\n  }));\n};\n\nmodule.exports.MaxBufferError = MaxBufferError;","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/storage/node_modules/get-stream/index.js"],"names":["require","BufferConstants","constants","stream","promisify","bufferStream","streamPipelinePromisified","pipeline","MaxBufferError","name","Error","getStream","inputStream","options","maxBuffer","Infinity","Promise","resolve","reject","rejectPromise","error","getBufferedLength","MAX_LENGTH","bufferedData","getBufferedValue","on","module","exports","buffer","encoding","array"],"mappings":"AAAA;;;;;;;;;;;;;;;;eACqCA,OAAO,CAAC,QAAD,C;IAA1BC,e,YAAXC,S;;AACP,IAAMC,MAAM,GAAGH,OAAO,CAAC,QAAD,CAAtB;;gBACoBA,OAAO,CAAC,MAAD,C;IAApBI,S,aAAAA,S;;AACP,IAAMC,YAAY,GAAGL,OAAO,CAAC,iBAAD,CAA5B;;AAEA,IAAMM,yBAAyB,GAAGF,SAAS,CAACD,MAAM,CAACI,QAAR,CAA3C;;IAEMC,c;;;;;AACL,4BAAc;AAAA;;AAAA;;AACb,8BAAM,oBAAN;AACA,UAAKC,IAAL,GAAY,gBAAZ;AAFa;AAGb;;;iCAJ2BC,K;;SAOdC,S;;;;;wEAAf,kBAAyBC,WAAzB,EAAsCC,OAAtC;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA,gBACMD,WADN;AAAA;AAAA;AAAA;;AAAA,kBAEQ,IAAIF,KAAJ,CAAU,mBAAV,CAFR;;AAAA;AAKCG,YAAAA,OAAO;AACNC,cAAAA,SAAS,EAAEC;AADL,eAEHF,OAFG,CAAP;AALD,uBAUqBA,OAVrB,EAUQC,SAVR,YAUQA,SAVR;AAWOX,YAAAA,MAXP,GAWgBE,YAAY,CAACQ,OAAD,CAX5B;AAAA;AAAA,mBAaO,IAAIG,OAAJ,CAAY,UAACC,OAAD,EAAUC,MAAV,EAAqB;AACtC,kBAAMC,aAAa,GAAG,SAAhBA,aAAgB,CAAAC,KAAK,EAAI;AAC9B;AACA,oBAAIA,KAAK,IAAIjB,MAAM,CAACkB,iBAAP,MAA8BpB,eAAe,CAACqB,UAA3D,EAAuE;AACtEF,kBAAAA,KAAK,CAACG,YAAN,GAAqBpB,MAAM,CAACqB,gBAAP,EAArB;AACA;;AAEDN,gBAAAA,MAAM,CAACE,KAAD,CAAN;AACA,eAPD;;AASA,uEAAC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,+BAEOd,yBAAyB,CAACM,WAAD,EAAcT,MAAd,CAFhC;;AAAA;AAGCc,wBAAAA,OAAO;AAHR;AAAA;;AAAA;AAAA;AAAA;AAKCE,wBAAAA,aAAa,aAAb;;AALD;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,eAAD;;AASAhB,cAAAA,MAAM,CAACsB,EAAP,CAAU,MAAV,EAAkB,YAAM;AACvB,oBAAItB,MAAM,CAACkB,iBAAP,KAA6BP,SAAjC,EAA4C;AAC3CK,kBAAAA,aAAa,CAAC,IAAIX,cAAJ,EAAD,CAAb;AACA;AACD,eAJD;AAKA,aAxBK,CAbP;;AAAA;AAAA,8CAuCQL,MAAM,CAACqB,gBAAP,EAvCR;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,G;;;;AA0CAE,MAAM,CAACC,OAAP,GAAiBhB,SAAjB;;AACAe,MAAM,CAACC,OAAP,CAAeC,MAAf,GAAwB,UAACzB,MAAD,EAASU,OAAT;AAAA,SAAqBF,SAAS,CAACR,MAAD,kCAAaU,OAAb;AAAsBgB,IAAAA,QAAQ,EAAE;AAAhC,KAA9B;AAAA,CAAxB;;AACAH,MAAM,CAACC,OAAP,CAAeG,KAAf,GAAuB,UAAC3B,MAAD,EAASU,OAAT;AAAA,SAAqBF,SAAS,CAACR,MAAD,kCAAaU,OAAb;AAAsBiB,IAAAA,KAAK,EAAE;AAA7B,KAA9B;AAAA,CAAvB;;AACAJ,MAAM,CAACC,OAAP,CAAenB,cAAf,GAAgCA,cAAhC","sourcesContent":["'use strict';\nconst {constants: BufferConstants} = require('buffer');\nconst stream = require('stream');\nconst {promisify} = require('util');\nconst bufferStream = require('./buffer-stream');\n\nconst streamPipelinePromisified = promisify(stream.pipeline);\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\tthrow new Error('Expected a stream');\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\tconst stream = bufferStream(options);\n\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tawait streamPipelinePromisified(inputStream, stream);\n\t\t\t\tresolve();\n\t\t\t} catch (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t}\n\t\t})();\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n"]},"metadata":{},"sourceType":"script"}