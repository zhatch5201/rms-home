{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PagedApiCaller = void 0;\n\nvar call_1 = require(\"../call\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar resourceCollector_1 = require(\"./resourceCollector\");\n\nvar PagedApiCaller = /*#__PURE__*/function () {\n  /**\n   * Creates an API caller that returns a stream to performs page-streaming.\n   *\n   * @private\n   * @constructor\n   * @param {PageDescriptor} pageDescriptor - indicates the structure\n   *   of page streaming to be performed.\n   */\n  function PagedApiCaller(pageDescriptor) {\n    _classCallCheck(this, PagedApiCaller);\n\n    this.pageDescriptor = pageDescriptor;\n  }\n  /**\n   * This function translates between regular gRPC calls (that accepts a request and returns a response,\n   * and does not know anything about pages and page tokens) and the users' callback (that expects\n   * to see resources from one page, a request to get the next page, and the raw response from the server).\n   *\n   * It generates a function that can be passed as a callback function to a gRPC call, will understand\n   * pagination-specific fields in the response, and call the users' callback after having those fields\n   * parsed.\n   *\n   * @param request Request object. It needs to be passed to all subsequent next page requests\n   * (the main content of the request object stays unchanged, only the next page token changes)\n   * @param callback The user's callback that expects the page content, next page request, and raw response.\n   */\n\n\n  _createClass(PagedApiCaller, [{\n    key: \"generateParseResponseCallback\",\n    value: function generateParseResponseCallback(request, callback) {\n      var resourceFieldName = this.pageDescriptor.resourceField;\n      var responsePageTokenFieldName = this.pageDescriptor.responsePageTokenField;\n      var requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n      return function (err, response) {\n        if (err) {\n          callback(err);\n          return;\n        }\n\n        if (!request) {\n          callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n          return;\n        }\n\n        if (!response) {\n          callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n          return;\n        }\n\n        var resources = response[resourceFieldName];\n        var pageToken = response[responsePageTokenFieldName];\n        var nextPageRequest = null;\n\n        if (pageToken) {\n          nextPageRequest = Object.assign({}, request);\n          nextPageRequest[requestPageTokenFieldName] = pageToken;\n        }\n\n        callback(err, resources, nextPageRequest, response);\n      };\n    }\n    /**\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n     * The original gRPC call just calls callback(err, result).\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n     *\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n     * request, metadata, call options, and callback.\n     */\n\n  }, {\n    key: \"wrap\",\n    value: function wrap(func) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var self = this;\n      return function wrappedCall(argument, metadata, options, callback) {\n        return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n      };\n    }\n    /**\n     * Makes it possible to use both callback-based and promise-based calls.\n     * Returns an OngoingCall or OngoingCallPromise object.\n     * Regardless of which one is returned, it always has a `.callback` to call.\n     *\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n     * @param [callback] Callback to be called, if any.\n     */\n\n  }, {\n    key: \"init\",\n    value: function init(callback) {\n      if (callback) {\n        return new call_1.OngoingCall(callback);\n      }\n\n      return new call_1.OngoingCallPromise();\n    }\n    /**\n     * Implements auto-pagination logic.\n     *\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n     * accept just two parameters: (request, callback).\n     * @param request A request object that came from the user.\n     * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\n     * (they are all optional).\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n     * and is used to return results to the user.\n     */\n\n  }, {\n    key: \"call\",\n    value: function call(apiCall, request, settings, ongoingCall) {\n      request = Object.assign({}, request); // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n\n      if (settings.pageToken) {\n        request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n      }\n\n      if (settings.pageSize) {\n        request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n      }\n\n      if (!settings.autoPaginate) {\n        // they don't want auto-pagination this time - okay, just call once\n        ongoingCall.call(apiCall, request);\n        return;\n      }\n\n      var maxResults = settings.maxResults || -1;\n      var resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n      resourceCollector.processAllPages(request).then(function (resources) {\n        return ongoingCall.callback(null, resources);\n      }, function (err) {\n        return ongoingCall.callback(err);\n      });\n    }\n  }, {\n    key: \"fail\",\n    value: function fail(ongoingCall, err) {\n      ongoingCall.callback(err);\n    }\n  }, {\n    key: \"result\",\n    value: function result(ongoingCall) {\n      return ongoingCall.promise;\n    }\n  }]);\n\n  return PagedApiCaller;\n}();\n\nexports.PagedApiCaller = PagedApiCaller;","map":{"version":3,"sources":["../../../src/paginationCalls/pagedApiCaller.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PagedApiCaller = void 0;\nconst call_1 = require(\"../call\");\nconst googleError_1 = require(\"../googleError\");\nconst resourceCollector_1 = require(\"./resourceCollector\");\nclass PagedApiCaller {\n    /**\n     * Creates an API caller that returns a stream to performs page-streaming.\n     *\n     * @private\n     * @constructor\n     * @param {PageDescriptor} pageDescriptor - indicates the structure\n     *   of page streaming to be performed.\n     */\n    constructor(pageDescriptor) {\n        this.pageDescriptor = pageDescriptor;\n    }\n    /**\n     * This function translates between regular gRPC calls (that accepts a request and returns a response,\n     * and does not know anything about pages and page tokens) and the users' callback (that expects\n     * to see resources from one page, a request to get the next page, and the raw response from the server).\n     *\n     * It generates a function that can be passed as a callback function to a gRPC call, will understand\n     * pagination-specific fields in the response, and call the users' callback after having those fields\n     * parsed.\n     *\n     * @param request Request object. It needs to be passed to all subsequent next page requests\n     * (the main content of the request object stays unchanged, only the next page token changes)\n     * @param callback The user's callback that expects the page content, next page request, and raw response.\n     */\n    generateParseResponseCallback(request, callback) {\n        const resourceFieldName = this.pageDescriptor.resourceField;\n        const responsePageTokenFieldName = this.pageDescriptor\n            .responsePageTokenField;\n        const requestPageTokenFieldName = this.pageDescriptor.requestPageTokenField;\n        return (err, response) => {\n            if (err) {\n                callback(err);\n                return;\n            }\n            if (!request) {\n                callback(new googleError_1.GoogleError('Undefined request in pagination method callback.'));\n                return;\n            }\n            if (!response) {\n                callback(new googleError_1.GoogleError('Undefined response in pagination method callback.'));\n                return;\n            }\n            const resources = response[resourceFieldName];\n            const pageToken = response[responsePageTokenFieldName];\n            let nextPageRequest = null;\n            if (pageToken) {\n                nextPageRequest = Object.assign({}, request);\n                nextPageRequest[requestPageTokenFieldName] = pageToken;\n            }\n            callback(err, resources, nextPageRequest, response);\n        };\n    }\n    /**\n     * Adds a special ability to understand pagination-specific fields to the existing gRPC call.\n     * The original gRPC call just calls callback(err, result).\n     * The wrapped one will call callback(err, resources, nextPageRequest, rawResponse) instead.\n     *\n     * @param func gRPC call (normally, a service stub call). The gRPC call is expected to accept four parameters:\n     * request, metadata, call options, and callback.\n     */\n    wrap(func) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        return function wrappedCall(argument, metadata, options, callback) {\n            return func(argument, metadata, options, self.generateParseResponseCallback(argument, callback));\n        };\n    }\n    /**\n     * Makes it possible to use both callback-based and promise-based calls.\n     * Returns an OngoingCall or OngoingCallPromise object.\n     * Regardless of which one is returned, it always has a `.callback` to call.\n     *\n     * @param settings Call settings. Can only be used to replace Promise with another promise implementation.\n     * @param [callback] Callback to be called, if any.\n     */\n    init(callback) {\n        if (callback) {\n            return new call_1.OngoingCall(callback);\n        }\n        return new call_1.OngoingCallPromise();\n    }\n    /**\n     * Implements auto-pagination logic.\n     *\n     * @param apiCall A function that performs gRPC request and calls its callback with a response or an error.\n     * It's supposed to be a gRPC service stub function wrapped into several layers of wrappers that make it\n     * accept just two parameters: (request, callback).\n     * @param request A request object that came from the user.\n     * @param settings Call settings. We are interested in `maxResults`, autoPaginate`, `pageToken`, and `pageSize`\n     * (they are all optional).\n     * @param ongoingCall An instance of OngoingCall or OngoingCallPromise that can be used for call cancellation,\n     * and is used to return results to the user.\n     */\n    call(apiCall, request, settings, ongoingCall) {\n        request = Object.assign({}, request);\n        // If settings object contain pageToken or pageSize, override the corresponding fields in the request object.\n        if (settings.pageToken) {\n            request[this.pageDescriptor.requestPageTokenField] = settings.pageToken;\n        }\n        if (settings.pageSize) {\n            request[this.pageDescriptor.requestPageSizeField] = settings.pageSize;\n        }\n        if (!settings.autoPaginate) {\n            // they don't want auto-pagination this time - okay, just call once\n            ongoingCall.call(apiCall, request);\n            return;\n        }\n        const maxResults = settings.maxResults || -1;\n        const resourceCollector = new resourceCollector_1.ResourceCollector(apiCall, maxResults);\n        resourceCollector.processAllPages(request).then(resources => ongoingCall.callback(null, resources), err => ongoingCall.callback(err));\n    }\n    fail(ongoingCall, err) {\n        ongoingCall.callback(err);\n    }\n    result(ongoingCall) {\n        return ongoingCall.promise;\n    }\n}\nexports.PagedApiCaller = PagedApiCaller;\n//# sourceMappingURL=pagedApiCaller.js.map"]},"metadata":{},"sourceType":"script"}