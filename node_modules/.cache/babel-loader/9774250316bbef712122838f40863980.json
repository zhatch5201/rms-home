{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BundleExecutor = void 0;\n\nvar status_1 = require(\"../status\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar warnings_1 = require(\"../warnings\");\n\nvar bundlingUtils_1 = require(\"./bundlingUtils\");\n\nvar task_1 = require(\"./task\");\n\nfunction noop() {}\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\n\n\nvar BundleExecutor = /*#__PURE__*/function () {\n  /**\n   * Organizes requests for an api service that requires to bundle them.\n   *\n   * @param {BundleOptions} bundleOptions - configures strategy this instance\n   *   uses when executing bundled functions.\n   * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n   * @constructor\n   */\n  function BundleExecutor(bundleOptions, bundleDescriptor) {\n    _classCallCheck(this, BundleExecutor);\n\n    this._options = bundleOptions;\n    this._descriptor = bundleDescriptor;\n    this._tasks = {};\n    this._timers = {};\n    this._invocations = {};\n    this._invocationId = 0;\n  }\n  /**\n   * Schedule a method call.\n   *\n   * @param {function} apiCall - the function for an API call.\n   * @param {Object} request - the request object to be bundled with others.\n   * @param {APICallback} callback - the callback to be called when the method finished.\n   * @return {function()} - the function to cancel the scheduled invocation.\n   */\n\n\n  _createClass(BundleExecutor, [{\n    key: \"schedule\",\n    value: function schedule(apiCall, request, callback) {\n      var _this = this;\n\n      var bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n      callback = callback || noop;\n\n      if (bundleId === undefined) {\n        warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' + \"Invoking immediately. Request: \".concat(JSON.stringify(request), \" \") + \"discriminator fields: \".concat(this._descriptor.requestDiscriminatorFields));\n        return apiCall(request, callback);\n      }\n\n      if (request[this._descriptor.bundledField] === undefined) {\n        warnings_1.warn('bundling_no_bundled_field', \"Request does not contain field \".concat(this._descriptor.bundledField, \" that must present for bundling. \") + \"Invoking immediately. Request: \".concat(JSON.stringify(request)));\n        return apiCall(request, callback);\n      }\n\n      if (!(bundleId in this._tasks)) {\n        this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n      }\n\n      var task = this._tasks[bundleId];\n      callback.id = String(this._invocationId++);\n      this._invocations[callback.id] = bundleId;\n      var bundledField = request[this._descriptor.bundledField];\n      var elementCount = bundledField.length;\n      var requestBytes = 0; // eslint-disable-next-line @typescript-eslint/no-this-alias\n\n      var self = this;\n      bundledField.forEach(function (obj) {\n        requestBytes += _this._descriptor.byteLengthFunction(obj);\n      });\n      var countLimit = this._options.elementCountLimit || 0;\n      var byteLimit = this._options.requestByteLimit || 0;\n\n      if (countLimit > 0 && elementCount > countLimit || byteLimit > 0 && requestBytes >= byteLimit) {\n        var message;\n\n        if (countLimit > 0 && elementCount > countLimit) {\n          message = 'The number of elements ' + elementCount + ' exceeds the limit ' + this._options.elementCountLimit;\n        } else {\n          message = 'The required bytes ' + requestBytes + ' exceeds the limit ' + this._options.requestByteLimit;\n        }\n\n        var error = new googleError_1.GoogleError(message);\n        error.code = status_1.Status.INVALID_ARGUMENT;\n        callback(error);\n        return {\n          cancel: noop\n        };\n      }\n\n      var existingCount = task.getElementCount();\n      var existingBytes = task.getRequestByteSize();\n\n      if (countLimit > 0 && elementCount + existingCount >= countLimit || byteLimit > 0 && requestBytes + existingBytes >= byteLimit) {\n        this._runNow(bundleId);\n\n        this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        task = this._tasks[bundleId];\n      }\n\n      task.extend(bundledField, requestBytes, callback);\n      var ret = {\n        cancel: function cancel() {\n          self._cancel(callback.id);\n        }\n      };\n      var countThreshold = this._options.elementCountThreshold || 0;\n      var sizeThreshold = this._options.requestByteThreshold || 0;\n\n      if (countThreshold > 0 && task.getElementCount() >= countThreshold || sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold) {\n        this._runNow(bundleId);\n\n        return ret;\n      }\n\n      if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n        this._timers[bundleId] = setTimeout(function () {\n          delete _this._timers[bundleId];\n\n          _this._runNow(bundleId);\n        }, this._options.delayThreshold);\n      }\n\n      return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n\n  }, {\n    key: \"_maybeClearTimeout\",\n    value: function _maybeClearTimeout(bundleId) {\n      if (bundleId in this._timers) {\n        var timerId = this._timers[bundleId];\n        delete this._timers[bundleId];\n        clearTimeout(timerId);\n      }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n\n  }, {\n    key: \"_cancel\",\n    value: function _cancel(id) {\n      if (!(id in this._invocations)) {\n        return;\n      }\n\n      var bundleId = this._invocations[id];\n\n      if (!(bundleId in this._tasks)) {\n        return;\n      }\n\n      var task = this._tasks[bundleId];\n      delete this._invocations[id];\n\n      if (task.cancel(id)) {\n        this._maybeClearTimeout(bundleId);\n\n        delete this._tasks[bundleId];\n      }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n\n  }, {\n    key: \"_runNow\",\n    value: function _runNow(bundleId) {\n      var _this2 = this;\n\n      if (!(bundleId in this._tasks)) {\n        warnings_1.warn('bundle_runnow_bundleid_unknown', \"No such bundleid: \".concat(bundleId));\n        return;\n      }\n\n      this._maybeClearTimeout(bundleId);\n\n      var task = this._tasks[bundleId];\n      delete this._tasks[bundleId];\n      task.run().forEach(function (id) {\n        delete _this2._invocations[id];\n      });\n    }\n  }]);\n\n  return BundleExecutor;\n}();\n\nexports.BundleExecutor = BundleExecutor;","map":{"version":3,"sources":["../../../src/bundlingCalls/bundleExecutor.ts"],"names":[],"mappings":";AAAA;;;;;;;;;;;;;;AAcG;;;;;;;;;;;AAEH,IAAA,QAAA,GAAA,OAAA,CAAA,WAAA,CAAA;;AAGA,IAAA,aAAA,GAAA,OAAA,CAAA,gBAAA,CAAA;;AACA,IAAA,UAAA,GAAA,OAAA,CAAA,aAAA,CAAA;;AAGA,IAAA,eAAA,GAAA,OAAA,CAAA,iBAAA,CAAA;;AACA,IAAA,MAAA,GAAA,OAAA,CAAA,QAAA,CAAA;;AAEA,SAAS,IAAT,GAAa,CAAK;AAsClB;;;;;;AAMG;;;IACU,c;AAOX;;;;;;;AAOG;AACH,0BACE,aADF,EAEE,gBAFF,EAEoC;AAAA;;AAElC,SAAK,QAAL,GAAgB,aAAhB;AACA,SAAK,WAAL,GAAmB,gBAAnB;AACA,SAAK,MAAL,GAAc,EAAd;AACA,SAAK,OAAL,GAAe,EAAf;AACA,SAAK,YAAL,GAAoB,EAApB;AACA,SAAK,aAAL,GAAqB,CAArB;AACD;AAED;;;;;;;AAOG;;;;;WACH,kBACE,OADF,EAEE,OAFF,EAGE,QAHF,EAGyB;AAAA;;AAEvB,UAAM,QAAQ,GAAG,eAAA,CAAA,eAAA,CACf,OADe,EAEf,KAAK,WAAL,CAAiB,0BAFF,CAAjB;AAIA,MAAA,QAAQ,GAAI,QAAQ,IAAI,IAAxB;;AACA,UAAI,QAAQ,KAAK,SAAjB,EAA4B;AAC1B,QAAA,UAAA,CAAA,IAAA,CACE,sCADF,EAEE,iHACoC,IAAI,CAAC,SAAL,CAAe,OAAf,CADpC,yCAE2B,KAAK,WAAL,CAAiB,0BAF5C,CAFF;AAMA,eAAO,OAAO,CAAC,OAAD,EAAU,QAAV,CAAd;AACD;;AACD,UAAI,OAAO,CAAC,KAAK,WAAL,CAAiB,YAAlB,CAAP,KAA2C,SAA/C,EAA0D;AACxD,QAAA,UAAA,CAAA,IAAA,CACE,2BADF,EAEE,yCAAkC,KAAK,WAAL,CAAiB,YAAnD,kFACoC,IAAI,CAAC,SAAL,CAAe,OAAf,CADpC,CAFF;AAKA,eAAO,OAAO,CAAC,OAAD,EAAU,QAAV,CAAd;AACD;;AAED,UAAI,EAAE,QAAQ,IAAI,KAAK,MAAnB,CAAJ,EAAgC;AAC9B,aAAK,MAAL,CAAY,QAAZ,IAAwB,IAAI,MAAA,CAAA,IAAJ,CACtB,OADsB,EAEtB,OAFsB,EAGtB,KAAK,WAAL,CAAiB,YAHK,EAItB,KAAK,WAAL,CAAiB,gBAJK,CAAxB;AAMD;;AACD,UAAI,IAAI,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAX;AACA,MAAA,QAAQ,CAAC,EAAT,GAAc,MAAM,CAAC,KAAK,aAAL,EAAD,CAApB;AACA,WAAK,YAAL,CAAkB,QAAQ,CAAC,EAA3B,IAAiC,QAAjC;AAEA,UAAM,YAAY,GAAG,OAAO,CAAC,KAAK,WAAL,CAAiB,YAAlB,CAA5B;AACA,UAAM,YAAY,GAAG,YAAY,CAAC,MAAlC;AACA,UAAI,YAAY,GAAG,CAAnB,CAvCuB,CAwCvB;;AACA,UAAM,IAAI,GAAG,IAAb;AACA,MAAA,YAAY,CAAC,OAAb,CAAqB,UAAA,GAAG,EAAG;AACzB,QAAA,YAAY,IAAI,KAAI,CAAC,WAAL,CAAiB,kBAAjB,CAAoC,GAApC,CAAhB;AACD,OAFD;AAIA,UAAM,UAAU,GAAG,KAAK,QAAL,CAAc,iBAAd,IAAmC,CAAtD;AACA,UAAM,SAAS,GAAG,KAAK,QAAL,CAAc,gBAAd,IAAkC,CAApD;;AAEA,UACG,UAAU,GAAG,CAAb,IAAkB,YAAY,GAAG,UAAlC,IACC,SAAS,GAAG,CAAZ,IAAiB,YAAY,IAAI,SAFpC,EAGE;AACA,YAAI,OAAJ;;AACA,YAAI,UAAU,GAAG,CAAb,IAAkB,YAAY,GAAG,UAArC,EAAiD;AAC/C,UAAA,OAAO,GACL,4BACA,YADA,GAEA,qBAFA,GAGA,KAAK,QAAL,CAAc,iBAJhB;AAKD,SAND,MAMO;AACL,UAAA,OAAO,GACL,wBACA,YADA,GAEA,qBAFA,GAGA,KAAK,QAAL,CAAc,gBAJhB;AAKD;;AACD,YAAM,KAAK,GAAG,IAAI,aAAA,CAAA,WAAJ,CAAgB,OAAhB,CAAd;AACA,QAAA,KAAK,CAAC,IAAN,GAAa,QAAA,CAAA,MAAA,CAAO,gBAApB;AACA,QAAA,QAAQ,CAAC,KAAD,CAAR;AACA,eAAO;AACL,UAAA,MAAM,EAAE;AADH,SAAP;AAGD;;AAED,UAAM,aAAa,GAAG,IAAI,CAAC,eAAL,EAAtB;AACA,UAAM,aAAa,GAAG,IAAI,CAAC,kBAAL,EAAtB;;AAEA,UACG,UAAU,GAAG,CAAb,IAAkB,YAAY,GAAG,aAAf,IAAgC,UAAnD,IACC,SAAS,GAAG,CAAZ,IAAiB,YAAY,GAAG,aAAf,IAAgC,SAFpD,EAGE;AACA,aAAK,OAAL,CAAa,QAAb;;AACA,aAAK,MAAL,CAAY,QAAZ,IAAwB,IAAI,MAAA,CAAA,IAAJ,CACtB,OADsB,EAEtB,OAFsB,EAGtB,KAAK,WAAL,CAAiB,YAHK,EAItB,KAAK,WAAL,CAAiB,gBAJK,CAAxB;AAMA,QAAA,IAAI,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAP;AACD;;AAED,MAAA,IAAI,CAAC,MAAL,CAAY,YAAZ,EAA0B,YAA1B,EAAwC,QAAxC;AACA,UAAM,GAAG,GAAG;AACV,QAAA,MADU,oBACJ;AACJ,UAAA,IAAI,CAAC,OAAL,CAAa,QAAS,CAAC,EAAvB;AACD;AAHS,OAAZ;AAMA,UAAM,cAAc,GAAG,KAAK,QAAL,CAAc,qBAAd,IAAuC,CAA9D;AACA,UAAM,aAAa,GAAG,KAAK,QAAL,CAAc,oBAAd,IAAsC,CAA5D;;AACA,UACG,cAAc,GAAG,CAAjB,IAAsB,IAAI,CAAC,eAAL,MAA0B,cAAjD,IACC,aAAa,GAAG,CAAhB,IAAqB,IAAI,CAAC,kBAAL,MAA6B,aAFrD,EAGE;AACA,aAAK,OAAL,CAAa,QAAb;;AACA,eAAO,GAAP;AACD;;AAED,UAAI,EAAE,QAAQ,IAAI,KAAK,OAAnB,KAA+B,KAAK,QAAL,CAAc,cAAd,GAAgC,CAAnE,EAAsE;AACpE,aAAK,OAAL,CAAa,QAAb,IAA0B,UAAU,CAAC,YAAK;AACxC,iBAAO,KAAI,CAAC,OAAL,CAAa,QAAb,CAAP;;AACA,UAAA,KAAI,CAAC,OAAL,CAAa,QAAb;AACD,SAHmC,EAGjC,KAAK,QAAL,CAAc,cAHmB,CAApC;AAID;;AAED,aAAO,GAAP;AACD;AAED;;;;;;AAMG;;;;WACK,4BAAmB,QAAnB,EAAmC;AACzC,UAAI,QAAQ,IAAI,KAAK,OAArB,EAA8B;AAC5B,YAAM,OAAO,GAAG,KAAK,OAAL,CAAa,QAAb,CAAhB;AACA,eAAO,KAAK,OAAL,CAAa,QAAb,CAAP;AACA,QAAA,YAAY,CAAC,OAAD,CAAZ;AACD;AACF;AAED;;;;;AAKG;;;;WACK,iBAAQ,EAAR,EAAkB;AACxB,UAAI,EAAE,EAAE,IAAI,KAAK,YAAb,CAAJ,EAAgC;AAC9B;AACD;;AACD,UAAM,QAAQ,GAAG,KAAK,YAAL,CAAkB,EAAlB,CAAjB;;AACA,UAAI,EAAE,QAAQ,IAAI,KAAK,MAAnB,CAAJ,EAAgC;AAC9B;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAb;AACA,aAAO,KAAK,YAAL,CAAkB,EAAlB,CAAP;;AACA,UAAI,IAAI,CAAC,MAAL,CAAY,EAAZ,CAAJ,EAAqB;AACnB,aAAK,kBAAL,CAAwB,QAAxB;;AACA,eAAO,KAAK,MAAL,CAAY,QAAZ,CAAP;AACD;AACF;AAED;;;;;AAKG;;;;WACH,iBAAQ,QAAR,EAAwB;AAAA;;AACtB,UAAI,EAAE,QAAQ,IAAI,KAAK,MAAnB,CAAJ,EAAgC;AAC9B,QAAA,UAAA,CAAA,IAAA,CAAK,gCAAL,8BAA4D,QAA5D;AACA;AACD;;AACD,WAAK,kBAAL,CAAwB,QAAxB;;AACA,UAAM,IAAI,GAAG,KAAK,MAAL,CAAY,QAAZ,CAAb;AACA,aAAO,KAAK,MAAL,CAAY,QAAZ,CAAP;AAEA,MAAA,IAAI,CAAC,GAAL,GAAW,OAAX,CAAmB,UAAA,EAAE,EAAG;AACtB,eAAO,MAAI,CAAC,YAAL,CAAkB,EAAlB,CAAP;AACD,OAFD;AAGD;;;;;;AArNH,OAAA,CAAA,cAAA,GAAA,cAAA","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.BundleExecutor = void 0;\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst warnings_1 = require(\"../warnings\");\nconst bundlingUtils_1 = require(\"./bundlingUtils\");\nconst task_1 = require(\"./task\");\nfunction noop() { }\n/**\n * BundleExecutor stores several timers for each bundle (calls are bundled based\n * on the options passed, each bundle has unique ID that is calculated based on\n * field values). Each timer fires and sends a call after certain amount of\n * time, and if a new request comes to the same bundle, the timer can be\n * restarted.\n */\nclass BundleExecutor {\n    /**\n     * Organizes requests for an api service that requires to bundle them.\n     *\n     * @param {BundleOptions} bundleOptions - configures strategy this instance\n     *   uses when executing bundled functions.\n     * @param {BundleDescriptor} bundleDescriptor - the description of the bundling.\n     * @constructor\n     */\n    constructor(bundleOptions, bundleDescriptor) {\n        this._options = bundleOptions;\n        this._descriptor = bundleDescriptor;\n        this._tasks = {};\n        this._timers = {};\n        this._invocations = {};\n        this._invocationId = 0;\n    }\n    /**\n     * Schedule a method call.\n     *\n     * @param {function} apiCall - the function for an API call.\n     * @param {Object} request - the request object to be bundled with others.\n     * @param {APICallback} callback - the callback to be called when the method finished.\n     * @return {function()} - the function to cancel the scheduled invocation.\n     */\n    schedule(apiCall, request, callback) {\n        const bundleId = bundlingUtils_1.computeBundleId(request, this._descriptor.requestDiscriminatorFields);\n        callback = (callback || noop);\n        if (bundleId === undefined) {\n            warnings_1.warn('bundling_schedule_bundleid_undefined', 'The request does not have enough information for request bundling. ' +\n                `Invoking immediately. Request: ${JSON.stringify(request)} ` +\n                `discriminator fields: ${this._descriptor.requestDiscriminatorFields}`);\n            return apiCall(request, callback);\n        }\n        if (request[this._descriptor.bundledField] === undefined) {\n            warnings_1.warn('bundling_no_bundled_field', `Request does not contain field ${this._descriptor.bundledField} that must present for bundling. ` +\n                `Invoking immediately. Request: ${JSON.stringify(request)}`);\n            return apiCall(request, callback);\n        }\n        if (!(bundleId in this._tasks)) {\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n        }\n        let task = this._tasks[bundleId];\n        callback.id = String(this._invocationId++);\n        this._invocations[callback.id] = bundleId;\n        const bundledField = request[this._descriptor.bundledField];\n        const elementCount = bundledField.length;\n        let requestBytes = 0;\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        bundledField.forEach(obj => {\n            requestBytes += this._descriptor.byteLengthFunction(obj);\n        });\n        const countLimit = this._options.elementCountLimit || 0;\n        const byteLimit = this._options.requestByteLimit || 0;\n        if ((countLimit > 0 && elementCount > countLimit) ||\n            (byteLimit > 0 && requestBytes >= byteLimit)) {\n            let message;\n            if (countLimit > 0 && elementCount > countLimit) {\n                message =\n                    'The number of elements ' +\n                        elementCount +\n                        ' exceeds the limit ' +\n                        this._options.elementCountLimit;\n            }\n            else {\n                message =\n                    'The required bytes ' +\n                        requestBytes +\n                        ' exceeds the limit ' +\n                        this._options.requestByteLimit;\n            }\n            const error = new googleError_1.GoogleError(message);\n            error.code = status_1.Status.INVALID_ARGUMENT;\n            callback(error);\n            return {\n                cancel: noop,\n            };\n        }\n        const existingCount = task.getElementCount();\n        const existingBytes = task.getRequestByteSize();\n        if ((countLimit > 0 && elementCount + existingCount >= countLimit) ||\n            (byteLimit > 0 && requestBytes + existingBytes >= byteLimit)) {\n            this._runNow(bundleId);\n            this._tasks[bundleId] = new task_1.Task(apiCall, request, this._descriptor.bundledField, this._descriptor.subresponseField);\n            task = this._tasks[bundleId];\n        }\n        task.extend(bundledField, requestBytes, callback);\n        const ret = {\n            cancel() {\n                self._cancel(callback.id);\n            },\n        };\n        const countThreshold = this._options.elementCountThreshold || 0;\n        const sizeThreshold = this._options.requestByteThreshold || 0;\n        if ((countThreshold > 0 && task.getElementCount() >= countThreshold) ||\n            (sizeThreshold > 0 && task.getRequestByteSize() >= sizeThreshold)) {\n            this._runNow(bundleId);\n            return ret;\n        }\n        if (!(bundleId in this._timers) && this._options.delayThreshold > 0) {\n            this._timers[bundleId] = setTimeout(() => {\n                delete this._timers[bundleId];\n                this._runNow(bundleId);\n            }, this._options.delayThreshold);\n        }\n        return ret;\n    }\n    /**\n     * Clears scheduled timeout if it exists.\n     *\n     * @param {String} bundleId - the id for the task whose timeout needs to be\n     *   cleared.\n     * @private\n     */\n    _maybeClearTimeout(bundleId) {\n        if (bundleId in this._timers) {\n            const timerId = this._timers[bundleId];\n            delete this._timers[bundleId];\n            clearTimeout(timerId);\n        }\n    }\n    /**\n     * Cancels an event.\n     *\n     * @param {String} id - The id for the event in the task.\n     * @private\n     */\n    _cancel(id) {\n        if (!(id in this._invocations)) {\n            return;\n        }\n        const bundleId = this._invocations[id];\n        if (!(bundleId in this._tasks)) {\n            return;\n        }\n        const task = this._tasks[bundleId];\n        delete this._invocations[id];\n        if (task.cancel(id)) {\n            this._maybeClearTimeout(bundleId);\n            delete this._tasks[bundleId];\n        }\n    }\n    /**\n     * Invokes a task.\n     *\n     * @param {String} bundleId - The id for the task.\n     * @private\n     */\n    _runNow(bundleId) {\n        if (!(bundleId in this._tasks)) {\n            warnings_1.warn('bundle_runnow_bundleid_unknown', `No such bundleid: ${bundleId}`);\n            return;\n        }\n        this._maybeClearTimeout(bundleId);\n        const task = this._tasks[bundleId];\n        delete this._tasks[bundleId];\n        task.run().forEach(id => {\n            delete this._invocations[id];\n        });\n    }\n}\nexports.BundleExecutor = BundleExecutor;\n//# sourceMappingURL=bundleExecutor.js.map"]},"metadata":{},"sourceType":"script"}