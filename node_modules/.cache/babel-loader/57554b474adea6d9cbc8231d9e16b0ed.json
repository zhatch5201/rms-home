{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar firestore_v1_proto_api_1 = require(\"../protos/firestore_v1_proto_api\");\n\nvar document_1 = require(\"./document\");\n\nvar reference_1 = require(\"./reference\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar validate_1 = require(\"./validate\");\n\nvar BundleElement = firestore_v1_proto_api_1.firestore.BundleElement;\nvar BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\n\nvar BundleBuilder = /*#__PURE__*/function () {\n  function BundleBuilder(bundleId) {\n    _classCallCheck(this, BundleBuilder);\n\n    this.bundleId = bundleId; // Resulting documents for the bundle, keyed by full document path.\n\n    this.documents = new Map(); // Named queries saved in the bundle, keyed by query name.\n\n    this.namedQueries = new Map(); // The latest read time among all bundled documents and queries.\n\n    this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n  }\n  /**\n   * Adds a Firestore document snapshot or query snapshot to the bundle.\n   * Both the documents data and the query read time will be included in the bundle.\n   *\n   * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n   * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n   * @returns {BundleBuilder} This instance.\n   *\n   * @example\n   * const bundle = firestore.bundle('data-bundle');\n   * const docSnapshot = await firestore.doc('abc/123').get();\n   * const querySnapshot = await firestore.collection('coll').get();\n   *\n   * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n   *                            .add('coll-query', querySnapshot) // Add a named query.\n   *                            .build()\n   * // Save `bundleBuffer` to CDN or stream it to clients.\n   */\n\n\n  _createClass(BundleBuilder, [{\n    key: \"add\",\n    value: function add(documentOrName, querySnapshot) {\n      // eslint-disable-next-line prefer-rest-params\n      validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1); // eslint-disable-next-line prefer-rest-params\n\n      validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n\n      if (arguments.length === 1) {\n        validateDocumentSnapshot('documentOrName', documentOrName);\n        this.addBundledDocument(documentOrName);\n      } else {\n        validate_1.validateString('documentOrName', documentOrName);\n        validateQuerySnapshot('querySnapshot', querySnapshot);\n        this.addNamedQuery(documentOrName, querySnapshot);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addBundledDocument\",\n    value: function addBundledDocument(snap, queryName) {\n      var originalDocument = this.documents.get(snap.id);\n      var originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries; // Update with document built from `snap` because it is newer.\n\n      if (!originalDocument || timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n        var docProto = snap.toDocumentProto();\n        this.documents.set(snap.id, {\n          document: snap.exists ? docProto : undefined,\n          metadata: {\n            name: docProto.name,\n            readTime: snap.readTime.toProto().timestampValue,\n            exists: snap.exists\n          }\n        });\n      } // Update `queries` to include both original and `queryName`.\n\n\n      var newDocument = this.documents.get(snap.id);\n      newDocument.metadata.queries = originalQueries || [];\n\n      if (queryName) {\n        newDocument.metadata.queries.push(queryName);\n      }\n\n      if (snap.readTime > this.latestReadTime) {\n        this.latestReadTime = snap.readTime;\n      }\n    }\n  }, {\n    key: \"addNamedQuery\",\n    value: function addNamedQuery(name, querySnap) {\n      if (this.namedQueries.has(name)) {\n        throw new Error(\"Query name conflict: \".concat(name, \" has already been added.\"));\n      }\n\n      this.namedQueries.set(name, {\n        name: name,\n        bundledQuery: querySnap.query._toBundledQuery(),\n        readTime: querySnap.readTime.toProto().timestampValue\n      });\n\n      var _iterator = _createForOfIteratorHelper(querySnap.docs),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var snap = _step.value;\n          this.addBundledDocument(snap, name);\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      if (querySnap.readTime > this.latestReadTime) {\n        this.latestReadTime = querySnap.readTime;\n      }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     */\n\n  }, {\n    key: \"elementToLengthPrefixedBuffer\",\n    value: function elementToLengthPrefixedBuffer(bundleElement) {\n      // Convert to a valid proto message object then take its JSON representation.\n      // This take cares of stuff like converting internal byte array fields\n      // to Base64 encodings.\n      var message = BundleElement.fromObject(bundleElement).toJSON();\n      var buffer = Buffer.from(JSON.stringify(message), 'utf-8');\n      var lengthBuffer = Buffer.from(buffer.length.toString());\n      return Buffer.concat([lengthBuffer, buffer]);\n    }\n  }, {\n    key: \"build\",\n    value: function build() {\n      var bundleBuffer = Buffer.alloc(0);\n\n      var _iterator2 = _createForOfIteratorHelper(this.namedQueries.values()),\n          _step2;\n\n      try {\n        for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n          var namedQuery = _step2.value;\n          bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n            namedQuery: namedQuery\n          })]);\n        }\n      } catch (err) {\n        _iterator2.e(err);\n      } finally {\n        _iterator2.f();\n      }\n\n      var _iterator3 = _createForOfIteratorHelper(this.documents.values()),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var bundledDocument = _step3.value;\n          var documentMetadata = bundledDocument.metadata;\n          bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n            documentMetadata: documentMetadata\n          })]); // Write to the bundle if document exists.\n\n          var document = bundledDocument.document;\n\n          if (document) {\n            bundleBuffer = Buffer.concat([bundleBuffer, this.elementToLengthPrefixedBuffer({\n              document: document\n            })]);\n          }\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n\n      var metadata = {\n        id: this.bundleId,\n        createTime: this.latestReadTime.toProto().timestampValue,\n        version: BUNDLE_VERSION,\n        totalDocuments: this.documents.size,\n        totalBytes: bundleBuffer.length\n      }; // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n\n      bundleBuffer = Buffer.concat([this.elementToLengthPrefixedBuffer({\n        metadata: metadata\n      }), bundleBuffer]);\n      return bundleBuffer;\n    }\n  }]);\n\n  return BundleBuilder;\n}();\n\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n */\n\nvar BundledDocument = function BundledDocument(metadata, document) {\n  _classCallCheck(this, BundledDocument);\n\n  this.metadata = metadata;\n  this.document = document;\n};\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateDocumentSnapshot(arg, value) {\n  if (!(value instanceof document_1.DocumentSnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n  }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\n\n\nfunction validateQuerySnapshot(arg, value) {\n  if (!(value instanceof reference_1.QuerySnapshot)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n  }\n}","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/firestore/build/src/bundle.js"],"names":["Object","defineProperty","exports","value","firestore_v1_proto_api_1","require","document_1","reference_1","timestamp_1","validate_1","BundleElement","firestore","BUNDLE_VERSION","BundleBuilder","bundleId","documents","Map","namedQueries","latestReadTime","Timestamp","documentOrName","querySnapshot","validateMinNumberOfArguments","arguments","validateMaxNumberOfArguments","length","validateDocumentSnapshot","addBundledDocument","validateString","validateQuerySnapshot","addNamedQuery","snap","queryName","originalDocument","get","id","originalQueries","metadata","queries","fromProto","readTime","docProto","toDocumentProto","set","document","exists","undefined","name","toProto","timestampValue","newDocument","push","querySnap","has","Error","bundledQuery","query","_toBundledQuery","docs","bundleElement","message","fromObject","toJSON","buffer","Buffer","from","JSON","stringify","lengthBuffer","toString","concat","bundleBuffer","alloc","values","namedQuery","elementToLengthPrefixedBuffer","bundledDocument","documentMetadata","createTime","version","totalDocuments","size","totalBytes","BundledDocument","arg","DocumentSnapshot","invalidArgumentMessage","QuerySnapshot"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//     https://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst firestore_v1_proto_api_1 = require(\"../protos/firestore_v1_proto_api\");\nconst document_1 = require(\"./document\");\nconst reference_1 = require(\"./reference\");\nconst timestamp_1 = require(\"./timestamp\");\nconst validate_1 = require(\"./validate\");\nvar BundleElement = firestore_v1_proto_api_1.firestore.BundleElement;\nconst BUNDLE_VERSION = 1;\n/**\n * Builds a Firestore data bundle with results from the given document and query snapshots.\n */\nclass BundleBuilder {\n    constructor(bundleId) {\n        this.bundleId = bundleId;\n        // Resulting documents for the bundle, keyed by full document path.\n        this.documents = new Map();\n        // Named queries saved in the bundle, keyed by query name.\n        this.namedQueries = new Map();\n        // The latest read time among all bundled documents and queries.\n        this.latestReadTime = new timestamp_1.Timestamp(0, 0);\n    }\n    /**\n     * Adds a Firestore document snapshot or query snapshot to the bundle.\n     * Both the documents data and the query read time will be included in the bundle.\n     *\n     * @param {DocumentSnapshot | string} documentOrName A document snapshot to add or a name of a query.\n     * @param {Query=} querySnapshot A query snapshot to add to the bundle, if provided.\n     * @returns {BundleBuilder} This instance.\n     *\n     * @example\n     * const bundle = firestore.bundle('data-bundle');\n     * const docSnapshot = await firestore.doc('abc/123').get();\n     * const querySnapshot = await firestore.collection('coll').get();\n     *\n     * const bundleBuffer = bundle.add(docSnapshot); // Add a document\n     *                            .add('coll-query', querySnapshot) // Add a named query.\n     *                            .build()\n     * // Save `bundleBuffer` to CDN or stream it to clients.\n     */\n    add(documentOrName, querySnapshot) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('BundleBuilder.add', arguments, 1);\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMaxNumberOfArguments('BundleBuilder.add', arguments, 2);\n        if (arguments.length === 1) {\n            validateDocumentSnapshot('documentOrName', documentOrName);\n            this.addBundledDocument(documentOrName);\n        }\n        else {\n            validate_1.validateString('documentOrName', documentOrName);\n            validateQuerySnapshot('querySnapshot', querySnapshot);\n            this.addNamedQuery(documentOrName, querySnapshot);\n        }\n        return this;\n    }\n    addBundledDocument(snap, queryName) {\n        const originalDocument = this.documents.get(snap.id);\n        const originalQueries = originalDocument === null || originalDocument === void 0 ? void 0 : originalDocument.metadata.queries;\n        // Update with document built from `snap` because it is newer.\n        if (!originalDocument ||\n            timestamp_1.Timestamp.fromProto(originalDocument.metadata.readTime) < snap.readTime) {\n            const docProto = snap.toDocumentProto();\n            this.documents.set(snap.id, {\n                document: snap.exists ? docProto : undefined,\n                metadata: {\n                    name: docProto.name,\n                    readTime: snap.readTime.toProto().timestampValue,\n                    exists: snap.exists,\n                },\n            });\n        }\n        // Update `queries` to include both original and `queryName`.\n        const newDocument = this.documents.get(snap.id);\n        newDocument.metadata.queries = originalQueries || [];\n        if (queryName) {\n            newDocument.metadata.queries.push(queryName);\n        }\n        if (snap.readTime > this.latestReadTime) {\n            this.latestReadTime = snap.readTime;\n        }\n    }\n    addNamedQuery(name, querySnap) {\n        if (this.namedQueries.has(name)) {\n            throw new Error(`Query name conflict: ${name} has already been added.`);\n        }\n        this.namedQueries.set(name, {\n            name,\n            bundledQuery: querySnap.query._toBundledQuery(),\n            readTime: querySnap.readTime.toProto().timestampValue,\n        });\n        for (const snap of querySnap.docs) {\n            this.addBundledDocument(snap, name);\n        }\n        if (querySnap.readTime > this.latestReadTime) {\n            this.latestReadTime = querySnap.readTime;\n        }\n    }\n    /**\n     * Converts a IBundleElement to a Buffer whose content is the length prefixed JSON representation\n     * of the element.\n     * @private\n     */\n    elementToLengthPrefixedBuffer(bundleElement) {\n        // Convert to a valid proto message object then take its JSON representation.\n        // This take cares of stuff like converting internal byte array fields\n        // to Base64 encodings.\n        const message = BundleElement.fromObject(bundleElement).toJSON();\n        const buffer = Buffer.from(JSON.stringify(message), 'utf-8');\n        const lengthBuffer = Buffer.from(buffer.length.toString());\n        return Buffer.concat([lengthBuffer, buffer]);\n    }\n    build() {\n        let bundleBuffer = Buffer.alloc(0);\n        for (const namedQuery of this.namedQueries.values()) {\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ namedQuery }),\n            ]);\n        }\n        for (const bundledDocument of this.documents.values()) {\n            const documentMetadata = bundledDocument.metadata;\n            bundleBuffer = Buffer.concat([\n                bundleBuffer,\n                this.elementToLengthPrefixedBuffer({ documentMetadata }),\n            ]);\n            // Write to the bundle if document exists.\n            const document = bundledDocument.document;\n            if (document) {\n                bundleBuffer = Buffer.concat([\n                    bundleBuffer,\n                    this.elementToLengthPrefixedBuffer({ document }),\n                ]);\n            }\n        }\n        const metadata = {\n            id: this.bundleId,\n            createTime: this.latestReadTime.toProto().timestampValue,\n            version: BUNDLE_VERSION,\n            totalDocuments: this.documents.size,\n            totalBytes: bundleBuffer.length,\n        };\n        // Prepends the metadata element to the bundleBuffer: `bundleBuffer` is the second argument to `Buffer.concat`.\n        bundleBuffer = Buffer.concat([\n            this.elementToLengthPrefixedBuffer({ metadata }),\n            bundleBuffer,\n        ]);\n        return bundleBuffer;\n    }\n}\nexports.BundleBuilder = BundleBuilder;\n/**\n * Convenient class to hold both the metadata and the actual content of a document to be bundled.\n * @private\n */\nclass BundledDocument {\n    constructor(metadata, document) {\n        this.metadata = metadata;\n        this.document = document;\n    }\n}\n/**\n * Validates that 'value' is DocumentSnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateDocumentSnapshot(arg, value) {\n    if (!(value instanceof document_1.DocumentSnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentSnapshot'));\n    }\n}\n/**\n * Validates that 'value' is QuerySnapshot.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The input to validate.\n */\nfunction validateQuerySnapshot(arg, value) {\n    if (!(value instanceof reference_1.QuerySnapshot)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'QuerySnapshot'));\n    }\n}\n//# sourceMappingURL=bundle.js.map"]},"metadata":{},"sourceType":"script"}