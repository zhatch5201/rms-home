{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\n/*!\n * @module common/paginator\n */\n\nvar arrify = require(\"arrify\");\n\nvar extend = require(\"extend\");\n\nvar resource_stream_1 = require(\"./resource-stream\");\n\nObject.defineProperty(exports, \"ResourceStream\", {\n  enumerable: true,\n  get: function get() {\n    return resource_stream_1.ResourceStream;\n  }\n});\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\n\nvar Paginator = /*#__PURE__*/function () {\n  function Paginator() {\n    _classCallCheck(this, Paginator);\n  }\n\n  _createClass(Paginator, [{\n    key: \"extend\",\n    value:\n    /**\n     * Cache the original method, then overwrite it on the Class's prototype.\n     *\n     * @param {function} Class - The parent class of the methods to extend.\n     * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n     */\n    // tslint:disable-next-line:variable-name\n    function extend(Class, methodNames) {\n      methodNames = arrify(methodNames);\n      methodNames.forEach(function (methodName) {\n        var originalMethod = Class.prototype[methodName]; // map the original method to a private member\n\n        Class.prototype[methodName + '_'] = originalMethod; // overwrite the original to auto-paginate\n\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n        Class.prototype[methodName] = function () {\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          var parsedArguments = paginator.parseArguments_(args);\n          return paginator.run_(parsedArguments, originalMethod.bind(this));\n        };\n      });\n    }\n    /**\n     * Wraps paginated API calls in a readable object stream.\n     *\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {string} methodName - Name of the method to streamify.\n     * @return {function} - Wrapped function.\n     */\n\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n  }, {\n    key: \"streamify\",\n    value: function streamify(methodName) {\n      return function () {\n        for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n          args[_key2] = arguments[_key2];\n        }\n\n        var parsedArguments = paginator.parseArguments_(args);\n        var originalMethod = this[methodName + '_'] || this[methodName];\n        return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n      };\n    }\n    /**\n     * Parse a pseudo-array `arguments` for a query and callback.\n     *\n     * @param {array} args - The original `arguments` pseduo-array that the original\n     *     method received.\n     */\n\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n  }, {\n    key: \"parseArguments_\",\n    value: function parseArguments_(args) {\n      var query;\n      var autoPaginate = true;\n      var maxApiCalls = -1;\n      var maxResults = -1;\n      var callback;\n      var firstArgument = args[0];\n      var lastArgument = args[args.length - 1];\n\n      if (typeof firstArgument === 'function') {\n        callback = firstArgument;\n      } else {\n        query = firstArgument;\n      }\n\n      if (typeof lastArgument === 'function') {\n        callback = lastArgument;\n      }\n\n      if (typeof query === 'object') {\n        query = extend(true, {}, query); // Check if the user only asked for a certain amount of results.\n\n        if (query.maxResults && typeof query.maxResults === 'number') {\n          // `maxResults` is used API-wide.\n          maxResults = query.maxResults;\n        } else if (typeof query.pageSize === 'number') {\n          // `pageSize` is Pub/Sub's `maxResults`.\n          maxResults = query.pageSize;\n        }\n\n        if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n          maxApiCalls = query.maxApiCalls;\n          delete query.maxApiCalls;\n        } // maxResults is the user specified limit.\n\n\n        if (maxResults !== -1 || query.autoPaginate === false) {\n          autoPaginate = false;\n        }\n      }\n\n      var parsedArguments = {\n        query: query || {},\n        autoPaginate: autoPaginate,\n        maxApiCalls: maxApiCalls,\n        maxResults: maxResults,\n        callback: callback\n      };\n      parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n      delete parsedArguments.streamOptions.autoPaginate;\n      delete parsedArguments.streamOptions.maxResults;\n      delete parsedArguments.streamOptions.pageSize;\n      return parsedArguments;\n    }\n    /**\n     * This simply checks to see if `autoPaginate` is set or not, if it's true\n     * then we buffer all results, otherwise simply call the original method.\n     *\n     * @param {array} parsedArguments - Parsed arguments from the original method\n     *     call.\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     */\n\n  }, {\n    key: \"run_\",\n    value: function run_(parsedArguments, originalMethod) {\n      var query = parsedArguments.query;\n      var callback = parsedArguments.callback;\n\n      if (!parsedArguments.autoPaginate) {\n        return originalMethod(query, callback);\n      }\n\n      var results = new Array();\n      var promise = new Promise(function (resolve, reject) {\n        paginator.runAsStream_(parsedArguments, originalMethod).on('error', reject).on('data', function (data) {\n          return results.push(data);\n        }).on('end', function () {\n          return resolve(results);\n        });\n      });\n\n      if (!callback) {\n        return promise.then(function (results) {\n          return [results];\n        });\n      }\n\n      promise.then(function (results) {\n        return callback(null, results);\n      }, function (err) {\n        return callback(err);\n      });\n    }\n    /**\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     * @return {stream} - Readable object stream.\n     */\n\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n\n  }, {\n    key: \"runAsStream_\",\n    value: function runAsStream_(parsedArguments, originalMethod) {\n      return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\n    }\n  }]);\n\n  return Paginator;\n}();\n\nexports.Paginator = Paginator;\nvar paginator = new Paginator();\nexports.paginator = paginator;","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/paginator/build/src/index.js"],"names":["Object","defineProperty","exports","value","ResourceStream","paginator","Paginator","arrify","require","extend","resource_stream_1","enumerable","get","Class","methodNames","forEach","methodName","originalMethod","prototype","args","parsedArguments","parseArguments_","run_","bind","runAsStream_","query","autoPaginate","maxApiCalls","maxResults","callback","firstArgument","lastArgument","length","pageSize","streamOptions","results","Array","promise","Promise","resolve","reject","on","data","push","then","err"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2015 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.ResourceStream = exports.paginator = exports.Paginator = void 0;\n/*!\n * @module common/paginator\n */\nconst arrify = require(\"arrify\");\nconst extend = require(\"extend\");\nconst resource_stream_1 = require(\"./resource-stream\");\nObject.defineProperty(exports, \"ResourceStream\", { enumerable: true, get: function () { return resource_stream_1.ResourceStream; } });\n/*! Developer Documentation\n *\n * paginator is used to auto-paginate `nextQuery` methods as well as\n * streamifying them.\n *\n * Before:\n *\n *   search.query('done=true', function(err, results, nextQuery) {\n *     search.query(nextQuery, function(err, results, nextQuery) {});\n *   });\n *\n * After:\n *\n *   search.query('done=true', function(err, results) {});\n *\n * Methods to extend should be written to accept callbacks and return a\n * `nextQuery`.\n */\nclass Paginator {\n    /**\n     * Cache the original method, then overwrite it on the Class's prototype.\n     *\n     * @param {function} Class - The parent class of the methods to extend.\n     * @param {string|string[]} methodNames - Name(s) of the methods to extend.\n     */\n    // tslint:disable-next-line:variable-name\n    extend(Class, methodNames) {\n        methodNames = arrify(methodNames);\n        methodNames.forEach(methodName => {\n            const originalMethod = Class.prototype[methodName];\n            // map the original method to a private member\n            Class.prototype[methodName + '_'] = originalMethod;\n            // overwrite the original to auto-paginate\n            /* eslint-disable  @typescript-eslint/no-explicit-any */\n            Class.prototype[methodName] = function (...args) {\n                const parsedArguments = paginator.parseArguments_(args);\n                return paginator.run_(parsedArguments, originalMethod.bind(this));\n            };\n        });\n    }\n    /**\n     * Wraps paginated API calls in a readable object stream.\n     *\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {string} methodName - Name of the method to streamify.\n     * @return {function} - Wrapped function.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    streamify(methodName) {\n        return function (\n        /* eslint-disable  @typescript-eslint/no-explicit-any */\n        ...args) {\n            const parsedArguments = paginator.parseArguments_(args);\n            const originalMethod = this[methodName + '_'] || this[methodName];\n            return paginator.runAsStream_(parsedArguments, originalMethod.bind(this));\n        };\n    }\n    /**\n     * Parse a pseudo-array `arguments` for a query and callback.\n     *\n     * @param {array} args - The original `arguments` pseduo-array that the original\n     *     method received.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    parseArguments_(args) {\n        let query;\n        let autoPaginate = true;\n        let maxApiCalls = -1;\n        let maxResults = -1;\n        let callback;\n        const firstArgument = args[0];\n        const lastArgument = args[args.length - 1];\n        if (typeof firstArgument === 'function') {\n            callback = firstArgument;\n        }\n        else {\n            query = firstArgument;\n        }\n        if (typeof lastArgument === 'function') {\n            callback = lastArgument;\n        }\n        if (typeof query === 'object') {\n            query = extend(true, {}, query);\n            // Check if the user only asked for a certain amount of results.\n            if (query.maxResults && typeof query.maxResults === 'number') {\n                // `maxResults` is used API-wide.\n                maxResults = query.maxResults;\n            }\n            else if (typeof query.pageSize === 'number') {\n                // `pageSize` is Pub/Sub's `maxResults`.\n                maxResults = query.pageSize;\n            }\n            if (query.maxApiCalls && typeof query.maxApiCalls === 'number') {\n                maxApiCalls = query.maxApiCalls;\n                delete query.maxApiCalls;\n            }\n            // maxResults is the user specified limit.\n            if (maxResults !== -1 || query.autoPaginate === false) {\n                autoPaginate = false;\n            }\n        }\n        const parsedArguments = {\n            query: query || {},\n            autoPaginate,\n            maxApiCalls,\n            maxResults,\n            callback,\n        };\n        parsedArguments.streamOptions = extend(true, {}, parsedArguments.query);\n        delete parsedArguments.streamOptions.autoPaginate;\n        delete parsedArguments.streamOptions.maxResults;\n        delete parsedArguments.streamOptions.pageSize;\n        return parsedArguments;\n    }\n    /**\n     * This simply checks to see if `autoPaginate` is set or not, if it's true\n     * then we buffer all results, otherwise simply call the original method.\n     *\n     * @param {array} parsedArguments - Parsed arguments from the original method\n     *     call.\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     */\n    run_(parsedArguments, originalMethod) {\n        const query = parsedArguments.query;\n        const callback = parsedArguments.callback;\n        if (!parsedArguments.autoPaginate) {\n            return originalMethod(query, callback);\n        }\n        const results = new Array();\n        const promise = new Promise((resolve, reject) => {\n            paginator\n                .runAsStream_(parsedArguments, originalMethod)\n                .on('error', reject)\n                .on('data', (data) => results.push(data))\n                .on('end', () => resolve(results));\n        });\n        if (!callback) {\n            return promise.then(results => [results]);\n        }\n        promise.then(results => callback(null, results), (err) => callback(err));\n    }\n    /**\n     * This method simply calls the nextQuery recursively, emitting results to a\n     * stream. The stream ends when `nextQuery` is null.\n     *\n     * `maxResults` will act as a cap for how many results are fetched and emitted\n     * to the stream.\n     *\n     * @param {object=|string=} parsedArguments.query - Query object. This is most\n     *     commonly an object, but to make the API more simple, it can also be a\n     *     string in some places.\n     * @param {function=} parsedArguments.callback - Callback function.\n     * @param {boolean} parsedArguments.autoPaginate - Auto-pagination enabled.\n     * @param {boolean} parsedArguments.maxApiCalls - Maximum API calls to make.\n     * @param {number} parsedArguments.maxResults - Maximum results to return.\n     * @param {function} originalMethod - The cached method that accepts a callback\n     *     and returns `nextQuery` to receive more results.\n     * @return {stream} - Readable object stream.\n     */\n    /* eslint-disable  @typescript-eslint/no-explicit-any */\n    runAsStream_(parsedArguments, originalMethod) {\n        return new resource_stream_1.ResourceStream(parsedArguments, originalMethod);\n    }\n}\nexports.Paginator = Paginator;\nconst paginator = new Paginator();\nexports.paginator = paginator;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}