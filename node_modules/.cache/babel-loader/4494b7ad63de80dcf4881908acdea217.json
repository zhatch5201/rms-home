{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _inherits = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.operation = exports.Operation = void 0;\n\nvar events_1 = require(\"events\");\n\nvar status_1 = require(\"../status\");\n\nvar googleError_1 = require(\"../googleError\");\n\nvar operationProtos = require(\"../../protos/operations\");\n\nvar Operation = /*#__PURE__*/function (_events_1$EventEmitte) {\n  _inherits(Operation, _events_1$EventEmitte);\n\n  var _super = _createSuper(Operation);\n\n  /**\n   * Wrapper for a google.longrunnung.Operation.\n   *\n   * @constructor\n   *\n   * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\n   * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n   * operations service client and unpacking mechanisms for the operation.\n   * @param {BackoffSettings} backoffSettings - The backoff settings used in\n   * in polling the operation.\n   * @param {CallOptions} callOptions - CallOptions used in making get operation\n   * requests.\n   */\n  function Operation(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\n    var _this;\n\n    _classCallCheck(this, Operation);\n\n    _this = _super.call(this);\n    _this.completeListeners = 0;\n    _this.hasActiveListeners = false;\n    _this.latestResponse = grpcOp;\n    _this.name = _this.latestResponse.name;\n    _this.done = _this.latestResponse.done;\n    _this.error = _this.latestResponse.error;\n    _this.longrunningDescriptor = longrunningDescriptor;\n    _this.result = null;\n    _this.metadata = null;\n    _this.backoffSettings = backoffSettings;\n\n    _this._unpackResponse(grpcOp);\n\n    _this._listenForEvents();\n\n    _this._callOptions = callOptions;\n    return _this;\n  }\n  /**\n   * Begin listening for events on the operation. This method keeps track of how\n   * many \"complete\" listeners are registered and removed, making sure polling\n   * is handled automatically.\n   *\n   * As long as there is one active \"complete\" listener, the connection is open.\n   * When there are no more listeners, the polling stops.\n   *\n   * @private\n   */\n\n\n  _createClass(Operation, [{\n    key: \"_listenForEvents\",\n    value: function _listenForEvents() {\n      var _this2 = this;\n\n      this.on('newListener', function (event) {\n        if (event === 'complete') {\n          _this2.completeListeners++;\n\n          if (!_this2.hasActiveListeners) {\n            _this2.hasActiveListeners = true;\n\n            _this2.startPolling_();\n          }\n        }\n      });\n      this.on('removeListener', function (event) {\n        if (event === 'complete' && --_this2.completeListeners === 0) {\n          _this2.hasActiveListeners = false;\n        }\n      });\n    }\n    /**\n     * Cancels current polling api call and cancels the operation.\n     *\n     * @return {Promise} the promise of the OperationsClient#cancelOperation api\n     * request.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      if (this.currentCallPromise_) {\n        this.currentCallPromise_.cancel();\n      }\n\n      var operationsClient = this.longrunningDescriptor.operationsClient;\n      var cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\n      cancelRequest.name = this.latestResponse.name;\n      return operationsClient.cancelOperation(cancelRequest);\n    }\n  }, {\n    key: \"getOperation\",\n    value: function getOperation(callback) {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var self = this;\n      var operationsClient = this.longrunningDescriptor.operationsClient;\n\n      function promisifyResponse() {\n        if (!callback) {\n          return new Promise(function (resolve, reject) {\n            if (self.latestResponse.error) {\n              var error = new googleError_1.GoogleError(self.latestResponse.error.message);\n              error.code = self.latestResponse.error.code;\n              reject(error);\n            } else {\n              resolve([self.result, self.metadata, self.latestResponse]);\n            }\n          });\n        }\n\n        return;\n      }\n\n      if (this.latestResponse.done) {\n        this._unpackResponse(this.latestResponse, callback);\n\n        return promisifyResponse();\n      }\n\n      var request = new operationProtos.google.longrunning.GetOperationRequest();\n      request.name = this.latestResponse.name;\n      this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\n      var noCallbackPromise = this.currentCallPromise_.then(function (responses) {\n        self.latestResponse = responses[0];\n\n        self._unpackResponse(responses[0], callback);\n\n        return promisifyResponse();\n      });\n\n      if (!callback) {\n        return noCallbackPromise;\n      }\n    }\n  }, {\n    key: \"_unpackResponse\",\n    value: function _unpackResponse(op, callback) {\n      var responseDecoder = this.longrunningDescriptor.responseDecoder;\n      var metadataDecoder = this.longrunningDescriptor.metadataDecoder;\n      var response;\n      var metadata;\n\n      if (op.done) {\n        if (op.result === 'error') {\n          var error = new googleError_1.GoogleError(op.error.message);\n          error.code = op.error.code;\n          this.error = error;\n\n          if (callback) {\n            callback(error);\n          }\n\n          return;\n        }\n\n        if (responseDecoder && op.response) {\n          this.response = op.response;\n          response = responseDecoder(op.response.value);\n          this.result = response;\n          this.done = true;\n        }\n      }\n\n      if (metadataDecoder && op.metadata) {\n        metadata = metadataDecoder(op.metadata.value);\n        this.metadata = metadata;\n      }\n\n      if (callback) {\n        callback(null, response, metadata, op);\n      }\n    }\n    /**\n     * Poll `getOperation` to check the operation's status. This runs a loop to\n     * ping using the backoff strategy specified at initialization.\n     *\n     * Note: This method is automatically called once a \"complete\" event handler\n     * is registered on the operation.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"startPolling_\",\n    value: function startPolling_() {\n      // eslint-disable-next-line @typescript-eslint/no-this-alias\n      var self = this;\n      var now = new Date();\n      var delayMult = this.backoffSettings.retryDelayMultiplier;\n      var maxDelay = this.backoffSettings.maxRetryDelayMillis;\n      var delay = this.backoffSettings.initialRetryDelayMillis;\n      var deadline = Infinity;\n\n      if (this.backoffSettings.totalTimeoutMillis) {\n        deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\n      }\n\n      var previousMetadataBytes;\n\n      if (this.latestResponse.metadata) {\n        previousMetadataBytes = this.latestResponse.metadata.value;\n      } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n      function emit(event) {\n        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n          args[_key - 1] = arguments[_key];\n        }\n\n        self.emit.apply(self, [event].concat(args));\n      } // Helper function to replace nodejs buffer's equals()\n\n\n      function arrayEquals(a, b) {\n        if (a.byteLength !== b.byteLength) {\n          return false;\n        }\n\n        for (var i = 0; i < a.byteLength; ++i) {\n          if (a[i] !== b[i]) return false;\n        }\n\n        return true;\n      }\n\n      function retry() {\n        if (!self.hasActiveListeners) {\n          return;\n        }\n\n        if (now.getTime() >= deadline) {\n          var error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\n          error.code = status_1.Status.DEADLINE_EXCEEDED;\n          setImmediate(emit, 'error', error);\n          return;\n        }\n\n        self.getOperation(function (err, result, metadata, rawResponse) {\n          if (err) {\n            setImmediate(emit, 'error', err);\n            return;\n          }\n\n          if (!result) {\n            if (rawResponse.metadata && (!previousMetadataBytes || rawResponse && !arrayEquals(rawResponse.metadata.value, previousMetadataBytes))) {\n              setImmediate(emit, 'progress', metadata, rawResponse);\n              previousMetadataBytes = rawResponse.metadata.value;\n            } // special case: some APIs fail to set either result or error\n            // but set done = true (e.g. speech with silent file).\n            // Don't hang forever in this case.\n\n\n            if (rawResponse.done) {\n              var _error = new googleError_1.GoogleError('Long running operation has finished but there was no result');\n\n              _error.code = status_1.Status.UNKNOWN;\n              setImmediate(emit, 'error', _error);\n              return;\n            }\n\n            setTimeout(function () {\n              now = new Date();\n              delay = Math.min(delay * delayMult, maxDelay);\n              retry();\n            }, delay);\n            return;\n          }\n\n          setImmediate(emit, 'complete', result, metadata, rawResponse);\n        });\n      }\n\n      retry();\n    }\n    /**\n     * Wraps the `complete` and `error` events in a Promise.\n     *\n     * @return {promise} - Promise that resolves on operation completion and rejects\n     * on operation error.\n     */\n\n  }, {\n    key: \"promise\",\n    value: function promise() {\n      var _this3 = this;\n\n      return new Promise(function (resolve, reject) {\n        _this3.on('error', reject).on('complete', function (result, metadata, rawResponse) {\n          resolve([result, metadata, rawResponse]);\n        });\n      });\n    }\n  }]);\n\n  return Operation;\n}(events_1.EventEmitter);\n\nexports.Operation = Operation;\n/**\n * Method used to create Operation objects.\n *\n * @constructor\n *\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\n * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n * operations service client and unpacking mechanisms for the operation.\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\n * in polling the operation.\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\n * requests.\n */\n\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\n  return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\n}\n\nexports.operation = operation;","map":{"version":3,"sources":["../../../src/longRunningCalls/longrunning.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.operation = exports.Operation = void 0;\nconst events_1 = require(\"events\");\nconst status_1 = require(\"../status\");\nconst googleError_1 = require(\"../googleError\");\nconst operationProtos = require(\"../../protos/operations\");\nclass Operation extends events_1.EventEmitter {\n    /**\n     * Wrapper for a google.longrunnung.Operation.\n     *\n     * @constructor\n     *\n     * @param {google.longrunning.Operation} grpcOp - The operation to be wrapped.\n     * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n     * operations service client and unpacking mechanisms for the operation.\n     * @param {BackoffSettings} backoffSettings - The backoff settings used in\n     * in polling the operation.\n     * @param {CallOptions} callOptions - CallOptions used in making get operation\n     * requests.\n     */\n    constructor(grpcOp, longrunningDescriptor, backoffSettings, callOptions) {\n        super();\n        this.completeListeners = 0;\n        this.hasActiveListeners = false;\n        this.latestResponse = grpcOp;\n        this.name = this.latestResponse.name;\n        this.done = this.latestResponse.done;\n        this.error = this.latestResponse.error;\n        this.longrunningDescriptor = longrunningDescriptor;\n        this.result = null;\n        this.metadata = null;\n        this.backoffSettings = backoffSettings;\n        this._unpackResponse(grpcOp);\n        this._listenForEvents();\n        this._callOptions = callOptions;\n    }\n    /**\n     * Begin listening for events on the operation. This method keeps track of how\n     * many \"complete\" listeners are registered and removed, making sure polling\n     * is handled automatically.\n     *\n     * As long as there is one active \"complete\" listener, the connection is open.\n     * When there are no more listeners, the polling stops.\n     *\n     * @private\n     */\n    _listenForEvents() {\n        this.on('newListener', event => {\n            if (event === 'complete') {\n                this.completeListeners++;\n                if (!this.hasActiveListeners) {\n                    this.hasActiveListeners = true;\n                    this.startPolling_();\n                }\n            }\n        });\n        this.on('removeListener', event => {\n            if (event === 'complete' && --this.completeListeners === 0) {\n                this.hasActiveListeners = false;\n            }\n        });\n    }\n    /**\n     * Cancels current polling api call and cancels the operation.\n     *\n     * @return {Promise} the promise of the OperationsClient#cancelOperation api\n     * request.\n     */\n    cancel() {\n        if (this.currentCallPromise_) {\n            this.currentCallPromise_.cancel();\n        }\n        const operationsClient = this.longrunningDescriptor.operationsClient;\n        const cancelRequest = new operationProtos.google.longrunning.CancelOperationRequest();\n        cancelRequest.name = this.latestResponse.name;\n        return operationsClient.cancelOperation(cancelRequest);\n    }\n    getOperation(callback) {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        const operationsClient = this.longrunningDescriptor.operationsClient;\n        function promisifyResponse() {\n            if (!callback) {\n                return new Promise((resolve, reject) => {\n                    if (self.latestResponse.error) {\n                        const error = new googleError_1.GoogleError(self.latestResponse.error.message);\n                        error.code = self.latestResponse.error.code;\n                        reject(error);\n                    }\n                    else {\n                        resolve([self.result, self.metadata, self.latestResponse]);\n                    }\n                });\n            }\n            return;\n        }\n        if (this.latestResponse.done) {\n            this._unpackResponse(this.latestResponse, callback);\n            return promisifyResponse();\n        }\n        const request = new operationProtos.google.longrunning.GetOperationRequest();\n        request.name = this.latestResponse.name;\n        this.currentCallPromise_ = operationsClient.getOperationInternal(request, this._callOptions);\n        const noCallbackPromise = this.currentCallPromise_.then(responses => {\n            self.latestResponse = responses[0];\n            self._unpackResponse(responses[0], callback);\n            return promisifyResponse();\n        });\n        if (!callback) {\n            return noCallbackPromise;\n        }\n    }\n    _unpackResponse(op, callback) {\n        const responseDecoder = this.longrunningDescriptor.responseDecoder;\n        const metadataDecoder = this.longrunningDescriptor.metadataDecoder;\n        let response;\n        let metadata;\n        if (op.done) {\n            if (op.result === 'error') {\n                const error = new googleError_1.GoogleError(op.error.message);\n                error.code = op.error.code;\n                this.error = error;\n                if (callback) {\n                    callback(error);\n                }\n                return;\n            }\n            if (responseDecoder && op.response) {\n                this.response = op.response;\n                response = responseDecoder(op.response.value);\n                this.result = response;\n                this.done = true;\n            }\n        }\n        if (metadataDecoder && op.metadata) {\n            metadata = metadataDecoder(op.metadata.value);\n            this.metadata = metadata;\n        }\n        if (callback) {\n            callback(null, response, metadata, op);\n        }\n    }\n    /**\n     * Poll `getOperation` to check the operation's status. This runs a loop to\n     * ping using the backoff strategy specified at initialization.\n     *\n     * Note: This method is automatically called once a \"complete\" event handler\n     * is registered on the operation.\n     *\n     * @private\n     */\n    startPolling_() {\n        // eslint-disable-next-line @typescript-eslint/no-this-alias\n        const self = this;\n        let now = new Date();\n        const delayMult = this.backoffSettings.retryDelayMultiplier;\n        const maxDelay = this.backoffSettings.maxRetryDelayMillis;\n        let delay = this.backoffSettings.initialRetryDelayMillis;\n        let deadline = Infinity;\n        if (this.backoffSettings.totalTimeoutMillis) {\n            deadline = now.getTime() + this.backoffSettings.totalTimeoutMillis;\n        }\n        let previousMetadataBytes;\n        if (this.latestResponse.metadata) {\n            previousMetadataBytes = this.latestResponse.metadata.value;\n        }\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        function emit(event, ...args) {\n            self.emit(event, ...args);\n        }\n        // Helper function to replace nodejs buffer's equals()\n        function arrayEquals(a, b) {\n            if (a.byteLength !== b.byteLength) {\n                return false;\n            }\n            for (let i = 0; i < a.byteLength; ++i) {\n                if (a[i] !== b[i])\n                    return false;\n            }\n            return true;\n        }\n        function retry() {\n            if (!self.hasActiveListeners) {\n                return;\n            }\n            if (now.getTime() >= deadline) {\n                const error = new googleError_1.GoogleError('Total timeout exceeded before any response was received');\n                error.code = status_1.Status.DEADLINE_EXCEEDED;\n                setImmediate(emit, 'error', error);\n                return;\n            }\n            self.getOperation((err, result, metadata, rawResponse) => {\n                if (err) {\n                    setImmediate(emit, 'error', err);\n                    return;\n                }\n                if (!result) {\n                    if (rawResponse.metadata &&\n                        (!previousMetadataBytes ||\n                            (rawResponse &&\n                                !arrayEquals(rawResponse.metadata.value, previousMetadataBytes)))) {\n                        setImmediate(emit, 'progress', metadata, rawResponse);\n                        previousMetadataBytes = rawResponse.metadata.value;\n                    }\n                    // special case: some APIs fail to set either result or error\n                    // but set done = true (e.g. speech with silent file).\n                    // Don't hang forever in this case.\n                    if (rawResponse.done) {\n                        const error = new googleError_1.GoogleError('Long running operation has finished but there was no result');\n                        error.code = status_1.Status.UNKNOWN;\n                        setImmediate(emit, 'error', error);\n                        return;\n                    }\n                    setTimeout(() => {\n                        now = new Date();\n                        delay = Math.min(delay * delayMult, maxDelay);\n                        retry();\n                    }, delay);\n                    return;\n                }\n                setImmediate(emit, 'complete', result, metadata, rawResponse);\n            });\n        }\n        retry();\n    }\n    /**\n     * Wraps the `complete` and `error` events in a Promise.\n     *\n     * @return {promise} - Promise that resolves on operation completion and rejects\n     * on operation error.\n     */\n    promise() {\n        return new Promise((resolve, reject) => {\n            this.on('error', reject).on('complete', (result, metadata, rawResponse) => {\n                resolve([result, metadata, rawResponse]);\n            });\n        });\n    }\n}\nexports.Operation = Operation;\n/**\n * Method used to create Operation objects.\n *\n * @constructor\n *\n * @param {google.longrunning.Operation} op - The operation to be wrapped.\n * @param {LongRunningDescriptor} longrunningDescriptor - This defines the\n * operations service client and unpacking mechanisms for the operation.\n * @param {BackoffSettings} backoffSettings - The backoff settings used in\n * in polling the operation.\n * @param {CallOptions=} callOptions - CallOptions used in making get operation\n * requests.\n */\nfunction operation(op, longrunningDescriptor, backoffSettings, callOptions) {\n    return new Operation(op, longrunningDescriptor, backoffSettings, callOptions);\n}\nexports.operation = operation;\n//# sourceMappingURL=longrunning.js.map"]},"metadata":{},"sourceType":"script"}