{"ast":null,"code":"\"use strict\";\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar reference_1 = require(\"./reference\");\n\nvar path_1 = require(\"./path\");\n\nvar serializer_1 = require(\"./serializer\");\n/**\n * A split point that can be used in a query as a starting and/or end point for\n * the query results. The cursors returned by {@link #startAt} and {@link\n * #endBefore} can only be used in a query that matches the constraint of query\n * that produced this partition.\n *\n * @class QueryPartition\n */\n\n\nvar QueryPartition = /*#__PURE__*/function () {\n  /** @hideconstructor */\n  function QueryPartition(_firestore, _collectionId, _converter, _startAt, _endBefore) {\n    _classCallCheck(this, QueryPartition);\n\n    this._firestore = _firestore;\n    this._collectionId = _collectionId;\n    this._converter = _converter;\n    this._startAt = _startAt;\n    this._endBefore = _endBefore;\n    this._serializer = new serializer_1.Serializer(_firestore);\n  }\n  /**\n   * The cursor that defines the first result for this partition or `undefined`\n   * if this is the first partition. The cursor value must be\n   * destructured when passed to `startAt()` (for example with\n   * `query.startAt(...queryPartition.startAt)`).\n   *\n   * @example\n   * const query = firestore.collectionGroup('collectionId');\n   * for await (const partition of query.getPartitions(42)) {\n   *   let partitionedQuery = query.orderBy(FieldPath.documentId());\n   *   if (partition.startAt) {\n   *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\n   *   }\n   *   if (partition.endBefore) {\n   *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\n   *   }\n   *   const querySnapshot = await partitionedQuery.get();\n   *   console.log(`Partition contained ${querySnapshot.length} documents`);\n   * }\n   *\n   * @type {Array<*>}\n   * @return {Array<*>} A cursor value that can be used with {@link\n   * Query#startAt} or `undefined` if this is the first partition.\n   */\n\n\n  _createClass(QueryPartition, [{\n    key: \"startAt\",\n    get: function get() {\n      var _this = this;\n\n      if (this._startAt && !this._memoizedStartAt) {\n        this._memoizedStartAt = this._startAt.map(function (v) {\n          return _this._serializer.decodeValue(v);\n        });\n      }\n\n      return this._memoizedStartAt;\n    }\n    /**\n     * The cursor that defines the first result after this partition or\n     * `undefined` if this is the last partition.  The cursor value must be\n     * destructured when passed to `endBefore()` (for example with\n     * `query.endBefore(...queryPartition.endBefore)`).\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\n     *   if (partition.startAt) {\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\n     *   }\n     *   if (partition.endBefore) {\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\n     *   }\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @type {Array<*>}\n     * @return {Array<*>} A cursor value that can be used with {@link\n     * Query#endBefore} or `undefined` if this is the last partition.\n     */\n\n  }, {\n    key: \"endBefore\",\n    get: function get() {\n      var _this2 = this;\n\n      if (this._endBefore && !this._memoizedEndBefore) {\n        this._memoizedEndBefore = this._endBefore.map(function (v) {\n          return _this2._serializer.decodeValue(v);\n        });\n      }\n\n      return this._memoizedEndBefore;\n    }\n    /**\n     * Returns a query that only encapsulates the documents for this partition.\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   const partitionedQuery = partition.toQuery();\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\n     * {@link Query#endBefore} cursor.\n     */\n\n  }, {\n    key: \"toQuery\",\n    value: function toQuery() {\n      // Since the api.Value to JavaScript type conversion can be lossy (unless\n      // `useBigInt` is used), we pass the original protobuf representaion to the\n      // created query.\n      var queryOptions = reference_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\n      queryOptions = queryOptions.with({\n        fieldOrders: [new reference_1.FieldOrder(path_1.FieldPath.documentId())]\n      });\n\n      if (this._startAt !== undefined) {\n        queryOptions = queryOptions.with({\n          startAt: {\n            before: true,\n            values: this._startAt\n          }\n        });\n      }\n\n      if (this._endBefore !== undefined) {\n        queryOptions = queryOptions.with({\n          endAt: {\n            before: true,\n            values: this._endBefore\n          }\n        });\n      }\n\n      return new reference_1.Query(this._firestore, queryOptions);\n    }\n  }]);\n\n  return QueryPartition;\n}();\n\nexports.QueryPartition = QueryPartition;","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/firestore/build/src/query-partition.js"],"names":["Object","defineProperty","exports","value","reference_1","require","path_1","serializer_1","QueryPartition","_firestore","_collectionId","_converter","_startAt","_endBefore","_serializer","Serializer","_memoizedStartAt","map","v","decodeValue","_memoizedEndBefore","queryOptions","QueryOptions","forCollectionGroupQuery","with","fieldOrders","FieldOrder","FieldPath","documentId","undefined","startAt","before","values","endAt","Query"],"mappings":"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","sourcesContent":["\"use strict\";\n/*\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *       http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst reference_1 = require(\"./reference\");\nconst path_1 = require(\"./path\");\nconst serializer_1 = require(\"./serializer\");\n/**\n * A split point that can be used in a query as a starting and/or end point for\n * the query results. The cursors returned by {@link #startAt} and {@link\n * #endBefore} can only be used in a query that matches the constraint of query\n * that produced this partition.\n *\n * @class QueryPartition\n */\nclass QueryPartition {\n    /** @hideconstructor */\n    constructor(_firestore, _collectionId, _converter, _startAt, _endBefore) {\n        this._firestore = _firestore;\n        this._collectionId = _collectionId;\n        this._converter = _converter;\n        this._startAt = _startAt;\n        this._endBefore = _endBefore;\n        this._serializer = new serializer_1.Serializer(_firestore);\n    }\n    /**\n     * The cursor that defines the first result for this partition or `undefined`\n     * if this is the first partition. The cursor value must be\n     * destructured when passed to `startAt()` (for example with\n     * `query.startAt(...queryPartition.startAt)`).\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\n     *   if (partition.startAt) {\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\n     *   }\n     *   if (partition.endBefore) {\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\n     *   }\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @type {Array<*>}\n     * @return {Array<*>} A cursor value that can be used with {@link\n     * Query#startAt} or `undefined` if this is the first partition.\n     */\n    get startAt() {\n        if (this._startAt && !this._memoizedStartAt) {\n            this._memoizedStartAt = this._startAt.map(v => this._serializer.decodeValue(v));\n        }\n        return this._memoizedStartAt;\n    }\n    /**\n     * The cursor that defines the first result after this partition or\n     * `undefined` if this is the last partition.  The cursor value must be\n     * destructured when passed to `endBefore()` (for example with\n     * `query.endBefore(...queryPartition.endBefore)`).\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   let partitionedQuery = query.orderBy(FieldPath.documentId());\n     *   if (partition.startAt) {\n     *     partitionedQuery = partitionedQuery.startAt(...partition.startAt);\n     *   }\n     *   if (partition.endBefore) {\n     *     partitionedQuery = partitionedQuery.endBefore(...partition.endBefore);\n     *   }\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @type {Array<*>}\n     * @return {Array<*>} A cursor value that can be used with {@link\n     * Query#endBefore} or `undefined` if this is the last partition.\n     */\n    get endBefore() {\n        if (this._endBefore && !this._memoizedEndBefore) {\n            this._memoizedEndBefore = this._endBefore.map(v => this._serializer.decodeValue(v));\n        }\n        return this._memoizedEndBefore;\n    }\n    /**\n     * Returns a query that only encapsulates the documents for this partition.\n     *\n     * @example\n     * const query = firestore.collectionGroup('collectionId');\n     * for await (const partition of query.getPartitions(42)) {\n     *   const partitionedQuery = partition.toQuery();\n     *   const querySnapshot = await partitionedQuery.get();\n     *   console.log(`Partition contained ${querySnapshot.length} documents`);\n     * }\n     *\n     * @return {Query<T>} A query partitioned by a {@link Query#startAt} and\n     * {@link Query#endBefore} cursor.\n     */\n    toQuery() {\n        // Since the api.Value to JavaScript type conversion can be lossy (unless\n        // `useBigInt` is used), we pass the original protobuf representaion to the\n        // created query.\n        let queryOptions = reference_1.QueryOptions.forCollectionGroupQuery(this._collectionId, this._converter);\n        queryOptions = queryOptions.with({\n            fieldOrders: [new reference_1.FieldOrder(path_1.FieldPath.documentId())],\n        });\n        if (this._startAt !== undefined) {\n            queryOptions = queryOptions.with({\n                startAt: { before: true, values: this._startAt },\n            });\n        }\n        if (this._endBefore !== undefined) {\n            queryOptions = queryOptions.with({\n                endAt: { before: true, values: this._endBefore },\n            });\n        }\n        return new reference_1.Query(this._firestore, queryOptions);\n    }\n}\nexports.QueryPartition = QueryPartition;\n//# sourceMappingURL=query-partition.js.map"]},"metadata":{},"sourceType":"script"}