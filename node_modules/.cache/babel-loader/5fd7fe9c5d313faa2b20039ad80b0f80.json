{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _get2 = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\n\nvar _getPrototypeOf = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\n\nvar _inherits = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _regeneratorRuntime = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _slicedToArray = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar stream_1 = require(\"stream\");\n\nvar deepEqual = require(\"fast-deep-equal\");\n\nvar document_1 = require(\"./document\");\n\nvar document_change_1 = require(\"./document-change\");\n\nvar logger_1 = require(\"./logger\");\n\nvar order_1 = require(\"./order\");\n\nvar path_1 = require(\"./path\");\n\nvar serializer_1 = require(\"./serializer\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar types_1 = require(\"./types\");\n\nvar util_1 = require(\"./util\");\n\nvar validate_1 = require(\"./validate\");\n\nvar watch_1 = require(\"./watch\");\n\nvar write_batch_1 = require(\"./write-batch\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n */\n\n\nvar directionOperators = {\n  asc: 'ASCENDING',\n  desc: 'DESCENDING'\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in', 'not-in',\n * and 'array-contains-any'.\n *\n * @private\n */\n\nvar comparisonOperators = {\n  '<': 'LESS_THAN',\n  '<=': 'LESS_THAN_OR_EQUAL',\n  '==': 'EQUAL',\n  '!=': 'NOT_EQUAL',\n  '>': 'GREATER_THAN',\n  '>=': 'GREATER_THAN_OR_EQUAL',\n  'array-contains': 'ARRAY_CONTAINS',\n  in: 'IN',\n  'not-in': 'NOT_IN',\n  'array-contains-any': 'ARRAY_CONTAINS_ANY'\n};\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\n\nvar DocumentReference = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _path The Path of this reference.\n   */\n  function DocumentReference(_firestore, _path) {\n    var _converter = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : types_1.defaultConverter();\n\n    _classCallCheck(this, DocumentReference);\n\n    this._firestore = _firestore;\n    this._path = _path;\n    this._converter = _converter;\n  }\n  /**\n   * The string representation of the DocumentReference's location.\n   * @private\n   * @type {string}\n   * @name DocumentReference#formattedName\n   */\n\n\n  _createClass(DocumentReference, [{\n    key: \"formattedName\",\n    get: function get() {\n      var projectId = this.firestore.projectId;\n      return this._path.toQualifiedResourcePath(projectId).formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n\n  }, {\n    key: \"firestore\",\n    get: function get() {\n      return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     */\n\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._path.id;\n    }\n    /**\n     * Returns a resource path for this document.\n     * @private\n     */\n\n  }, {\n    key: \"_resourcePath\",\n    get: function get() {\n      return this._path;\n    }\n    /**\n     * A reference to the collection to which this DocumentRference belongs.\n     *e\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._firestore.getAll(this).then(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 1),\n            result = _ref2[0];\n\n        return result;\n      });\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     */\n\n  }, {\n    key: \"collection\",\n    value: function collection(collectionPath) {\n      path_1.validateResourcePath('collectionPath', collectionPath);\n\n      var path = this._path.append(collectionPath);\n\n      if (!path.isCollection) {\n        throw new Error(\"Value for argument \\\"collectionPath\\\" must point to a collection, but was \\\"\".concat(collectionPath, \"\\\". Your path does not contain an odd number of components.\"));\n      }\n\n      return new CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"listCollections\",\n    value: function listCollections() {\n      var _this = this;\n\n      var tag = util_1.requestTag();\n      return this.firestore.initializeIfNeeded(tag).then(function () {\n        var request = {\n          parent: _this.formattedName,\n          // Setting `pageSize` to an arbitrarily large value lets the backend cap\n          // the page size (currently to 300). Note that the backend rejects\n          // MAX_INT32 (b/146883794).\n          pageSize: Math.pow(2, 16) - 1\n        };\n        return _this._firestore.request('listCollectionIds', request, tag).then(function (collectionIds) {\n          var collections = []; // We can just sort this list using the default comparator since it\n          // will only contain collection ids.\n\n          collectionIds.sort();\n\n          var _iterator = _createForOfIteratorHelper(collectionIds),\n              _step;\n\n          try {\n            for (_iterator.s(); !(_step = _iterator.n()).done;) {\n              var collectionId = _step.value;\n              collections.push(_this.collection(collectionId));\n            }\n          } catch (err) {\n            _iterator.e(err);\n          } finally {\n            _iterator.f();\n          }\n\n          return collections;\n        });\n      });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     */\n\n  }, {\n    key: \"create\",\n    value: function create(data) {\n      var writeBatch = new write_batch_1.WriteBatch(this._firestore);\n      return writeBatch.create(this, data).commit().then(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 1),\n            writeResult = _ref4[0];\n\n        return writeResult;\n      });\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     */\n\n  }, {\n    key: \"delete\",\n    value: function _delete(precondition) {\n      var writeBatch = new write_batch_1.WriteBatch(this._firestore);\n      return writeBatch.delete(this, precondition).commit().then(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 1),\n            writeResult = _ref6[0];\n\n        return writeResult;\n      });\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T|Partial<T>} data A map of the fields and values for the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     */\n\n  }, {\n    key: \"set\",\n    value: function set(data, options) {\n      var writeBatch = new write_batch_1.WriteBatch(this._firestore);\n      return writeBatch.set(this, data, options).commit().then(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 1),\n            writeResult = _ref8[0];\n\n        return writeResult;\n      });\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     */\n\n  }, {\n    key: \"update\",\n    value: function update(dataOrField) {\n      for (var _len = arguments.length, preconditionOrValues = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        preconditionOrValues[_key - 1] = arguments[_key];\n      }\n\n      // eslint-disable-next-line prefer-rest-params\n      validate_1.validateMinNumberOfArguments('DocumentReference.update', arguments, 1);\n      var writeBatch = new write_batch_1.WriteBatch(this._firestore);\n      return writeBatch.update.apply(writeBatch, [this, dataOrField].concat(preconditionOrValues)).commit().then(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 1),\n            writeResult = _ref10[0];\n\n        return writeResult;\n      });\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n\n  }, {\n    key: \"onSnapshot\",\n    value: function onSnapshot(onNext, onError) {\n      var _this2 = this;\n\n      validate_1.validateFunction('onNext', onNext);\n      validate_1.validateFunction('onError', onError, {\n        optional: true\n      });\n      var watch = new watch_1.DocumentWatch(this.firestore, this);\n      return watch.onSnapshot(function (readTime, size, docs) {\n        var _iterator2 = _createForOfIteratorHelper(docs()),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _document = _step2.value;\n\n            if (_document.ref.path === _this2.path) {\n              onNext(_document);\n              return;\n            }\n          } // The document is missing.\n\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n\n        var ref = new DocumentReference(_this2._firestore, _this2._path, _this2._converter);\n        var document = new document_1.DocumentSnapshotBuilder(ref);\n        document.readTime = readTime;\n        onNext(document.build());\n      }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      return this === other || other instanceof DocumentReference && this._firestore === other._firestore && this._path.isEqual(other._path) && this._converter === other._converter;\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto() {\n      return {\n        referenceValue: this.formattedName\n      };\n    }\n  }, {\n    key: \"withConverter\",\n    value: function withConverter(converter) {\n      return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : types_1.defaultConverter());\n    }\n  }]);\n\n  return DocumentReference;\n}();\n\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @class\n */\n\nvar FieldOrder = /*#__PURE__*/function () {\n  /**\n   * @param field The name of a document field (member) on which to order query\n   * results.\n   * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n   * set the ordering direction to ascending or descending, respectively.\n   */\n  function FieldOrder(field) {\n    var direction = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'ASCENDING';\n\n    _classCallCheck(this, FieldOrder);\n\n    this.field = field;\n    this.direction = direction;\n  }\n  /**\n   * Generates the proto representation for this field order.\n   * @private\n   */\n\n\n  _createClass(FieldOrder, [{\n    key: \"toProto\",\n    value: function toProto() {\n      return {\n        field: {\n          fieldPath: this.field.formattedName\n        },\n        direction: this.direction\n      };\n    }\n  }]);\n\n  return FieldOrder;\n}();\n\nexports.FieldOrder = FieldOrder;\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @class\n */\n\nvar FieldFilter = /*#__PURE__*/function () {\n  /**\n   * @param serializer The Firestore serializer\n   * @param field The path of the property value to compare.\n   * @param op A comparison operation.\n   * @param value The value to which to compare the field for inclusion in a\n   * query.\n   */\n  function FieldFilter(serializer, field, op, value) {\n    _classCallCheck(this, FieldFilter);\n\n    this.serializer = serializer;\n    this.field = field;\n    this.op = op;\n    this.value = value;\n  }\n  /**\n   * Returns whether this FieldFilter uses an equals comparison.\n   *\n   * @private\n   */\n\n\n  _createClass(FieldFilter, [{\n    key: \"isInequalityFilter\",\n    value: function isInequalityFilter() {\n      switch (this.op) {\n        case 'GREATER_THAN':\n        case 'GREATER_THAN_OR_EQUAL':\n        case 'LESS_THAN':\n        case 'LESS_THAN_OR_EQUAL':\n          return true;\n\n        default:\n          return false;\n      }\n    }\n    /**\n     * Generates the proto representation for this field filter.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto() {\n      if (typeof this.value === 'number' && isNaN(this.value)) {\n        return {\n          unaryFilter: {\n            field: {\n              fieldPath: this.field.formattedName\n            },\n            op: this.op === 'EQUAL' ? 'IS_NAN' : 'IS_NOT_NAN'\n          }\n        };\n      }\n\n      if (this.value === null) {\n        return {\n          unaryFilter: {\n            field: {\n              fieldPath: this.field.formattedName\n            },\n            op: this.op === 'EQUAL' ? 'IS_NULL' : 'IS_NOT_NULL'\n          }\n        };\n      }\n\n      return {\n        fieldFilter: {\n          field: {\n            fieldPath: this.field.formattedName\n          },\n          op: this.op,\n          value: this.serializer.encodeValue(this.value)\n        }\n      };\n    }\n  }]);\n\n  return FieldFilter;\n}();\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\n\n\nvar QuerySnapshot = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param _query The originating query.\n   * @param _readTime The time when this query snapshot was obtained.\n   * @param _size The number of documents in the result set.\n   * @param docs A callback returning a sorted array of documents matching\n   * this query\n   * @param changes A callback returning a sorted array of document change\n   * events for this snapshot.\n   */\n  function QuerySnapshot(_query, _readTime, _size, docs, changes) {\n    _classCallCheck(this, QuerySnapshot);\n\n    this._query = _query;\n    this._readTime = _readTime;\n    this._size = _size;\n    this._materializedDocs = null;\n    this._materializedChanges = null;\n    this._docs = null;\n    this._changes = null;\n    this._docs = docs;\n    this._changes = changes;\n  }\n  /**\n   * The query on which you called get() or onSnapshot() in order to get this\n   * QuerySnapshot.\n   *\n   * @type {Query}\n   * @name QuerySnapshot#query\n   * @readonly\n   *\n   * @example\n   * let query = firestore.collection('col').where('foo', '==', 'bar');\n   *\n   * query.limit(10).get().then(querySnapshot => {\n   *   console.log(`Returned first batch of results`);\n   *   let query = querySnapshot.query;\n   *   return query.offset(10).get();\n   * }).then(() => {\n   *   console.log(`Returned second batch of results`);\n   * });\n   */\n\n\n  _createClass(QuerySnapshot, [{\n    key: \"query\",\n    get: function get() {\n      return this._query;\n    }\n    /**\n     * An array of all the documents in this QuerySnapshot.\n     *\n     * @type {Array.<QueryDocumentSnapshot>}\n     * @name QuerySnapshot#docs\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   let docs = querySnapshot.docs;\n     *   for (let doc of docs) {\n     *     console.log(`Document found at path: ${doc.ref.path}`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"docs\",\n    get: function get() {\n      if (this._materializedDocs) {\n        return this._materializedDocs;\n      }\n\n      this._materializedDocs = this._docs();\n      this._docs = null;\n      return this._materializedDocs;\n    }\n    /**\n     * True if there are no documents in the QuerySnapshot.\n     *\n     * @type {boolean}\n     * @name QuerySnapshot#empty\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   if (querySnapshot.empty) {\n     *     console.log('No documents found.');\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"empty\",\n    get: function get() {\n      return this._size === 0;\n    }\n    /**\n     * The number of documents in the QuerySnapshot.\n     *\n     * @type {number}\n     * @name QuerySnapshot#size\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   console.log(`Found ${querySnapshot.size} documents.`);\n     * });\n     */\n\n  }, {\n    key: \"size\",\n    get: function get() {\n      return this._size;\n    }\n    /**\n     * The time this query snapshot was obtained.\n     *\n     * @type {Timestamp}\n     * @name QuerySnapshot#readTime\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then((querySnapshot) => {\n     *   let readTime = querySnapshot.readTime;\n     *   console.log(`Query results returned at '${readTime.toDate()}'`);\n     * });\n     */\n\n  }, {\n    key: \"readTime\",\n    get: function get() {\n      return this._readTime;\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If\n     * this is the first snapshot, all documents will be in the list as added\n     * changes.\n     *\n     * @return {Array.<DocumentChange>}\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.onSnapshot(querySnapshot => {\n     *   let changes = querySnapshot.docChanges();\n     *   for (let change of changes) {\n     *     console.log(`A document was ${change.type}.`);\n     *   }\n     * });\n     */\n\n  }, {\n    key: \"docChanges\",\n    value: function docChanges() {\n      if (this._materializedChanges) {\n        return this._materializedChanges;\n      }\n\n      this._materializedChanges = this._changes();\n      this._changes = null;\n      return this._materializedChanges;\n    }\n    /**\n     * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n     * method for running the same callback on each {@link QueryDocumentSnapshot}\n     * that is returned.\n     *\n     * @param {function} callback A callback to be called with a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n     * the snapshot.\n     * @param {*=} thisArg The `this` binding for the callback..\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback, thisArg) {\n      validate_1.validateFunction('callback', callback);\n\n      var _iterator3 = _createForOfIteratorHelper(this.docs),\n          _step3;\n\n      try {\n        for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n          var doc = _step3.value;\n          callback.call(thisArg, doc);\n        }\n      } catch (err) {\n        _iterator3.e(err);\n      } finally {\n        _iterator3.f();\n      }\n    }\n    /**\n     * Returns true if the document data in this `QuerySnapshot` is equal to the\n     * provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n     * value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      // Since the read time is different on every query read, we explicitly\n      // ignore all metadata in this comparison.\n      if (this === other) {\n        return true;\n      }\n\n      if (!(other instanceof QuerySnapshot)) {\n        return false;\n      }\n\n      if (this._size !== other._size) {\n        return false;\n      }\n\n      if (!this._query.isEqual(other._query)) {\n        return false;\n      }\n\n      if (this._materializedDocs && !this._materializedChanges) {\n        // If we have only materialized the documents, we compare them first.\n        return isArrayEqual(this.docs, other.docs) && isArrayEqual(this.docChanges(), other.docChanges());\n      } // Otherwise, we compare the changes first as we expect there to be fewer.\n\n\n      return isArrayEqual(this.docChanges(), other.docChanges()) && isArrayEqual(this.docs, other.docs);\n    }\n  }]);\n\n  return QuerySnapshot;\n}();\n\nexports.QuerySnapshot = QuerySnapshot;\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\n\nvar LimitType;\n\n(function (LimitType) {\n  LimitType[LimitType[\"First\"] = 0] = \"First\";\n  LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n */\n\n\nvar QueryOptions = /*#__PURE__*/function () {\n  function QueryOptions(parentPath, collectionId, converter, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, limitType, offset, projection) {\n    var kindless = arguments.length > 12 && arguments[12] !== undefined ? arguments[12] : false;\n\n    _classCallCheck(this, QueryOptions);\n\n    this.parentPath = parentPath;\n    this.collectionId = collectionId;\n    this.converter = converter;\n    this.allDescendants = allDescendants;\n    this.fieldFilters = fieldFilters;\n    this.fieldOrders = fieldOrders;\n    this.startAt = startAt;\n    this.endAt = endAt;\n    this.limit = limit;\n    this.limitType = limitType;\n    this.offset = offset;\n    this.projection = projection;\n    this.kindless = kindless;\n  }\n  /**\n   * Returns query options for a collection group query.\n   * @private\n   */\n\n\n  _createClass(QueryOptions, [{\n    key: \"with\",\n    value:\n    /**\n     * Returns the union of the current and the provided options.\n     * @private\n     */\n    function _with(settings) {\n      return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection), coalesce(settings.kindless, this.kindless));\n    }\n  }, {\n    key: \"withConverter\",\n    value: function withConverter(converter) {\n      return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.fieldFilters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n    }\n  }, {\n    key: \"hasFieldOrders\",\n    value: function hasFieldOrders() {\n      return this.fieldOrders.length > 0;\n    }\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      if (this === other) {\n        return true;\n      }\n\n      return other instanceof QueryOptions && this.parentPath.isEqual(other.parentPath) && this.collectionId === other.collectionId && this.converter === other.converter && this.allDescendants === other.allDescendants && this.limit === other.limit && this.offset === other.offset && deepEqual(this.fieldFilters, other.fieldFilters) && deepEqual(this.fieldOrders, other.fieldOrders) && deepEqual(this.startAt, other.startAt) && deepEqual(this.endAt, other.endAt) && deepEqual(this.projection, other.projection) && this.kindless === other.kindless;\n    }\n  }], [{\n    key: \"forCollectionGroupQuery\",\n    value: function forCollectionGroupQuery(collectionId) {\n      var converter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types_1.defaultConverter();\n      return new QueryOptions(\n      /*parentPath=*/\n      path_1.ResourcePath.EMPTY, collectionId, converter,\n      /*allDescendants=*/\n      true,\n      /*fieldFilters=*/\n      [],\n      /*fieldOrders=*/\n      []);\n    }\n    /**\n     * Returns query options for a single-collection query.\n     * @private\n     */\n\n  }, {\n    key: \"forCollectionQuery\",\n    value: function forCollectionQuery(collectionRef) {\n      var converter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types_1.defaultConverter();\n      return new QueryOptions(collectionRef.parent(), collectionRef.id, converter,\n      /*allDescendants=*/\n      false,\n      /*fieldFilters=*/\n      [],\n      /*fieldOrders=*/\n      []);\n    }\n    /**\n     * Returns query options for a query that fetches all descendants under the\n     * specified reference.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"forKindlessAllDescendants\",\n    value: function forKindlessAllDescendants(parent, id) {\n      var options = new QueryOptions(parent, id, types_1.defaultConverter(),\n      /*allDescendants=*/\n      true,\n      /*fieldFilters=*/\n      [],\n      /*fieldOrders=*/\n      []);\n      options = options.with({\n        kindless: true\n      });\n      return options;\n    }\n  }]);\n\n  return QueryOptions;\n}();\n\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\n\nvar Query = /*#__PURE__*/function () {\n  /**\n   * @hideconstructor\n   *\n   * @param _firestore The Firestore Database client.\n   * @param _queryOptions Options that define the query.\n   */\n  function Query(_firestore, _queryOptions) {\n    _classCallCheck(this, Query);\n\n    this._firestore = _firestore;\n    this._queryOptions = _queryOptions;\n    this._serializer = new serializer_1.Serializer(_firestore);\n    this._allowUndefined = !!this._firestore._settings.ignoreUndefinedProperties;\n  }\n  /**\n   * Extracts field values from the DocumentSnapshot based on the provided\n   * field order.\n   *\n   * @private\n   * @param documentSnapshot The document to extract the fields from.\n   * @param fieldOrders The field order that defines what fields we should\n   * extract.\n   * @return {Array.<*>} The field values to use.\n   * @private\n   */\n\n\n  _createClass(Query, [{\n    key: \"firestore\",\n    get:\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name Query#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    function get() {\n      return this._firestore;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} with the additional filter\n     * that documents must contain the specified field and that its value should\n     * satisfy the relation constraint provided.\n     *\n     * Returns a new Query that constrains the value of a Document property.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the filter.\n     *\n     * @param {string|FieldPath} fieldPath The name of a property value to compare.\n     * @param {string} opStr A comparison operation in the form of a string\n     * (e.g., \"<\").\n     * @param {*} value The value to which to compare the field for inclusion in\n     * a query.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"where\",\n    value: function where(fieldPath, opStr, value) {\n      var _this3 = this;\n\n      path_1.validateFieldPath('fieldPath', fieldPath);\n      opStr = validateQueryOperator('opStr', opStr, value);\n      validateQueryValue('value', value, this._allowUndefined);\n\n      if (this._queryOptions.startAt || this._queryOptions.endAt) {\n        throw new Error('Cannot specify a where() filter after calling startAt(), ' + 'startAfter(), endBefore() or endAt().');\n      }\n\n      var path = path_1.FieldPath.fromArgument(fieldPath);\n\n      if (path_1.FieldPath.documentId().isEqual(path)) {\n        if (opStr === 'array-contains' || opStr === 'array-contains-any') {\n          throw new Error(\"Invalid Query. You can't perform '\".concat(opStr, \"' \") + 'queries on FieldPath.documentId().');\n        }\n\n        if (opStr === 'in' || opStr === 'not-in') {\n          if (!Array.isArray(value) || value.length === 0) {\n            throw new Error(\"Invalid Query. A non-empty array is required for '\".concat(opStr, \"' filters.\"));\n          }\n\n          value = value.map(function (el) {\n            return _this3.validateReference(el);\n          });\n        } else {\n          value = this.validateReference(value);\n        }\n      }\n\n      var fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);\n\n      var options = this._queryOptions.with({\n        fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter)\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} instance that applies a\n     * field mask to the result and returns only the specified subset of fields.\n     * You can specify a list of field paths to return, or use an empty list to\n     * only return the references of matching documents.\n     *\n     * Queries that contain field masks cannot be listened to via `onSnapshot()`\n     * listeners.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRef = collectionRef.doc('doc');\n     *\n     * return documentRef.set({x:10, y:5}).then(() => {\n     *   return collectionRef.where('x', '>', 5).select('y').get();\n     * }).then((res) => {\n     *   console.log(`y is ${res.docs[0].get('y')}.`);\n     * });\n     */\n\n  }, {\n    key: \"select\",\n    value: function select() {\n      var fields = [];\n\n      if (arguments.length === 0) {\n        fields.push({\n          fieldPath: path_1.FieldPath.documentId().formattedName\n        });\n      } else {\n        for (var i = 0; i < arguments.length; ++i) {\n          path_1.validateFieldPath(i, i < 0 || arguments.length <= i ? undefined : arguments[i]);\n          fields.push({\n            fieldPath: path_1.FieldPath.fromArgument(i < 0 || arguments.length <= i ? undefined : arguments[i]).formattedName\n          });\n        }\n      } // By specifying a field mask, the query result no longer conforms to type\n      // `T`. We there return `Query<DocumentData>`;\n\n\n      var options = this._queryOptions.with({\n        projection: {\n          fields: fields\n        }\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that's additionally sorted\n     * by the specified field, optionally in descending order instead of\n     * ascending.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {string|FieldPath} fieldPath The field to sort by.\n     * @param {string=} directionStr Optional direction to sort by ('asc' or\n     * 'desc'). If not specified, order will be ascending.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"orderBy\",\n    value: function orderBy(fieldPath, directionStr) {\n      path_1.validateFieldPath('fieldPath', fieldPath);\n      directionStr = validateQueryOrder('directionStr', directionStr);\n\n      if (this._queryOptions.startAt || this._queryOptions.endAt) {\n        throw new Error('Cannot specify an orderBy() constraint after calling ' + 'startAt(), startAfter(), endBefore() or endAt().');\n      }\n\n      var newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n\n      var options = this._queryOptions.with({\n        fieldOrders: this._queryOptions.fieldOrders.concat(newOrder)\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * first matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the limit.\n     *\n     * @param {number} limit The maximum number of items to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"limit\",\n    value: function limit(_limit) {\n      validate_1.validateInteger('limit', _limit);\n\n      var options = this._queryOptions.with({\n        limit: _limit,\n        limitType: LimitType.First\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * last matching documents.\n     *\n     * You must specify at least one orderBy clause for limitToLast queries,\n     * otherwise an exception will be thrown during execution.\n     *\n     * Results for limitToLast queries cannot be streamed via the `stream()` API.\n     *\n     * @param limit The maximum number of items to return.\n     * @return The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limitToLast(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"limitToLast\",\n    value: function limitToLast(limit) {\n      validate_1.validateInteger('limitToLast', limit);\n\n      var options = this._queryOptions.with({\n        limit: limit,\n        limitType: LimitType.Last\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Specifies the offset of the returned results.\n     *\n     * This function returns a new (immutable) instance of the\n     * [Query]{@link Query} (rather than modify the existing instance)\n     * to impose the offset.\n     *\n     * @param {number} offset The offset to apply to the Query results\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(10).offset(20).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"offset\",\n    value: function offset(_offset) {\n      validate_1.validateInteger('offset', _offset);\n\n      var options = this._queryOptions.with({\n        offset: _offset\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Returns true if this `Query` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `Query` is equal to the provided value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      if (this === other) {\n        return true;\n      }\n\n      return other instanceof Query && this._queryOptions.isEqual(other._queryOptions);\n    }\n    /**\n     * Computes the backend ordering semantics for DocumentSnapshot cursors.\n     *\n     * @private\n     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n     * set of field values to use as the boundary.\n     * @returns The implicit ordering semantics.\n     */\n\n  }, {\n    key: \"createImplicitOrderBy\",\n    value: function createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n      // Add an implicit orderBy if the only cursor value is a DocumentSnapshot\n      // or a DocumentReference.\n      if (cursorValuesOrDocumentSnapshot.length !== 1 || !(cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot || cursorValuesOrDocumentSnapshot[0] instanceof DocumentReference)) {\n        return this._queryOptions.fieldOrders;\n      }\n\n      var fieldOrders = this._queryOptions.fieldOrders.slice();\n\n      var hasDocumentId = false;\n\n      if (fieldOrders.length === 0) {\n        // If no explicit ordering is specified, use the first inequality to\n        // define an implicit order.\n        var _iterator4 = _createForOfIteratorHelper(this._queryOptions.fieldFilters),\n            _step4;\n\n        try {\n          for (_iterator4.s(); !(_step4 = _iterator4.n()).done;) {\n            var fieldFilter = _step4.value;\n\n            if (fieldFilter.isInequalityFilter()) {\n              fieldOrders.push(new FieldOrder(fieldFilter.field));\n              break;\n            }\n          }\n        } catch (err) {\n          _iterator4.e(err);\n        } finally {\n          _iterator4.f();\n        }\n      } else {\n        var _iterator5 = _createForOfIteratorHelper(fieldOrders),\n            _step5;\n\n        try {\n          for (_iterator5.s(); !(_step5 = _iterator5.n()).done;) {\n            var fieldOrder = _step5.value;\n\n            if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n              hasDocumentId = true;\n            }\n          }\n        } catch (err) {\n          _iterator5.e(err);\n        } finally {\n          _iterator5.f();\n        }\n      }\n\n      if (!hasDocumentId) {\n        // Add implicit sorting by name, using the last specified direction.\n        var lastDirection = fieldOrders.length === 0 ? directionOperators.ASC : fieldOrders[fieldOrders.length - 1].direction;\n        fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n      }\n\n      return fieldOrders;\n    }\n    /**\n     * Builds a Firestore 'Position' proto message.\n     *\n     * @private\n     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n     * cursor.\n     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n     * snapshot of the document or the set of field values to use as the boundary.\n     * @param before Whether the query boundary lies just before or after the\n     * provided data.\n     * @returns {Object} The proto message.\n     */\n\n  }, {\n    key: \"createCursor\",\n    value: function createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n      var fieldValues;\n\n      if (cursorValuesOrDocumentSnapshot.length === 1 && cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot) {\n        fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n      } else {\n        fieldValues = cursorValuesOrDocumentSnapshot;\n      }\n\n      if (fieldValues.length > fieldOrders.length) {\n        throw new Error('Too many cursor values specified. The specified ' + 'values must match the orderBy() constraints of the query.');\n      }\n\n      var options = {\n        values: [],\n        before: before\n      };\n\n      for (var i = 0; i < fieldValues.length; ++i) {\n        var fieldValue = fieldValues[i];\n\n        if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n          fieldValue = this.validateReference(fieldValue);\n        }\n\n        validateQueryValue(i, fieldValue, this._allowUndefined);\n        options.values.push(this._serializer.encodeValue(fieldValue));\n      }\n\n      return options;\n    }\n    /**\n     * Validates that a value used with FieldValue.documentId() is either a\n     * string or a DocumentReference that is part of the query`s result set.\n     * Throws a validation error or returns a DocumentReference that can\n     * directly be used in the Query.\n     *\n     * @param val The value to validate.\n     * @throws If the value cannot be used for this query.\n     * @return If valid, returns a DocumentReference that can be used with the\n     * query.\n     * @private\n     */\n\n  }, {\n    key: \"validateReference\",\n    value: function validateReference(val) {\n      var basePath = this._queryOptions.allDescendants ? this._queryOptions.parentPath : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n      var reference;\n\n      if (typeof val === 'string') {\n        var path = basePath.append(val);\n\n        if (this._queryOptions.allDescendants) {\n          if (!path.isDocument) {\n            throw new Error('When querying a collection group and ordering by ' + 'FieldPath.documentId(), the corresponding value must result in ' + \"a valid document path, but '\".concat(val, \"' is not because it \") + 'contains an odd number of segments.');\n          }\n        } else if (val.indexOf('/') !== -1) {\n          throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' + \"the corresponding value must be a plain document ID, but '\".concat(val, \"' \") + 'contains a slash.');\n        }\n\n        reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n      } else if (val instanceof DocumentReference) {\n        reference = val;\n\n        if (!basePath.isPrefixOf(reference._path)) {\n          throw new Error(\"\\\"\".concat(reference.path, \"\\\" is not part of the query result set and \") + 'cannot be used as a query boundary.');\n        }\n      } else {\n        throw new Error('The corresponding value for FieldPath.documentId() must be a ' + \"string or a DocumentReference, but was \\\"\".concat(val, \"\\\".\"));\n      }\n\n      if (!this._queryOptions.allDescendants && reference._path.parent().compareTo(basePath) !== 0) {\n        throw new Error('Only a direct child can be used as a query boundary. ' + \"Found: \\\"\".concat(reference.path, \"\\\".\"));\n      }\n\n      return reference;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start at or the field values to\n     * start this query at, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"startAt\",\n    value: function startAt() {\n      for (var _len2 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        fieldValuesOrDocumentSnapshot[_key2] = arguments[_key2];\n      }\n\n      validate_1.validateMinNumberOfArguments('Query.startAt', fieldValuesOrDocumentSnapshot, 1);\n      var fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n      var startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n\n      var options = this._queryOptions.with({\n        fieldOrders: fieldOrders,\n        startAt: startAt\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts after the\n     * provided set of field values relative to the order of the query. The order\n     * of the provided values must match the order of the order by clauses of the\n     * query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start after or the field values to\n     * start this query after, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"startAfter\",\n    value: function startAfter() {\n      for (var _len3 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        fieldValuesOrDocumentSnapshot[_key3] = arguments[_key3];\n      }\n\n      validate_1.validateMinNumberOfArguments('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);\n      var fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n      var startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n\n      var options = this._queryOptions.with({\n        fieldOrders: fieldOrders,\n        startAt: startAt\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends before the set of\n     * field values relative to the order of the query. The order of the provided\n     * values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end before or the field values to\n     * end this query before, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"endBefore\",\n    value: function endBefore() {\n      for (var _len4 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++) {\n        fieldValuesOrDocumentSnapshot[_key4] = arguments[_key4];\n      }\n\n      validate_1.validateMinNumberOfArguments('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);\n      var fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n      var endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n\n      var options = this._queryOptions.with({\n        fieldOrders: fieldOrders,\n        endAt: endAt\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end at or the field values to end\n     * this query at, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"endAt\",\n    value: function endAt() {\n      for (var _len5 = arguments.length, fieldValuesOrDocumentSnapshot = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {\n        fieldValuesOrDocumentSnapshot[_key5] = arguments[_key5];\n      }\n\n      validate_1.validateMinNumberOfArguments('Query.endAt', fieldValuesOrDocumentSnapshot, 1);\n      var fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n      var endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n\n      var options = this._queryOptions.with({\n        fieldOrders: fieldOrders,\n        endAt: endAt\n      });\n\n      return new Query(this._firestore, options);\n    }\n    /**\n     * Executes the query and returns the results as a\n     * [QuerySnapshot]{@link QuerySnapshot}.\n     *\n     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n     * of the Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._get();\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id.\n     *\n     * @private\n     * @param {bytes=} transactionId A transaction ID.\n     */\n\n  }, {\n    key: \"_get\",\n    value: function _get(transactionId) {\n      var _this4 = this;\n\n      var docs = []; // Capture the error stack to preserve stack tracing across async calls.\n\n      var stack = Error().stack;\n      return new Promise(function (resolve, reject) {\n        var readTime;\n\n        _this4._stream(transactionId).on('error', function (err) {\n          reject(util_1.wrapError(err, stack));\n        }).on('data', function (result) {\n          readTime = result.readTime;\n\n          if (result.document) {\n            docs.push(result.document);\n          }\n        }).on('end', function () {\n          if (_this4._queryOptions.limitType === LimitType.Last) {\n            // The results for limitToLast queries need to be flipped since\n            // we reversed the ordering constraints before sending the query\n            // to the backend.\n            docs.reverse();\n          }\n\n          resolve(new QuerySnapshot(_this4, readTime, docs.length, function () {\n            return docs;\n          }, function () {\n            var changes = [];\n\n            for (var i = 0; i < docs.length; ++i) {\n              changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n            }\n\n            return changes;\n          }));\n        });\n      });\n    }\n    /**\n     * Executes the query and streams the results as\n     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n     *\n     * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n     * QueryDocumentSnapshots.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.stream().on('data', (documentSnapshot) => {\n     *   console.log(`Found document with name '${documentSnapshot.id}'`);\n     *   ++count;\n     * }).on('end', () => {\n     *   console.log(`Total count is ${count}`);\n     * });\n     */\n\n  }, {\n    key: \"stream\",\n    value: function stream() {\n      if (this._queryOptions.limitType === LimitType.Last) {\n        throw new Error('Query results for queries that include limitToLast() ' + 'constraints cannot be streamed. Use Query.get() instead.');\n      }\n\n      var responseStream = this._stream();\n\n      var transform = new stream_1.Transform({\n        objectMode: true,\n        transform: function transform(chunk, encoding, callback) {\n          callback(undefined, chunk.document);\n        }\n      });\n      responseStream.pipe(transform);\n      responseStream.on('error', function (e) {\n        return transform.destroy(e);\n      });\n      return transform;\n    }\n    /**\n     * Converts a QueryCursor to its proto representation.\n     *\n     * @param cursor The original cursor value\n     * @private\n     */\n\n  }, {\n    key: \"toCursor\",\n    value: function toCursor(cursor) {\n      if (cursor) {\n        return cursor.before ? {\n          before: true,\n          values: cursor.values\n        } : {\n          values: cursor.values\n        };\n      }\n\n      return undefined;\n    }\n    /**\n     * Internal method for serializing a query to its RunQuery proto\n     * representation with an optional transaction id or read time.\n     *\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     * @private\n     * @returns Serialized JSON for the query.\n     */\n\n  }, {\n    key: \"toProto\",\n    value: function toProto(transactionIdOrReadTime) {\n      var projectId = this.firestore.projectId;\n\n      var parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n\n      var structuredQuery = this.toStructuredQuery(); // For limitToLast queries, the structured query has to be translated to a version with\n      // reversed ordered, and flipped startAt/endAt to work properly.\n\n      if (this._queryOptions.limitType === LimitType.Last) {\n        if (!this._queryOptions.hasFieldOrders()) {\n          throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n        }\n\n        structuredQuery.orderBy = this._queryOptions.fieldOrders.map(function (order) {\n          // Flip the orderBy directions since we want the last results\n          var dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n          return new FieldOrder(order.field, dir).toProto();\n        }); // Swap the cursors to match the now-flipped query ordering.\n\n        structuredQuery.startAt = this._queryOptions.endAt ? this.toCursor({\n          values: this._queryOptions.endAt.values,\n          before: !this._queryOptions.endAt.before\n        }) : undefined;\n        structuredQuery.endAt = this._queryOptions.startAt ? this.toCursor({\n          values: this._queryOptions.startAt.values,\n          before: !this._queryOptions.startAt.before\n        }) : undefined;\n      }\n\n      var runQueryRequest = {\n        parent: parentPath.formattedName,\n        structuredQuery: structuredQuery\n      };\n\n      if (transactionIdOrReadTime instanceof Uint8Array) {\n        runQueryRequest.transaction = transactionIdOrReadTime;\n      } else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n        runQueryRequest.readTime = transactionIdOrReadTime.toProto().timestampValue;\n      }\n\n      return runQueryRequest;\n    }\n    /**\n     * Converts current Query to an IBundledQuery.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"_toBundledQuery\",\n    value: function _toBundledQuery() {\n      var projectId = this.firestore.projectId;\n\n      var parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n\n      var structuredQuery = this.toStructuredQuery();\n      var bundledQuery = {\n        parent: parentPath.formattedName,\n        structuredQuery: structuredQuery\n      };\n\n      if (this._queryOptions.limitType === LimitType.First) {\n        bundledQuery.limitType = 'FIRST';\n      } else if (this._queryOptions.limitType === LimitType.Last) {\n        bundledQuery.limitType = 'LAST';\n      }\n\n      return bundledQuery;\n    }\n  }, {\n    key: \"toStructuredQuery\",\n    value: function toStructuredQuery() {\n      var structuredQuery = {\n        from: [{}]\n      };\n\n      if (this._queryOptions.allDescendants) {\n        structuredQuery.from[0].allDescendants = true;\n      } // Kindless queries select all descendant documents, so we remove the\n      // collectionId field.\n\n\n      if (!this._queryOptions.kindless) {\n        structuredQuery.from[0].collectionId = this._queryOptions.collectionId;\n      }\n\n      if (this._queryOptions.fieldFilters.length === 1) {\n        structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();\n      } else if (this._queryOptions.fieldFilters.length > 1) {\n        var filters = [];\n\n        var _iterator6 = _createForOfIteratorHelper(this._queryOptions.fieldFilters),\n            _step6;\n\n        try {\n          for (_iterator6.s(); !(_step6 = _iterator6.n()).done;) {\n            var fieldFilter = _step6.value;\n            filters.push(fieldFilter.toProto());\n          }\n        } catch (err) {\n          _iterator6.e(err);\n        } finally {\n          _iterator6.f();\n        }\n\n        structuredQuery.where = {\n          compositeFilter: {\n            op: 'AND',\n            filters: filters\n          }\n        };\n      }\n\n      if (this._queryOptions.hasFieldOrders()) {\n        structuredQuery.orderBy = this._queryOptions.fieldOrders.map(function (o) {\n          return o.toProto();\n        });\n      }\n\n      structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n      structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n\n      if (this._queryOptions.limit) {\n        structuredQuery.limit = {\n          value: this._queryOptions.limit\n        };\n      }\n\n      structuredQuery.offset = this._queryOptions.offset;\n      structuredQuery.select = this._queryOptions.projection;\n      return structuredQuery;\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * @param transactionId A transaction ID.\n     * @private\n     * @returns A stream of document results.\n     */\n\n  }, {\n    key: \"_stream\",\n    value: function _stream(transactionId) {\n      var _this5 = this;\n\n      var tag = util_1.requestTag();\n      var lastReceivedDocument = null;\n      var stream = new stream_1.Transform({\n        objectMode: true,\n        transform: function transform(proto, enc, callback) {\n          var readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n\n          if (proto.document) {\n            var document = _this5.firestore.snapshot_(proto.document, proto.readTime);\n\n            var finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(_this5._queryOptions.converter)); // Recreate the QueryDocumentSnapshot with the DocumentReference\n            // containing the original converter.\n\n            finalDoc.fieldsProto = document._fieldsProto;\n            finalDoc.readTime = document.readTime;\n            finalDoc.createTime = document.createTime;\n            finalDoc.updateTime = document.updateTime;\n            lastReceivedDocument = finalDoc.build();\n            callback(undefined, {\n              document: lastReceivedDocument,\n              readTime: readTime\n            });\n          } else {\n            callback(undefined, {\n              readTime: readTime\n            });\n          }\n        }\n      });\n      this.firestore.initializeIfNeeded(tag).then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var request, streamActive, _loop;\n\n        return _regeneratorRuntime.wrap(function _callee$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // `toProto()` might throw an exception. We rely on the behavior of an\n                // async function to convert this exception into the rejected Promise we\n                // catch below.\n                request = _this5.toProto(transactionId);\n                _loop = /*#__PURE__*/_regeneratorRuntime.mark(function _loop() {\n                  var backendStream;\n                  return _regeneratorRuntime.wrap(function _loop$(_context) {\n                    while (1) {\n                      switch (_context.prev = _context.next) {\n                        case 0:\n                          streamActive = new util_1.Deferred();\n                          _context.next = 3;\n                          return _this5._firestore.requestStream('runQuery', request, tag);\n\n                        case 3:\n                          backendStream = _context.sent;\n                          backendStream.on('error', function (err) {\n                            backendStream.unpipe(stream); // If a non-transactional query failed, attempt to restart.\n                            // Transactional queries are retried via the transaction runner.\n\n                            if (!transactionId && !util_1.isPermanentRpcError(err, 'runQuery')) {\n                              logger_1.logger('Query._stream', tag, 'Query failed with retryable stream error:', err);\n\n                              if (lastReceivedDocument) {\n                                // Restart the query but use the last document we received as the\n                                // query cursor. Note that we do not use backoff here. The call to\n                                // `requestStream()` will backoff should the restart fail before\n                                // delivering any results.\n                                request = _this5.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                              }\n\n                              streamActive.resolve(\n                              /* active= */\n                              true);\n                            } else {\n                              logger_1.logger('Query._stream', tag, 'Query failed with stream error:', err);\n                              stream.destroy(err);\n                              streamActive.resolve(\n                              /* active= */\n                              false);\n                            }\n                          });\n                          backendStream.on('end', function () {\n                            streamActive.resolve(\n                            /* active= */\n                            false);\n                          });\n                          backendStream.resume();\n                          backendStream.pipe(stream);\n\n                        case 8:\n                        case \"end\":\n                          return _context.stop();\n                      }\n                    }\n                  }, _loop);\n                });\n\n              case 2:\n                return _context2.delegateYield(_loop(), \"t0\", 3);\n\n              case 3:\n                _context2.next = 5;\n                return streamActive.promise;\n\n              case 5:\n                if (_context2.sent) {\n                  _context2.next = 2;\n                  break;\n                }\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (e) {\n        return stream.destroy(e);\n      });\n      return stream;\n    }\n    /**\n     * Attaches a listener for QuerySnapshot events.\n     *\n     * @param {querySnapshotCallback} onNext A callback to be called every time\n     * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n     * @param {errorCallback=} onError A callback to be called if the listen\n     * fails or is cancelled. No further callbacks will occur.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n\n  }, {\n    key: \"onSnapshot\",\n    value: function onSnapshot(onNext, onError) {\n      var _this6 = this;\n\n      validate_1.validateFunction('onNext', onNext);\n      validate_1.validateFunction('onError', onError, {\n        optional: true\n      });\n      var watch = new watch_1.QueryWatch(this.firestore, this, this._queryOptions.converter);\n      return watch.onSnapshot(function (readTime, size, docs, changes) {\n        onNext(new QuerySnapshot(_this6, readTime, size, docs, changes));\n      }, onError || console.error);\n    }\n    /**\n     * Returns a function that can be used to sort QueryDocumentSnapshots\n     * according to the sort criteria of this query.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"comparator\",\n    value: function comparator() {\n      var _this7 = this;\n\n      return function (doc1, doc2) {\n        // Add implicit sorting by name, using the last specified direction.\n        var lastDirection = _this7._queryOptions.hasFieldOrders() ? _this7._queryOptions.fieldOrders[_this7._queryOptions.fieldOrders.length - 1].direction : 'ASCENDING';\n\n        var orderBys = _this7._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n\n        var _iterator7 = _createForOfIteratorHelper(orderBys),\n            _step7;\n\n        try {\n          for (_iterator7.s(); !(_step7 = _iterator7.n()).done;) {\n            var orderBy = _step7.value;\n            var comp = void 0;\n\n            if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n              comp = doc1.ref._path.compareTo(doc2.ref._path);\n            } else {\n              var v1 = doc1.protoField(orderBy.field);\n              var v2 = doc2.protoField(orderBy.field);\n\n              if (v1 === undefined || v2 === undefined) {\n                throw new Error('Trying to compare documents on fields that ' + \"don't exist. Please include the fields you are ordering on \" + 'in your select() call.');\n              }\n\n              comp = order_1.compare(v1, v2);\n            }\n\n            if (comp !== 0) {\n              var direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n              return direction * comp;\n            }\n          }\n        } catch (err) {\n          _iterator7.e(err);\n        } finally {\n          _iterator7.f();\n        }\n\n        return 0;\n      };\n    }\n  }, {\n    key: \"withConverter\",\n    value: function withConverter(converter) {\n      return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : types_1.defaultConverter()));\n    }\n  }], [{\n    key: \"_extractFieldValues\",\n    value: function _extractFieldValues(documentSnapshot, fieldOrders) {\n      var fieldValues = [];\n\n      var _iterator8 = _createForOfIteratorHelper(fieldOrders),\n          _step8;\n\n      try {\n        for (_iterator8.s(); !(_step8 = _iterator8.n()).done;) {\n          var fieldOrder = _step8.value;\n\n          if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n            fieldValues.push(documentSnapshot.ref);\n          } else {\n            var fieldValue = documentSnapshot.get(fieldOrder.field);\n\n            if (fieldValue === undefined) {\n              throw new Error(\"Field \\\"\".concat(fieldOrder.field, \"\\\" is missing in the provided DocumentSnapshot. \") + 'Please provide a document that contains values for all specified ' + 'orderBy() and where() constraints.');\n            } else {\n              fieldValues.push(fieldValue);\n            }\n          }\n        }\n      } catch (err) {\n        _iterator8.e(err);\n      } finally {\n        _iterator8.f();\n      }\n\n      return fieldValues;\n    }\n  }]);\n\n  return Query;\n}();\n\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class CollectionReference\n * @extends Query\n */\n\nvar CollectionReference = /*#__PURE__*/function (_Query) {\n  _inherits(CollectionReference, _Query);\n\n  var _super = _createSuper(CollectionReference);\n\n  /**\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   * @param path The Path of this collection.\n   */\n  function CollectionReference(firestore, path, converter) {\n    _classCallCheck(this, CollectionReference);\n\n    return _super.call(this, firestore, QueryOptions.forCollectionQuery(path, converter));\n  }\n  /**\n   * Returns a resource path for this collection.\n   * @private\n   */\n\n\n  _createClass(CollectionReference, [{\n    key: \"_resourcePath\",\n    get: function get() {\n      return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    }\n    /**\n     * The last path element of the referenced collection.\n     *\n     * @type {string}\n     * @name CollectionReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`ID of the subcollection: ${collectionRef.id}`);\n     */\n\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this._queryOptions.collectionId;\n    }\n    /**\n     * A reference to the containing Document if this is a subcollection, else\n     * null.\n     *\n     * @type {DocumentReference|null}\n     * @name CollectionReference#parent\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * let documentRef = collectionRef.parent;\n     * console.log(`Parent name: ${documentRef.path}`);\n     */\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      if (this._queryOptions.parentPath.isDocument) {\n        return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n      }\n\n      return null;\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name CollectionReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`Path of the subcollection: ${collectionRef.path}`);\n     */\n\n  }, {\n    key: \"path\",\n    get: function get() {\n      return this._resourcePath.relativeName;\n    }\n    /**\n     * Retrieves the list of documents in this collection.\n     *\n     * The document references returned may include references to \"missing\n     * documents\", i.e. document locations that have no document present but\n     * which contain subcollections with documents. Attempting to read such a\n     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n     * `DocumentSnapshot` whose `.exists` property is false.\n     *\n     * @return {Promise<DocumentReference[]>} The list of documents in this\n     * collection.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * return collectionRef.listDocuments().then(documentRefs => {\n     *    return firestore.getAll(...documentRefs);\n     * }).then(documentSnapshots => {\n     *    for (let documentSnapshot of documentSnapshots) {\n     *       if (documentSnapshot.exists) {\n     *         console.log(`Found document with data: ${documentSnapshot.id}`);\n     *       } else {\n     *         console.log(`Found missing document: ${documentSnapshot.id}`);\n     *       }\n     *    }\n     * });\n     */\n\n  }, {\n    key: \"listDocuments\",\n    value: function listDocuments() {\n      var _this8 = this;\n\n      var tag = util_1.requestTag();\n      return this.firestore.initializeIfNeeded(tag).then(function () {\n        var parentPath = _this8._queryOptions.parentPath.toQualifiedResourcePath(_this8.firestore.projectId);\n\n        var request = {\n          parent: parentPath.formattedName,\n          collectionId: _this8.id,\n          showMissing: true,\n          // Setting `pageSize` to an arbitrarily large value lets the backend cap\n          // the page size (currently to 300). Note that the backend rejects\n          // MAX_INT32 (b/146883794).\n          pageSize: Math.pow(2, 16) - 1,\n          mask: {\n            fieldPaths: []\n          }\n        };\n        return _this8.firestore.request('listDocuments', request, tag).then(function (documents) {\n          // Note that the backend already orders these documents by name,\n          // so we do not need to manually sort them.\n          return documents.map(function (doc) {\n            var path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n            return _this8.doc(path.id);\n          });\n        });\n      });\n    }\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path. If no path is specified, an\n     * automatically-generated unique ID will be used for the returned\n     * DocumentReference.\n     *\n     * @param {string=} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The `DocumentReference`\n     * instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRefWithName = collectionRef.doc('doc');\n     * let documentRefWithAutoId = collectionRef.doc();\n     * console.log(`Reference with name: ${documentRefWithName.path}`);\n     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n     */\n\n  }, {\n    key: \"doc\",\n    value: function doc(documentPath) {\n      if (arguments.length === 0) {\n        documentPath = util_1.autoId();\n      } else {\n        path_1.validateResourcePath('documentPath', documentPath);\n      }\n\n      var path = this._resourcePath.append(documentPath);\n\n      if (!path.isDocument) {\n        throw new Error(\"Value for argument \\\"documentPath\\\" must point to a document, but was \\\"\".concat(documentPath, \"\\\". Your path does not contain an even number of components.\"));\n      }\n\n      return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n    }\n    /**\n     * Add a new document to this collection with the specified data, assigning\n     * it a document ID automatically.\n     *\n     * @param {DocumentData} data An Object containing the data for the new\n     * document.\n     * @returns {Promise.<DocumentReference>} A Promise resolved with a\n     * [DocumentReference]{@link DocumentReference} pointing to the\n     * newly created document.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name: ${documentReference.id}`);\n     * });\n     */\n\n  }, {\n    key: \"add\",\n    value: function add(data) {\n      var firestoreData = this._queryOptions.converter.toFirestore(data);\n\n      write_batch_1.validateDocumentData('data', firestoreData,\n      /*allowDeletes=*/\n      false, this._allowUndefined);\n      var documentRef = this.doc();\n      return documentRef.create(data).then(function () {\n        return documentRef;\n      });\n    }\n    /**\n     * Returns true if this `CollectionReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `CollectionReference` is equal to the\n     * provided value.\n     */\n\n  }, {\n    key: \"isEqual\",\n    value: function isEqual(other) {\n      return this === other || other instanceof CollectionReference && _get2(_getPrototypeOf(CollectionReference.prototype), \"isEqual\", this).call(this, other);\n    }\n  }, {\n    key: \"withConverter\",\n    value: function withConverter(converter) {\n      return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : types_1.defaultConverter());\n    }\n  }]);\n\n  return CollectionReference;\n}(Query);\n\nexports.CollectionReference = CollectionReference;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\n\nfunction validateQueryOrder(arg, op) {\n  // For backwards compatibility, we support both lower and uppercase values.\n  op = typeof op === 'string' ? op.toLowerCase() : op;\n  validate_1.validateEnumValue(arg, op, Object.keys(directionOperators), {\n    optional: true\n  });\n  return op;\n}\n\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\n\nfunction validateQueryOperator(arg, op, fieldValue) {\n  // For backwards compatibility, we support both `=` and `==` for \"equals\".\n  if (op === '=') {\n    op = '==';\n  }\n\n  validate_1.validateEnumValue(arg, op, Object.keys(comparisonOperators));\n\n  if (typeof fieldValue === 'number' && isNaN(fieldValue) && op !== '==' && op !== '!=') {\n    throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on NaN.\");\n  }\n\n  if (fieldValue === null && op !== '==' && op !== '!=') {\n    throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on Null.\");\n  }\n\n  return op;\n}\n\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @return the DocumentReference if valid\n */\n\nfunction validateDocumentReference(arg, value) {\n  if (!(value instanceof DocumentReference)) {\n    throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentReference'));\n  }\n\n  return value;\n}\n\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n */\n\nfunction validateQueryValue(arg, value, allowUndefined) {\n  serializer_1.validateUserInput(arg, value, 'query constraint', {\n    allowDeletes: 'none',\n    allowTransforms: false,\n    allowUndefined: allowUndefined\n  });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\n\n\nfunction isArrayEqual(left, right) {\n  if (left.length !== right.length) {\n    return false;\n  }\n\n  for (var i = 0; i < left.length; ++i) {\n    if (!left[i].isEqual(right[i])) {\n      return false;\n    }\n  }\n\n  return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n */\n\n\nfunction coalesce() {\n  for (var _len6 = arguments.length, values = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {\n    values[_key6] = arguments[_key6];\n  }\n\n  return values.find(function (value) {\n    return value !== undefined;\n  });\n}","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/firestore/build/src/reference.js"],"names":["Object","defineProperty","exports","value","stream_1","require","deepEqual","document_1","document_change_1","logger_1","order_1","path_1","serializer_1","timestamp_1","types_1","util_1","validate_1","watch_1","write_batch_1","directionOperators","asc","desc","comparisonOperators","in","DocumentReference","_firestore","_path","_converter","defaultConverter","projectId","firestore","toQualifiedResourcePath","formattedName","relativeName","id","CollectionReference","parent","getAll","then","result","collectionPath","validateResourcePath","path","append","isCollection","Error","tag","requestTag","initializeIfNeeded","request","pageSize","Math","pow","collectionIds","collections","sort","collectionId","push","collection","data","writeBatch","WriteBatch","create","commit","writeResult","precondition","delete","options","set","dataOrField","preconditionOrValues","validateMinNumberOfArguments","arguments","update","onNext","onError","validateFunction","optional","watch","DocumentWatch","onSnapshot","readTime","size","docs","document","ref","DocumentSnapshotBuilder","build","console","error","other","isEqual","referenceValue","converter","FieldOrder","field","direction","fieldPath","FieldFilter","serializer","op","isNaN","unaryFilter","fieldFilter","encodeValue","QuerySnapshot","_query","_readTime","_size","changes","_materializedDocs","_materializedChanges","_docs","_changes","callback","thisArg","doc","call","isArrayEqual","docChanges","LimitType","QueryOptions","parentPath","allDescendants","fieldFilters","fieldOrders","startAt","endAt","limit","limitType","offset","projection","kindless","settings","coalesce","length","ResourcePath","EMPTY","collectionRef","with","Query","_queryOptions","_serializer","Serializer","_allowUndefined","_settings","ignoreUndefinedProperties","opStr","validateFieldPath","validateQueryOperator","validateQueryValue","FieldPath","fromArgument","documentId","Array","isArray","map","el","validateReference","concat","fields","i","directionStr","validateQueryOrder","newOrder","validateInteger","First","Last","cursorValuesOrDocumentSnapshot","DocumentSnapshot","slice","hasDocumentId","isInequalityFilter","fieldOrder","lastDirection","ASC","before","fieldValues","_extractFieldValues","values","fieldValue","val","basePath","reference","isDocument","indexOf","isPrefixOf","compareTo","fieldValuesOrDocumentSnapshot","createImplicitOrderBy","createCursor","_get","transactionId","stack","Promise","resolve","reject","_stream","on","err","wrapError","reverse","DocumentChange","responseStream","transform","Transform","objectMode","chunk","encoding","undefined","pipe","e","destroy","cursor","transactionIdOrReadTime","structuredQuery","toStructuredQuery","hasFieldOrders","orderBy","order","dir","toProto","toCursor","runQueryRequest","Uint8Array","transaction","Timestamp","timestampValue","bundledQuery","from","where","filters","compositeFilter","o","select","lastReceivedDocument","stream","proto","enc","fromProto","snapshot_","finalDoc","withConverter","fieldsProto","_fieldsProto","createTime","updateTime","streamActive","Deferred","requestStream","backendStream","unpipe","isPermanentRpcError","logger","startAfter","resume","promise","catch","QueryWatch","doc1","doc2","orderBys","comp","v1","protoField","v2","compare","documentSnapshot","get","forCollectionQuery","_resourcePath","showMissing","mask","fieldPaths","documents","QualifiedResourcePath","fromSlashSeparatedString","name","documentPath","autoId","firestoreData","toFirestore","validateDocumentData","documentRef","arg","toLowerCase","validateEnumValue","keys","validateDocumentReference","invalidArgumentMessage","allowUndefined","validateUserInput","allowDeletes","allowTransforms","left","right","find"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;AACAA,MAAM,CAACC,cAAP,CAAsBC,OAAtB,EAA+B,YAA/B,EAA6C;AAAEC,EAAAA,KAAK,EAAE;AAAT,CAA7C;;AACA,IAAMC,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAxB;;AACA,IAAMC,SAAS,GAAGD,OAAO,CAAC,iBAAD,CAAzB;;AACA,IAAME,UAAU,GAAGF,OAAO,CAAC,YAAD,CAA1B;;AACA,IAAMG,iBAAiB,GAAGH,OAAO,CAAC,mBAAD,CAAjC;;AACA,IAAMI,QAAQ,GAAGJ,OAAO,CAAC,UAAD,CAAxB;;AACA,IAAMK,OAAO,GAAGL,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMM,MAAM,GAAGN,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMO,YAAY,GAAGP,OAAO,CAAC,cAAD,CAA5B;;AACA,IAAMQ,WAAW,GAAGR,OAAO,CAAC,aAAD,CAA3B;;AACA,IAAMS,OAAO,GAAGT,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMU,MAAM,GAAGV,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAMW,UAAU,GAAGX,OAAO,CAAC,YAAD,CAA1B;;AACA,IAAMY,OAAO,GAAGZ,OAAO,CAAC,SAAD,CAAvB;;AACA,IAAMa,aAAa,GAAGb,OAAO,CAAC,eAAD,CAA7B;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,IAAMc,kBAAkB,GAAG;AACvBC,EAAAA,GAAG,EAAE,WADkB;AAEvBC,EAAAA,IAAI,EAAE;AAFiB,CAA3B;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,IAAMC,mBAAmB,GAAG;AACxB,OAAK,WADmB;AAExB,QAAM,oBAFkB;AAGxB,QAAM,OAHkB;AAIxB,QAAM,WAJkB;AAKxB,OAAK,cALmB;AAMxB,QAAM,uBANkB;AAOxB,oBAAkB,gBAPM;AAQxBC,EAAAA,EAAE,EAAE,IARoB;AASxB,YAAU,QATc;AAUxB,wBAAsB;AAVE,CAA5B;AAYA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;IACMC,iB;AACF;AACJ;AACA;AACA;AACA;AACA;AACI,6BAAYC,UAAZ,EAAwBC,KAAxB,EAAwE;AAAA,QAAzCC,UAAyC,uEAA5Bb,OAAO,CAACc,gBAAR,EAA4B;;AAAA;;AACpE,SAAKH,UAAL,GAAkBA,UAAlB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKC,UAAL,GAAkBA,UAAlB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;;;;;SACI,eAAoB;AAChB,UAAME,SAAS,GAAG,KAAKC,SAAL,CAAeD,SAAjC;AACA,aAAO,KAAKH,KAAL,CAAWK,uBAAX,CAAmCF,SAAnC,EAA8CG,aAArD;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAgB;AACZ,aAAO,KAAKP,UAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAW;AACP,aAAO,KAAKC,KAAL,CAAWO,YAAlB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAS;AACL,aAAO,KAAKP,KAAL,CAAWQ,EAAlB;AACH;AACD;AACJ;AACA;AACA;;;;SACI,eAAoB;AAChB,aAAO,KAAKR,KAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAa;AACT,aAAO,IAAIS,mBAAJ,CAAwB,KAAKV,UAA7B,EAAyC,KAAKC,KAAL,CAAWU,MAAX,EAAzC,EAA8D,KAAKT,UAAnE,CAAP;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;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AAhB,CAA4B,KAAKrG,KAAjC;AALE;AADV,OAAP;AASH;;;;;AAEL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;IACMsG,a;AACF;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACI,yBAAYC,MAAZ,EAAoBC,SAApB,EAA+BC,KAA/B,EAAsCzB,IAAtC,EAA4C0B,OAA5C,EAAqD;AAAA;;AACjD,SAAKH,MAAL,GAAcA,MAAd;AACA,SAAKC,SAAL,GAAiBA,SAAjB;AACA,SAAKC,KAAL,GAAaA,KAAb;AACA,SAAKE,iBAAL,GAAyB,IAAzB;AACA,SAAKC,oBAAL,GAA4B,IAA5B;AACA,SAAKC,KAAL,GAAa,IAAb;AACA,SAAKC,QAAL,GAAgB,IAAhB;AACA,SAAKD,KAAL,GAAa7B,IAAb;AACA,SAAK8B,QAAL,GAAgBJ,OAAhB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;SACI,eAAY;AACR,aAAO,KAAKH,MAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAW;AACP,UAAI,KAAKI,iBAAT,EAA4B;AACxB,eAAO,KAAKA,iBAAZ;AACH;;AACD,WAAKA,iBAAL,GAAyB,KAAKE,KAAL,EAAzB;AACA,WAAKA,KAAL,GAAa,IAAb;AACA,aAAO,KAAKF,iBAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAY;AACR,aAAO,KAAKF,KAAL,KAAe,CAAtB;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;SACI,eAAW;AACP,aAAO,KAAKA,KAAZ;AACH;AACD;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst stream_1 = require(\"stream\");\nconst deepEqual = require(\"fast-deep-equal\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst order_1 = require(\"./order\");\nconst path_1 = require(\"./path\");\nconst serializer_1 = require(\"./serializer\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\nconst validate_1 = require(\"./validate\");\nconst watch_1 = require(\"./watch\");\nconst write_batch_1 = require(\"./write-batch\");\n/**\n * The direction of a `Query.orderBy()` clause is specified as 'desc' or 'asc'\n * (descending or ascending).\n *\n * @private\n */\nconst directionOperators = {\n    asc: 'ASCENDING',\n    desc: 'DESCENDING',\n};\n/**\n * Filter conditions in a `Query.where()` clause are specified using the\n * strings '<', '<=', '==', '!=', '>=', '>', 'array-contains', 'in', 'not-in',\n * and 'array-contains-any'.\n *\n * @private\n */\nconst comparisonOperators = {\n    '<': 'LESS_THAN',\n    '<=': 'LESS_THAN_OR_EQUAL',\n    '==': 'EQUAL',\n    '!=': 'NOT_EQUAL',\n    '>': 'GREATER_THAN',\n    '>=': 'GREATER_THAN_OR_EQUAL',\n    'array-contains': 'ARRAY_CONTAINS',\n    in: 'IN',\n    'not-in': 'NOT_IN',\n    'array-contains-any': 'ARRAY_CONTAINS_ANY',\n};\n/**\n * onSnapshot() callback that receives a QuerySnapshot.\n *\n * @callback querySnapshotCallback\n * @param {QuerySnapshot} snapshot A query snapshot.\n */\n/**\n * onSnapshot() callback that receives a DocumentSnapshot.\n *\n * @callback documentSnapshotCallback\n * @param {DocumentSnapshot} snapshot A document snapshot.\n */\n/**\n * onSnapshot() callback that receives an error.\n *\n * @callback errorCallback\n * @param {Error} err An error from a listen.\n */\n/**\n * A DocumentReference refers to a document location in a Firestore database\n * and can be used to write, read, or listen to the location. The document at\n * the referenced location may or may not exist. A DocumentReference can\n * also be used to create a\n * [CollectionReference]{@link CollectionReference} to a\n * subcollection.\n *\n * @class DocumentReference\n */\nclass DocumentReference {\n    /**\n     * @hideconstructor\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _path The Path of this reference.\n     */\n    constructor(_firestore, _path, _converter = types_1.defaultConverter()) {\n        this._firestore = _firestore;\n        this._path = _path;\n        this._converter = _converter;\n    }\n    /**\n     * The string representation of the DocumentReference's location.\n     * @private\n     * @type {string}\n     * @name DocumentReference#formattedName\n     */\n    get formattedName() {\n        const projectId = this.firestore.projectId;\n        return this._path.toQualifiedResourcePath(projectId).formattedName;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name DocumentReference#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * A string representing the path of the referenced document (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name DocumentReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document at '${documentReference.path}'`);\n     * });\n     */\n    get path() {\n        return this._path.relativeName;\n    }\n    /**\n     * The last path element of the referenced document.\n     *\n     * @type {string}\n     * @name DocumentReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name '${documentReference.id}'`);\n     * });\n     */\n    get id() {\n        return this._path.id;\n    }\n    /**\n     * Returns a resource path for this document.\n     * @private\n     */\n    get _resourcePath() {\n        return this._path;\n    }\n    /**\n     * A reference to the collection to which this DocumentRference belongs.\n     *e\n     * @name DocumentReference#parent\n     * @type {CollectionReference}\n     * @readonly\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let collectionRef = documentRef.parent;\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(results => {\n     *   console.log(`Found ${results.size} matches in parent collection`);\n     * }):\n     */\n    get parent() {\n        return new CollectionReference(this._firestore, this._path.parent(), this._converter);\n    }\n    /**\n     * Reads the document referred to by this DocumentReference.\n     *\n     * @returns {Promise.<DocumentSnapshot>} A Promise resolved with a\n     * DocumentSnapshot for the retrieved document on success. For missing\n     * documents, DocumentSnapshot.exists will be false. If the get() fails for\n     * other reasons, the Promise will be rejected.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.get().then(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log('Document retrieved successfully.');\n     *   }\n     * });\n     */\n    get() {\n        return this._firestore.getAll(this).then(([result]) => result);\n    }\n    /**\n     * Gets a [CollectionReference]{@link CollectionReference} instance\n     * that refers to the collection at the specified path.\n     *\n     * @param {string} collectionPath A slash-separated path to a collection.\n     * @returns {CollectionReference} A reference to the new\n     * subcollection.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     * let subcollection = documentRef.collection('subcollection');\n     * console.log(`Path to subcollection: ${subcollection.path}`);\n     */\n    collection(collectionPath) {\n        path_1.validateResourcePath('collectionPath', collectionPath);\n        const path = this._path.append(collectionPath);\n        if (!path.isCollection) {\n            throw new Error(`Value for argument \"collectionPath\" must point to a collection, but was \"${collectionPath}\". Your path does not contain an odd number of components.`);\n        }\n        return new CollectionReference(this._firestore, path);\n    }\n    /**\n     * Fetches the subcollections that are direct children of this document.\n     *\n     * @returns {Promise.<Array.<CollectionReference>>} A Promise that resolves\n     * with an array of CollectionReferences.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.listCollections().then(collections => {\n     *   for (let collection of collections) {\n     *     console.log(`Found subcollection with id: ${collection.id}`);\n     *   }\n     * });\n     */\n    listCollections() {\n        const tag = util_1.requestTag();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const request = {\n                parent: this.formattedName,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n            };\n            return this._firestore\n                .request('listCollectionIds', request, tag)\n                .then(collectionIds => {\n                const collections = [];\n                // We can just sort this list using the default comparator since it\n                // will only contain collection ids.\n                collectionIds.sort();\n                for (const collectionId of collectionIds) {\n                    collections.push(this.collection(collectionId));\n                }\n                return collections;\n            });\n        });\n    }\n    /**\n     * Create a document with the provided object values. This will fail the write\n     * if a document exists at its location.\n     *\n     * @param {DocumentData} data An object that contains the fields and data to\n     * serialize as the document.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this create.\n     *\n     * @example\n     * let documentRef = firestore.collection('col').doc();\n     *\n     * documentRef.create({foo: 'bar'}).then((res) => {\n     *   console.log(`Document created at ${res.updateTime}`);\n     * }).catch((err) => {\n     *   console.log(`Failed to create document: ${err}`);\n     * });\n     */\n    create(data) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .create(this, data)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Deletes the document referred to by this `DocumentReference`.\n     *\n     * A delete for a non-existing document is treated as a success (unless\n     * lastUptimeTime is provided).\n     *\n     * @param {Precondition=} precondition A precondition to enforce for this\n     * delete.\n     * @param {Timestamp=} precondition.lastUpdateTime If set, enforces that the\n     * document was last updated at lastUpdateTime. Fails the delete if the\n     * document was last updated at a different time.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * delete time.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.delete().then(() => {\n     *   console.log('Document successfully deleted.');\n     * });\n     */\n    delete(precondition) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .delete(this, precondition)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Writes to the document referred to by this DocumentReference. If the\n     * document does not yet exist, it will be created. If you pass\n     * [SetOptions]{@link SetOptions}, the provided data can be merged into an\n     * existing document.\n     *\n     * @param {T|Partial<T>} data A map of the fields and values for the document.\n     * @param {SetOptions=} options An object to configure the set behavior.\n     * @param {boolean=} options.merge If true, set() merges the values specified\n     * in its data argument. Fields omitted from this set() call remain untouched.\n     * @param {Array.<string|FieldPath>=} options.mergeFields If provided,\n     * set() only replaces the specified field paths. Any field path that is not\n     * specified is ignored and remains untouched.\n     * @returns {Promise.<WriteResult>} A Promise that resolves with the\n     * write time of this set.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.set({foo: 'bar'}).then(res => {\n     *   console.log(`Document written at ${res.updateTime}`);\n     * });\n     */\n    set(data, options) {\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .set(this, data, options)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Updates fields in the document referred to by this DocumentReference.\n     * If the document doesn't yet exist, the update fails and the returned\n     * Promise will be rejected.\n     *\n     * The update() method accepts either an object with field paths encoded as\n     * keys and field values encoded as values, or a variable number of arguments\n     * that alternate between field paths and field values.\n     *\n     * A Precondition restricting this update can be specified as the last\n     * argument.\n     *\n     * @param {UpdateData|string|FieldPath} dataOrField An object containing the\n     * fields and values with which to update the document or the path of the\n     * first field to update.\n     * @param {\n     * ...(*|string|FieldPath|Precondition)} preconditionOrValues An alternating\n     * list of field paths and values to update or a Precondition to restrict\n     * this update.\n     * @returns {Promise.<WriteResult>} A Promise that resolves once the\n     * data has been successfully written to the backend.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * documentRef.update({foo: 'bar'}).then(res => {\n     *   console.log(`Document updated at ${res.updateTime}`);\n     * });\n     */\n    update(dataOrField, ...preconditionOrValues) {\n        // eslint-disable-next-line prefer-rest-params\n        validate_1.validateMinNumberOfArguments('DocumentReference.update', arguments, 1);\n        const writeBatch = new write_batch_1.WriteBatch(this._firestore);\n        return writeBatch\n            .update(this, dataOrField, ...preconditionOrValues)\n            .commit()\n            .then(([writeResult]) => writeResult);\n    }\n    /**\n     * Attaches a listener for DocumentSnapshot events.\n     *\n     * @param {documentSnapshotCallback} onNext A callback to be called every\n     * time a new `DocumentSnapshot` is available.\n     * @param {errorCallback=} onError A callback to be called if the listen fails\n     * or is cancelled. No further callbacks will occur. If unset, errors will be\n     * logged to the console.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let documentRef = firestore.doc('col/doc');\n     *\n     * let unsubscribe = documentRef.onSnapshot(documentSnapshot => {\n     *   if (documentSnapshot.exists) {\n     *     console.log(documentSnapshot.data());\n     *   }\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    onSnapshot(onNext, onError) {\n        validate_1.validateFunction('onNext', onNext);\n        validate_1.validateFunction('onError', onError, { optional: true });\n        const watch = new watch_1.DocumentWatch(this.firestore, this);\n        return watch.onSnapshot((readTime, size, docs) => {\n            for (const document of docs()) {\n                if (document.ref.path === this.path) {\n                    onNext(document);\n                    return;\n                }\n            }\n            // The document is missing.\n            const ref = new DocumentReference(this._firestore, this._path, this._converter);\n            const document = new document_1.DocumentSnapshotBuilder(ref);\n            document.readTime = readTime;\n            onNext(document.build());\n        }, onError || console.error);\n    }\n    /**\n     * Returns true if this `DocumentReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `DocumentReference` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof DocumentReference &&\n                this._firestore === other._firestore &&\n                this._path.isEqual(other._path) &&\n                this._converter === other._converter));\n    }\n    /**\n     * Converts this DocumentReference to the Firestore Proto representation.\n     *\n     * @private\n     */\n    toProto() {\n        return { referenceValue: this.formattedName };\n    }\n    withConverter(converter) {\n        return new DocumentReference(this.firestore, this._path, converter !== null && converter !== void 0 ? converter : types_1.defaultConverter());\n    }\n}\nexports.DocumentReference = DocumentReference;\n/**\n * A Query order-by field.\n *\n * @private\n * @class\n */\nclass FieldOrder {\n    /**\n     * @param field The name of a document field (member) on which to order query\n     * results.\n     * @param direction One of 'ASCENDING' (default) or 'DESCENDING' to\n     * set the ordering direction to ascending or descending, respectively.\n     */\n    constructor(field, direction = 'ASCENDING') {\n        this.field = field;\n        this.direction = direction;\n    }\n    /**\n     * Generates the proto representation for this field order.\n     * @private\n     */\n    toProto() {\n        return {\n            field: {\n                fieldPath: this.field.formattedName,\n            },\n            direction: this.direction,\n        };\n    }\n}\nexports.FieldOrder = FieldOrder;\n/**\n * A field constraint for a Query where clause.\n *\n * @private\n * @class\n */\nclass FieldFilter {\n    /**\n     * @param serializer The Firestore serializer\n     * @param field The path of the property value to compare.\n     * @param op A comparison operation.\n     * @param value The value to which to compare the field for inclusion in a\n     * query.\n     */\n    constructor(serializer, field, op, value) {\n        this.serializer = serializer;\n        this.field = field;\n        this.op = op;\n        this.value = value;\n    }\n    /**\n     * Returns whether this FieldFilter uses an equals comparison.\n     *\n     * @private\n     */\n    isInequalityFilter() {\n        switch (this.op) {\n            case 'GREATER_THAN':\n            case 'GREATER_THAN_OR_EQUAL':\n            case 'LESS_THAN':\n            case 'LESS_THAN_OR_EQUAL':\n                return true;\n            default:\n                return false;\n        }\n    }\n    /**\n     * Generates the proto representation for this field filter.\n     *\n     * @private\n     */\n    toProto() {\n        if (typeof this.value === 'number' && isNaN(this.value)) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: this.op === 'EQUAL' ? 'IS_NAN' : 'IS_NOT_NAN',\n                },\n            };\n        }\n        if (this.value === null) {\n            return {\n                unaryFilter: {\n                    field: {\n                        fieldPath: this.field.formattedName,\n                    },\n                    op: this.op === 'EQUAL' ? 'IS_NULL' : 'IS_NOT_NULL',\n                },\n            };\n        }\n        return {\n            fieldFilter: {\n                field: {\n                    fieldPath: this.field.formattedName,\n                },\n                op: this.op,\n                value: this.serializer.encodeValue(this.value),\n            },\n        };\n    }\n}\n/**\n * A QuerySnapshot contains zero or more\n * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} objects\n * representing the results of a query. The documents can be accessed as an\n * array via the [documents]{@link QuerySnapshot#documents} property\n * or enumerated using the [forEach]{@link QuerySnapshot#forEach}\n * method. The number of documents can be determined via the\n * [empty]{@link QuerySnapshot#empty} and\n * [size]{@link QuerySnapshot#size} properties.\n *\n * @class QuerySnapshot\n */\nclass QuerySnapshot {\n    /**\n     * @hideconstructor\n     *\n     * @param _query The originating query.\n     * @param _readTime The time when this query snapshot was obtained.\n     * @param _size The number of documents in the result set.\n     * @param docs A callback returning a sorted array of documents matching\n     * this query\n     * @param changes A callback returning a sorted array of document change\n     * events for this snapshot.\n     */\n    constructor(_query, _readTime, _size, docs, changes) {\n        this._query = _query;\n        this._readTime = _readTime;\n        this._size = _size;\n        this._materializedDocs = null;\n        this._materializedChanges = null;\n        this._docs = null;\n        this._changes = null;\n        this._docs = docs;\n        this._changes = changes;\n    }\n    /**\n     * The query on which you called get() or onSnapshot() in order to get this\n     * QuerySnapshot.\n     *\n     * @type {Query}\n     * @name QuerySnapshot#query\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.limit(10).get().then(querySnapshot => {\n     *   console.log(`Returned first batch of results`);\n     *   let query = querySnapshot.query;\n     *   return query.offset(10).get();\n     * }).then(() => {\n     *   console.log(`Returned second batch of results`);\n     * });\n     */\n    get query() {\n        return this._query;\n    }\n    /**\n     * An array of all the documents in this QuerySnapshot.\n     *\n     * @type {Array.<QueryDocumentSnapshot>}\n     * @name QuerySnapshot#docs\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   let docs = querySnapshot.docs;\n     *   for (let doc of docs) {\n     *     console.log(`Document found at path: ${doc.ref.path}`);\n     *   }\n     * });\n     */\n    get docs() {\n        if (this._materializedDocs) {\n            return this._materializedDocs;\n        }\n        this._materializedDocs = this._docs();\n        this._docs = null;\n        return this._materializedDocs;\n    }\n    /**\n     * True if there are no documents in the QuerySnapshot.\n     *\n     * @type {boolean}\n     * @name QuerySnapshot#empty\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   if (querySnapshot.empty) {\n     *     console.log('No documents found.');\n     *   }\n     * });\n     */\n    get empty() {\n        return this._size === 0;\n    }\n    /**\n     * The number of documents in the QuerySnapshot.\n     *\n     * @type {number}\n     * @name QuerySnapshot#size\n     * @readonly\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   console.log(`Found ${querySnapshot.size} documents.`);\n     * });\n     */\n    get size() {\n        return this._size;\n    }\n    /**\n     * The time this query snapshot was obtained.\n     *\n     * @type {Timestamp}\n     * @name QuerySnapshot#readTime\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then((querySnapshot) => {\n     *   let readTime = querySnapshot.readTime;\n     *   console.log(`Query results returned at '${readTime.toDate()}'`);\n     * });\n     */\n    get readTime() {\n        return this._readTime;\n    }\n    /**\n     * Returns an array of the documents changes since the last snapshot. If\n     * this is the first snapshot, all documents will be in the list as added\n     * changes.\n     *\n     * @return {Array.<DocumentChange>}\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.onSnapshot(querySnapshot => {\n     *   let changes = querySnapshot.docChanges();\n     *   for (let change of changes) {\n     *     console.log(`A document was ${change.type}.`);\n     *   }\n     * });\n     */\n    docChanges() {\n        if (this._materializedChanges) {\n            return this._materializedChanges;\n        }\n        this._materializedChanges = this._changes();\n        this._changes = null;\n        return this._materializedChanges;\n    }\n    /**\n     * Enumerates all of the documents in the QuerySnapshot. This is a convenience\n     * method for running the same callback on each {@link QueryDocumentSnapshot}\n     * that is returned.\n     *\n     * @param {function} callback A callback to be called with a\n     * [QueryDocumentSnapshot]{@link QueryDocumentSnapshot} for each document in\n     * the snapshot.\n     * @param {*=} thisArg The `this` binding for the callback..\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Document found at path: ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    forEach(callback, thisArg) {\n        validate_1.validateFunction('callback', callback);\n        for (const doc of this.docs) {\n            callback.call(thisArg, doc);\n        }\n    }\n    /**\n     * Returns true if the document data in this `QuerySnapshot` is equal to the\n     * provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `QuerySnapshot` is equal to the provided\n     * value.\n     */\n    isEqual(other) {\n        // Since the read time is different on every query read, we explicitly\n        // ignore all metadata in this comparison.\n        if (this === other) {\n            return true;\n        }\n        if (!(other instanceof QuerySnapshot)) {\n            return false;\n        }\n        if (this._size !== other._size) {\n            return false;\n        }\n        if (!this._query.isEqual(other._query)) {\n            return false;\n        }\n        if (this._materializedDocs && !this._materializedChanges) {\n            // If we have only materialized the documents, we compare them first.\n            return (isArrayEqual(this.docs, other.docs) &&\n                isArrayEqual(this.docChanges(), other.docChanges()));\n        }\n        // Otherwise, we compare the changes first as we expect there to be fewer.\n        return (isArrayEqual(this.docChanges(), other.docChanges()) &&\n            isArrayEqual(this.docs, other.docs));\n    }\n}\nexports.QuerySnapshot = QuerySnapshot;\n/*!\n * Denotes whether a provided limit is applied to the beginning or the end of\n * the result set.\n */\nvar LimitType;\n(function (LimitType) {\n    LimitType[LimitType[\"First\"] = 0] = \"First\";\n    LimitType[LimitType[\"Last\"] = 1] = \"Last\";\n})(LimitType || (LimitType = {}));\n/**\n * Internal class representing custom Query options.\n *\n * These options are immutable. Modified options can be created using `with()`.\n * @private\n */\nclass QueryOptions {\n    constructor(parentPath, collectionId, converter, allDescendants, fieldFilters, fieldOrders, startAt, endAt, limit, limitType, offset, projection, \n    // Whether to select all documents under `parentPath`. By default, only\n    // collections that match `collectionId` are selected.\n    kindless = false) {\n        this.parentPath = parentPath;\n        this.collectionId = collectionId;\n        this.converter = converter;\n        this.allDescendants = allDescendants;\n        this.fieldFilters = fieldFilters;\n        this.fieldOrders = fieldOrders;\n        this.startAt = startAt;\n        this.endAt = endAt;\n        this.limit = limit;\n        this.limitType = limitType;\n        this.offset = offset;\n        this.projection = projection;\n        this.kindless = kindless;\n    }\n    /**\n     * Returns query options for a collection group query.\n     * @private\n     */\n    static forCollectionGroupQuery(collectionId, converter = types_1.defaultConverter()) {\n        return new QueryOptions(\n        /*parentPath=*/ path_1.ResourcePath.EMPTY, collectionId, converter, \n        /*allDescendants=*/ true, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns query options for a single-collection query.\n     * @private\n     */\n    static forCollectionQuery(collectionRef, converter = types_1.defaultConverter()) {\n        return new QueryOptions(collectionRef.parent(), collectionRef.id, converter, \n        /*allDescendants=*/ false, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n    }\n    /**\n     * Returns query options for a query that fetches all descendants under the\n     * specified reference.\n     *\n     * @private\n     */\n    static forKindlessAllDescendants(parent, id) {\n        let options = new QueryOptions(parent, id, types_1.defaultConverter(), \n        /*allDescendants=*/ true, \n        /*fieldFilters=*/ [], \n        /*fieldOrders=*/ []);\n        options = options.with({\n            kindless: true,\n        });\n        return options;\n    }\n    /**\n     * Returns the union of the current and the provided options.\n     * @private\n     */\n    with(settings) {\n        return new QueryOptions(coalesce(settings.parentPath, this.parentPath), coalesce(settings.collectionId, this.collectionId), this.converter, coalesce(settings.allDescendants, this.allDescendants), coalesce(settings.fieldFilters, this.fieldFilters), coalesce(settings.fieldOrders, this.fieldOrders), coalesce(settings.startAt, this.startAt), coalesce(settings.endAt, this.endAt), coalesce(settings.limit, this.limit), coalesce(settings.limitType, this.limitType), coalesce(settings.offset, this.offset), coalesce(settings.projection, this.projection), coalesce(settings.kindless, this.kindless));\n    }\n    withConverter(converter) {\n        return new QueryOptions(this.parentPath, this.collectionId, converter, this.allDescendants, this.fieldFilters, this.fieldOrders, this.startAt, this.endAt, this.limit, this.limitType, this.offset, this.projection);\n    }\n    hasFieldOrders() {\n        return this.fieldOrders.length > 0;\n    }\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof QueryOptions &&\n            this.parentPath.isEqual(other.parentPath) &&\n            this.collectionId === other.collectionId &&\n            this.converter === other.converter &&\n            this.allDescendants === other.allDescendants &&\n            this.limit === other.limit &&\n            this.offset === other.offset &&\n            deepEqual(this.fieldFilters, other.fieldFilters) &&\n            deepEqual(this.fieldOrders, other.fieldOrders) &&\n            deepEqual(this.startAt, other.startAt) &&\n            deepEqual(this.endAt, other.endAt) &&\n            deepEqual(this.projection, other.projection) &&\n            this.kindless === other.kindless);\n    }\n}\nexports.QueryOptions = QueryOptions;\n/**\n * A Query refers to a query which you can read or stream from. You can also\n * construct refined Query objects by adding filters and ordering.\n *\n * @class Query\n */\nclass Query {\n    /**\n     * @hideconstructor\n     *\n     * @param _firestore The Firestore Database client.\n     * @param _queryOptions Options that define the query.\n     */\n    constructor(_firestore, _queryOptions) {\n        this._firestore = _firestore;\n        this._queryOptions = _queryOptions;\n        this._serializer = new serializer_1.Serializer(_firestore);\n        this._allowUndefined = !!this._firestore._settings\n            .ignoreUndefinedProperties;\n    }\n    /**\n     * Extracts field values from the DocumentSnapshot based on the provided\n     * field order.\n     *\n     * @private\n     * @param documentSnapshot The document to extract the fields from.\n     * @param fieldOrders The field order that defines what fields we should\n     * extract.\n     * @return {Array.<*>} The field values to use.\n     * @private\n     */\n    static _extractFieldValues(documentSnapshot, fieldOrders) {\n        const fieldValues = [];\n        for (const fieldOrder of fieldOrders) {\n            if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                fieldValues.push(documentSnapshot.ref);\n            }\n            else {\n                const fieldValue = documentSnapshot.get(fieldOrder.field);\n                if (fieldValue === undefined) {\n                    throw new Error(`Field \"${fieldOrder.field}\" is missing in the provided DocumentSnapshot. ` +\n                        'Please provide a document that contains values for all specified ' +\n                        'orderBy() and where() constraints.');\n                }\n                else {\n                    fieldValues.push(fieldValue);\n                }\n            }\n        }\n        return fieldValues;\n    }\n    /**\n     * The [Firestore]{@link Firestore} instance for the Firestore\n     * database (useful for performing transactions, etc.).\n     *\n     * @type {Firestore}\n     * @name Query#firestore\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   let firestore = documentReference.firestore;\n     *   console.log(`Root location for document is ${firestore.formattedName}`);\n     * });\n     */\n    get firestore() {\n        return this._firestore;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} with the additional filter\n     * that documents must contain the specified field and that its value should\n     * satisfy the relation constraint provided.\n     *\n     * Returns a new Query that constrains the value of a Document property.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the filter.\n     *\n     * @param {string|FieldPath} fieldPath The name of a property value to compare.\n     * @param {string} opStr A comparison operation in the form of a string\n     * (e.g., \"<\").\n     * @param {*} value The value to which to compare the field for inclusion in\n     * a query.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * collectionRef.where('foo', '==', 'bar').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    where(fieldPath, opStr, value) {\n        path_1.validateFieldPath('fieldPath', fieldPath);\n        opStr = validateQueryOperator('opStr', opStr, value);\n        validateQueryValue('value', value, this._allowUndefined);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify a where() filter after calling startAt(), ' +\n                'startAfter(), endBefore() or endAt().');\n        }\n        const path = path_1.FieldPath.fromArgument(fieldPath);\n        if (path_1.FieldPath.documentId().isEqual(path)) {\n            if (opStr === 'array-contains' || opStr === 'array-contains-any') {\n                throw new Error(`Invalid Query. You can't perform '${opStr}' ` +\n                    'queries on FieldPath.documentId().');\n            }\n            if (opStr === 'in' || opStr === 'not-in') {\n                if (!Array.isArray(value) || value.length === 0) {\n                    throw new Error(`Invalid Query. A non-empty array is required for '${opStr}' filters.`);\n                }\n                value = value.map(el => this.validateReference(el));\n            }\n            else {\n                value = this.validateReference(value);\n            }\n        }\n        const fieldFilter = new FieldFilter(this._serializer, path, comparisonOperators[opStr], value);\n        const options = this._queryOptions.with({\n            fieldFilters: this._queryOptions.fieldFilters.concat(fieldFilter),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} instance that applies a\n     * field mask to the result and returns only the specified subset of fields.\n     * You can specify a list of field paths to return, or use an empty list to\n     * only return the references of matching documents.\n     *\n     * Queries that contain field masks cannot be listened to via `onSnapshot()`\n     * listeners.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {...(string|FieldPath)} fieldPaths The field paths to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRef = collectionRef.doc('doc');\n     *\n     * return documentRef.set({x:10, y:5}).then(() => {\n     *   return collectionRef.where('x', '>', 5).select('y').get();\n     * }).then((res) => {\n     *   console.log(`y is ${res.docs[0].get('y')}.`);\n     * });\n     */\n    select(...fieldPaths) {\n        const fields = [];\n        if (fieldPaths.length === 0) {\n            fields.push({ fieldPath: path_1.FieldPath.documentId().formattedName });\n        }\n        else {\n            for (let i = 0; i < fieldPaths.length; ++i) {\n                path_1.validateFieldPath(i, fieldPaths[i]);\n                fields.push({\n                    fieldPath: path_1.FieldPath.fromArgument(fieldPaths[i]).formattedName,\n                });\n            }\n        }\n        // By specifying a field mask, the query result no longer conforms to type\n        // `T`. We there return `Query<DocumentData>`;\n        const options = this._queryOptions.with({\n            projection: { fields },\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that's additionally sorted\n     * by the specified field, optionally in descending order instead of\n     * ascending.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the field mask.\n     *\n     * @param {string|FieldPath} fieldPath The field to sort by.\n     * @param {string=} directionStr Optional direction to sort by ('asc' or\n     * 'desc'). If not specified, order will be ascending.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.orderBy('foo', 'desc').get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    orderBy(fieldPath, directionStr) {\n        path_1.validateFieldPath('fieldPath', fieldPath);\n        directionStr = validateQueryOrder('directionStr', directionStr);\n        if (this._queryOptions.startAt || this._queryOptions.endAt) {\n            throw new Error('Cannot specify an orderBy() constraint after calling ' +\n                'startAt(), startAfter(), endBefore() or endAt().');\n        }\n        const newOrder = new FieldOrder(path_1.FieldPath.fromArgument(fieldPath), directionOperators[directionStr || 'asc']);\n        const options = this._queryOptions.with({\n            fieldOrders: this._queryOptions.fieldOrders.concat(newOrder),\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * first matching documents.\n     *\n     * This function returns a new (immutable) instance of the Query (rather than\n     * modify the existing instance) to impose the limit.\n     *\n     * @param {number} limit The maximum number of items to return.\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    limit(limit) {\n        validate_1.validateInteger('limit', limit);\n        const options = this._queryOptions.with({\n            limit,\n            limitType: LimitType.First,\n        });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that only returns the\n     * last matching documents.\n     *\n     * You must specify at least one orderBy clause for limitToLast queries,\n     * otherwise an exception will be thrown during execution.\n     *\n     * Results for limitToLast queries cannot be streamed via the `stream()` API.\n     *\n     * @param limit The maximum number of items to return.\n     * @return The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limitToLast(1).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Last matching document is ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    limitToLast(limit) {\n        validate_1.validateInteger('limitToLast', limit);\n        const options = this._queryOptions.with({ limit, limitType: LimitType.Last });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Specifies the offset of the returned results.\n     *\n     * This function returns a new (immutable) instance of the\n     * [Query]{@link Query} (rather than modify the existing instance)\n     * to impose the offset.\n     *\n     * @param {number} offset The offset to apply to the Query results\n     * @returns {Query} The created Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '>', 42);\n     *\n     * query.limit(10).offset(20).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    offset(offset) {\n        validate_1.validateInteger('offset', offset);\n        const options = this._queryOptions.with({ offset });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Returns true if this `Query` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `Query` is equal to the provided value.\n     */\n    isEqual(other) {\n        if (this === other) {\n            return true;\n        }\n        return (other instanceof Query && this._queryOptions.isEqual(other._queryOptions));\n    }\n    /**\n     * Computes the backend ordering semantics for DocumentSnapshot cursors.\n     *\n     * @private\n     * @param cursorValuesOrDocumentSnapshot The snapshot of the document or the\n     * set of field values to use as the boundary.\n     * @returns The implicit ordering semantics.\n     */\n    createImplicitOrderBy(cursorValuesOrDocumentSnapshot) {\n        // Add an implicit orderBy if the only cursor value is a DocumentSnapshot\n        // or a DocumentReference.\n        if (cursorValuesOrDocumentSnapshot.length !== 1 ||\n            !(cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot ||\n                cursorValuesOrDocumentSnapshot[0] instanceof DocumentReference)) {\n            return this._queryOptions.fieldOrders;\n        }\n        const fieldOrders = this._queryOptions.fieldOrders.slice();\n        let hasDocumentId = false;\n        if (fieldOrders.length === 0) {\n            // If no explicit ordering is specified, use the first inequality to\n            // define an implicit order.\n            for (const fieldFilter of this._queryOptions.fieldFilters) {\n                if (fieldFilter.isInequalityFilter()) {\n                    fieldOrders.push(new FieldOrder(fieldFilter.field));\n                    break;\n                }\n            }\n        }\n        else {\n            for (const fieldOrder of fieldOrders) {\n                if (path_1.FieldPath.documentId().isEqual(fieldOrder.field)) {\n                    hasDocumentId = true;\n                }\n            }\n        }\n        if (!hasDocumentId) {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = fieldOrders.length === 0\n                ? directionOperators.ASC\n                : fieldOrders[fieldOrders.length - 1].direction;\n            fieldOrders.push(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n        }\n        return fieldOrders;\n    }\n    /**\n     * Builds a Firestore 'Position' proto message.\n     *\n     * @private\n     * @param {Array.<FieldOrder>} fieldOrders The field orders to use for this\n     * cursor.\n     * @param {Array.<DocumentSnapshot|*>} cursorValuesOrDocumentSnapshot The\n     * snapshot of the document or the set of field values to use as the boundary.\n     * @param before Whether the query boundary lies just before or after the\n     * provided data.\n     * @returns {Object} The proto message.\n     */\n    createCursor(fieldOrders, cursorValuesOrDocumentSnapshot, before) {\n        let fieldValues;\n        if (cursorValuesOrDocumentSnapshot.length === 1 &&\n            cursorValuesOrDocumentSnapshot[0] instanceof document_1.DocumentSnapshot) {\n            fieldValues = Query._extractFieldValues(cursorValuesOrDocumentSnapshot[0], fieldOrders);\n        }\n        else {\n            fieldValues = cursorValuesOrDocumentSnapshot;\n        }\n        if (fieldValues.length > fieldOrders.length) {\n            throw new Error('Too many cursor values specified. The specified ' +\n                'values must match the orderBy() constraints of the query.');\n        }\n        const options = { values: [], before };\n        for (let i = 0; i < fieldValues.length; ++i) {\n            let fieldValue = fieldValues[i];\n            if (path_1.FieldPath.documentId().isEqual(fieldOrders[i].field)) {\n                fieldValue = this.validateReference(fieldValue);\n            }\n            validateQueryValue(i, fieldValue, this._allowUndefined);\n            options.values.push(this._serializer.encodeValue(fieldValue));\n        }\n        return options;\n    }\n    /**\n     * Validates that a value used with FieldValue.documentId() is either a\n     * string or a DocumentReference that is part of the query`s result set.\n     * Throws a validation error or returns a DocumentReference that can\n     * directly be used in the Query.\n     *\n     * @param val The value to validate.\n     * @throws If the value cannot be used for this query.\n     * @return If valid, returns a DocumentReference that can be used with the\n     * query.\n     * @private\n     */\n    validateReference(val) {\n        const basePath = this._queryOptions.allDescendants\n            ? this._queryOptions.parentPath\n            : this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n        let reference;\n        if (typeof val === 'string') {\n            const path = basePath.append(val);\n            if (this._queryOptions.allDescendants) {\n                if (!path.isDocument) {\n                    throw new Error('When querying a collection group and ordering by ' +\n                        'FieldPath.documentId(), the corresponding value must result in ' +\n                        `a valid document path, but '${val}' is not because it ` +\n                        'contains an odd number of segments.');\n                }\n            }\n            else if (val.indexOf('/') !== -1) {\n                throw new Error('When querying a collection and ordering by FieldPath.documentId(), ' +\n                    `the corresponding value must be a plain document ID, but '${val}' ` +\n                    'contains a slash.');\n            }\n            reference = new DocumentReference(this._firestore, basePath.append(val), this._queryOptions.converter);\n        }\n        else if (val instanceof DocumentReference) {\n            reference = val;\n            if (!basePath.isPrefixOf(reference._path)) {\n                throw new Error(`\"${reference.path}\" is not part of the query result set and ` +\n                    'cannot be used as a query boundary.');\n            }\n        }\n        else {\n            throw new Error('The corresponding value for FieldPath.documentId() must be a ' +\n                `string or a DocumentReference, but was \"${val}\".`);\n        }\n        if (!this._queryOptions.allDescendants &&\n            reference._path.parent().compareTo(basePath) !== 0) {\n            throw new Error('Only a direct child can be used as a query boundary. ' +\n                `Found: \"${reference.path}\".`);\n        }\n        return reference;\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start at or the field values to\n     * start this query at, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    startAt(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.startAt', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that starts after the\n     * provided set of field values relative to the order of the query. The order\n     * of the provided values must match the order of the order by clauses of the\n     * query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should start after or the field values to\n     * start this query after, in order of the query's order by.\n     * @returns {Query} A query with the new starting point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').startAfter(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    startAfter(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.startAfter', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const startAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, startAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends before the set of\n     * field values relative to the order of the query. The order of the provided\n     * values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end before or the field values to\n     * end this query before, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endBefore(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    endBefore(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.endBefore', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, true);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Creates and returns a new [Query]{@link Query} that ends at the provided\n     * set of field values relative to the order of the query. The order of the\n     * provided values must match the order of the order by clauses of the query.\n     *\n     * @param {...*|DocumentSnapshot} fieldValuesOrDocumentSnapshot The snapshot\n     * of the document the query results should end at or the field values to end\n     * this query at, in order of the query's order by.\n     * @returns {Query} A query with the new ending point.\n     *\n     * @example\n     * let query = firestore.collection('col');\n     *\n     * query.orderBy('foo').endAt(42).get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    endAt(...fieldValuesOrDocumentSnapshot) {\n        validate_1.validateMinNumberOfArguments('Query.endAt', fieldValuesOrDocumentSnapshot, 1);\n        const fieldOrders = this.createImplicitOrderBy(fieldValuesOrDocumentSnapshot);\n        const endAt = this.createCursor(fieldOrders, fieldValuesOrDocumentSnapshot, false);\n        const options = this._queryOptions.with({ fieldOrders, endAt });\n        return new Query(this._firestore, options);\n    }\n    /**\n     * Executes the query and returns the results as a\n     * [QuerySnapshot]{@link QuerySnapshot}.\n     *\n     * @returns {Promise.<QuerySnapshot>} A Promise that resolves with the results\n     * of the Query.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * query.get().then(querySnapshot => {\n     *   querySnapshot.forEach(documentSnapshot => {\n     *     console.log(`Found document at ${documentSnapshot.ref.path}`);\n     *   });\n     * });\n     */\n    get() {\n        return this._get();\n    }\n    /**\n     * Internal get() method that accepts an optional transaction id.\n     *\n     * @private\n     * @param {bytes=} transactionId A transaction ID.\n     */\n    _get(transactionId) {\n        const docs = [];\n        // Capture the error stack to preserve stack tracing across async calls.\n        const stack = Error().stack;\n        return new Promise((resolve, reject) => {\n            let readTime;\n            this._stream(transactionId)\n                .on('error', err => {\n                reject(util_1.wrapError(err, stack));\n            })\n                .on('data', result => {\n                readTime = result.readTime;\n                if (result.document) {\n                    docs.push(result.document);\n                }\n            })\n                .on('end', () => {\n                if (this._queryOptions.limitType === LimitType.Last) {\n                    // The results for limitToLast queries need to be flipped since\n                    // we reversed the ordering constraints before sending the query\n                    // to the backend.\n                    docs.reverse();\n                }\n                resolve(new QuerySnapshot(this, readTime, docs.length, () => docs, () => {\n                    const changes = [];\n                    for (let i = 0; i < docs.length; ++i) {\n                        changes.push(new document_change_1.DocumentChange('added', docs[i], -1, i));\n                    }\n                    return changes;\n                }));\n            });\n        });\n    }\n    /**\n     * Executes the query and streams the results as\n     * [QueryDocumentSnapshots]{@link QueryDocumentSnapshot}.\n     *\n     * @returns {Stream.<QueryDocumentSnapshot>} A stream of\n     * QueryDocumentSnapshots.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let count = 0;\n     *\n     * query.stream().on('data', (documentSnapshot) => {\n     *   console.log(`Found document with name '${documentSnapshot.id}'`);\n     *   ++count;\n     * }).on('end', () => {\n     *   console.log(`Total count is ${count}`);\n     * });\n     */\n    stream() {\n        if (this._queryOptions.limitType === LimitType.Last) {\n            throw new Error('Query results for queries that include limitToLast() ' +\n                'constraints cannot be streamed. Use Query.get() instead.');\n        }\n        const responseStream = this._stream();\n        const transform = new stream_1.Transform({\n            objectMode: true,\n            transform(chunk, encoding, callback) {\n                callback(undefined, chunk.document);\n            },\n        });\n        responseStream.pipe(transform);\n        responseStream.on('error', e => transform.destroy(e));\n        return transform;\n    }\n    /**\n     * Converts a QueryCursor to its proto representation.\n     *\n     * @param cursor The original cursor value\n     * @private\n     */\n    toCursor(cursor) {\n        if (cursor) {\n            return cursor.before\n                ? { before: true, values: cursor.values }\n                : { values: cursor.values };\n        }\n        return undefined;\n    }\n    /**\n     * Internal method for serializing a query to its RunQuery proto\n     * representation with an optional transaction id or read time.\n     *\n     * @param transactionIdOrReadTime A transaction ID or the read time at which\n     * to execute the query.\n     * @private\n     * @returns Serialized JSON for the query.\n     */\n    toProto(transactionIdOrReadTime) {\n        const projectId = this.firestore.projectId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n        const structuredQuery = this.toStructuredQuery();\n        // For limitToLast queries, the structured query has to be translated to a version with\n        // reversed ordered, and flipped startAt/endAt to work properly.\n        if (this._queryOptions.limitType === LimitType.Last) {\n            if (!this._queryOptions.hasFieldOrders()) {\n                throw new Error('limitToLast() queries require specifying at least one orderBy() clause.');\n            }\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(order => {\n                // Flip the orderBy directions since we want the last results\n                const dir = order.direction === 'DESCENDING' ? 'ASCENDING' : 'DESCENDING';\n                return new FieldOrder(order.field, dir).toProto();\n            });\n            // Swap the cursors to match the now-flipped query ordering.\n            structuredQuery.startAt = this._queryOptions.endAt\n                ? this.toCursor({\n                    values: this._queryOptions.endAt.values,\n                    before: !this._queryOptions.endAt.before,\n                })\n                : undefined;\n            structuredQuery.endAt = this._queryOptions.startAt\n                ? this.toCursor({\n                    values: this._queryOptions.startAt.values,\n                    before: !this._queryOptions.startAt.before,\n                })\n                : undefined;\n        }\n        const runQueryRequest = {\n            parent: parentPath.formattedName,\n            structuredQuery,\n        };\n        if (transactionIdOrReadTime instanceof Uint8Array) {\n            runQueryRequest.transaction = transactionIdOrReadTime;\n        }\n        else if (transactionIdOrReadTime instanceof timestamp_1.Timestamp) {\n            runQueryRequest.readTime = transactionIdOrReadTime.toProto().timestampValue;\n        }\n        return runQueryRequest;\n    }\n    /**\n     * Converts current Query to an IBundledQuery.\n     *\n     * @private\n     */\n    _toBundledQuery() {\n        const projectId = this.firestore.projectId;\n        const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(projectId);\n        const structuredQuery = this.toStructuredQuery();\n        const bundledQuery = {\n            parent: parentPath.formattedName,\n            structuredQuery,\n        };\n        if (this._queryOptions.limitType === LimitType.First) {\n            bundledQuery.limitType = 'FIRST';\n        }\n        else if (this._queryOptions.limitType === LimitType.Last) {\n            bundledQuery.limitType = 'LAST';\n        }\n        return bundledQuery;\n    }\n    toStructuredQuery() {\n        const structuredQuery = {\n            from: [{}],\n        };\n        if (this._queryOptions.allDescendants) {\n            structuredQuery.from[0].allDescendants = true;\n        }\n        // Kindless queries select all descendant documents, so we remove the\n        // collectionId field.\n        if (!this._queryOptions.kindless) {\n            structuredQuery.from[0].collectionId = this._queryOptions.collectionId;\n        }\n        if (this._queryOptions.fieldFilters.length === 1) {\n            structuredQuery.where = this._queryOptions.fieldFilters[0].toProto();\n        }\n        else if (this._queryOptions.fieldFilters.length > 1) {\n            const filters = [];\n            for (const fieldFilter of this._queryOptions.fieldFilters) {\n                filters.push(fieldFilter.toProto());\n            }\n            structuredQuery.where = {\n                compositeFilter: {\n                    op: 'AND',\n                    filters,\n                },\n            };\n        }\n        if (this._queryOptions.hasFieldOrders()) {\n            structuredQuery.orderBy = this._queryOptions.fieldOrders.map(o => o.toProto());\n        }\n        structuredQuery.startAt = this.toCursor(this._queryOptions.startAt);\n        structuredQuery.endAt = this.toCursor(this._queryOptions.endAt);\n        if (this._queryOptions.limit) {\n            structuredQuery.limit = { value: this._queryOptions.limit };\n        }\n        structuredQuery.offset = this._queryOptions.offset;\n        structuredQuery.select = this._queryOptions.projection;\n        return structuredQuery;\n    }\n    /**\n     * Internal streaming method that accepts an optional transaction ID.\n     *\n     * @param transactionId A transaction ID.\n     * @private\n     * @returns A stream of document results.\n     */\n    _stream(transactionId) {\n        const tag = util_1.requestTag();\n        let lastReceivedDocument = null;\n        const stream = new stream_1.Transform({\n            objectMode: true,\n            transform: (proto, enc, callback) => {\n                const readTime = timestamp_1.Timestamp.fromProto(proto.readTime);\n                if (proto.document) {\n                    const document = this.firestore.snapshot_(proto.document, proto.readTime);\n                    const finalDoc = new document_1.DocumentSnapshotBuilder(document.ref.withConverter(this._queryOptions.converter));\n                    // Recreate the QueryDocumentSnapshot with the DocumentReference\n                    // containing the original converter.\n                    finalDoc.fieldsProto = document._fieldsProto;\n                    finalDoc.readTime = document.readTime;\n                    finalDoc.createTime = document.createTime;\n                    finalDoc.updateTime = document.updateTime;\n                    lastReceivedDocument = finalDoc.build();\n                    callback(undefined, { document: lastReceivedDocument, readTime });\n                }\n                else {\n                    callback(undefined, { readTime });\n                }\n            },\n        });\n        this.firestore\n            .initializeIfNeeded(tag)\n            .then(async () => {\n            // `toProto()` might throw an exception. We rely on the behavior of an\n            // async function to convert this exception into the rejected Promise we\n            // catch below.\n            let request = this.toProto(transactionId);\n            let streamActive;\n            do {\n                streamActive = new util_1.Deferred();\n                const backendStream = await this._firestore.requestStream('runQuery', request, tag);\n                backendStream.on('error', err => {\n                    backendStream.unpipe(stream);\n                    // If a non-transactional query failed, attempt to restart.\n                    // Transactional queries are retried via the transaction runner.\n                    if (!transactionId && !util_1.isPermanentRpcError(err, 'runQuery')) {\n                        logger_1.logger('Query._stream', tag, 'Query failed with retryable stream error:', err);\n                        if (lastReceivedDocument) {\n                            // Restart the query but use the last document we received as the\n                            // query cursor. Note that we do not use backoff here. The call to\n                            // `requestStream()` will backoff should the restart fail before\n                            // delivering any results.\n                            request = this.startAfter(lastReceivedDocument).toProto(lastReceivedDocument.readTime);\n                        }\n                        streamActive.resolve(/* active= */ true);\n                    }\n                    else {\n                        logger_1.logger('Query._stream', tag, 'Query failed with stream error:', err);\n                        stream.destroy(err);\n                        streamActive.resolve(/* active= */ false);\n                    }\n                });\n                backendStream.on('end', () => {\n                    streamActive.resolve(/* active= */ false);\n                });\n                backendStream.resume();\n                backendStream.pipe(stream);\n            } while (await streamActive.promise);\n        })\n            .catch(e => stream.destroy(e));\n        return stream;\n    }\n    /**\n     * Attaches a listener for QuerySnapshot events.\n     *\n     * @param {querySnapshotCallback} onNext A callback to be called every time\n     * a new [QuerySnapshot]{@link QuerySnapshot} is available.\n     * @param {errorCallback=} onError A callback to be called if the listen\n     * fails or is cancelled. No further callbacks will occur.\n     *\n     * @returns {function()} An unsubscribe function that can be called to cancel\n     * the snapshot listener.\n     *\n     * @example\n     * let query = firestore.collection('col').where('foo', '==', 'bar');\n     *\n     * let unsubscribe = query.onSnapshot(querySnapshot => {\n     *   console.log(`Received query snapshot of size ${querySnapshot.size}`);\n     * }, err => {\n     *   console.log(`Encountered error: ${err}`);\n     * });\n     *\n     * // Remove this listener.\n     * unsubscribe();\n     */\n    onSnapshot(onNext, onError) {\n        validate_1.validateFunction('onNext', onNext);\n        validate_1.validateFunction('onError', onError, { optional: true });\n        const watch = new watch_1.QueryWatch(this.firestore, this, this._queryOptions.converter);\n        return watch.onSnapshot((readTime, size, docs, changes) => {\n            onNext(new QuerySnapshot(this, readTime, size, docs, changes));\n        }, onError || console.error);\n    }\n    /**\n     * Returns a function that can be used to sort QueryDocumentSnapshots\n     * according to the sort criteria of this query.\n     *\n     * @private\n     */\n    comparator() {\n        return (doc1, doc2) => {\n            // Add implicit sorting by name, using the last specified direction.\n            const lastDirection = this._queryOptions.hasFieldOrders()\n                ? this._queryOptions.fieldOrders[this._queryOptions.fieldOrders.length - 1].direction\n                : 'ASCENDING';\n            const orderBys = this._queryOptions.fieldOrders.concat(new FieldOrder(path_1.FieldPath.documentId(), lastDirection));\n            for (const orderBy of orderBys) {\n                let comp;\n                if (path_1.FieldPath.documentId().isEqual(orderBy.field)) {\n                    comp = doc1.ref._path.compareTo(doc2.ref._path);\n                }\n                else {\n                    const v1 = doc1.protoField(orderBy.field);\n                    const v2 = doc2.protoField(orderBy.field);\n                    if (v1 === undefined || v2 === undefined) {\n                        throw new Error('Trying to compare documents on fields that ' +\n                            \"don't exist. Please include the fields you are ordering on \" +\n                            'in your select() call.');\n                    }\n                    comp = order_1.compare(v1, v2);\n                }\n                if (comp !== 0) {\n                    const direction = orderBy.direction === 'ASCENDING' ? 1 : -1;\n                    return direction * comp;\n                }\n            }\n            return 0;\n        };\n    }\n    withConverter(converter) {\n        return new Query(this.firestore, this._queryOptions.withConverter(converter !== null && converter !== void 0 ? converter : types_1.defaultConverter()));\n    }\n}\nexports.Query = Query;\n/**\n * A CollectionReference object can be used for adding documents, getting\n * document references, and querying for documents (using the methods\n * inherited from [Query]{@link Query}).\n *\n * @class CollectionReference\n * @extends Query\n */\nclass CollectionReference extends Query {\n    /**\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     * @param path The Path of this collection.\n     */\n    constructor(firestore, path, converter) {\n        super(firestore, QueryOptions.forCollectionQuery(path, converter));\n    }\n    /**\n     * Returns a resource path for this collection.\n     * @private\n     */\n    get _resourcePath() {\n        return this._queryOptions.parentPath.append(this._queryOptions.collectionId);\n    }\n    /**\n     * The last path element of the referenced collection.\n     *\n     * @type {string}\n     * @name CollectionReference#id\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`ID of the subcollection: ${collectionRef.id}`);\n     */\n    get id() {\n        return this._queryOptions.collectionId;\n    }\n    /**\n     * A reference to the containing Document if this is a subcollection, else\n     * null.\n     *\n     * @type {DocumentReference|null}\n     * @name CollectionReference#parent\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * let documentRef = collectionRef.parent;\n     * console.log(`Parent name: ${documentRef.path}`);\n     */\n    get parent() {\n        if (this._queryOptions.parentPath.isDocument) {\n            return new DocumentReference(this.firestore, this._queryOptions.parentPath);\n        }\n        return null;\n    }\n    /**\n     * A string representing the path of the referenced collection (relative\n     * to the root of the database).\n     *\n     * @type {string}\n     * @name CollectionReference#path\n     * @readonly\n     *\n     * @example\n     * let collectionRef = firestore.collection('col/doc/subcollection');\n     * console.log(`Path of the subcollection: ${collectionRef.path}`);\n     */\n    get path() {\n        return this._resourcePath.relativeName;\n    }\n    /**\n     * Retrieves the list of documents in this collection.\n     *\n     * The document references returned may include references to \"missing\n     * documents\", i.e. document locations that have no document present but\n     * which contain subcollections with documents. Attempting to read such a\n     * document reference (e.g. via `.get()` or `.onSnapshot()`) will return a\n     * `DocumentSnapshot` whose `.exists` property is false.\n     *\n     * @return {Promise<DocumentReference[]>} The list of documents in this\n     * collection.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     *\n     * return collectionRef.listDocuments().then(documentRefs => {\n     *    return firestore.getAll(...documentRefs);\n     * }).then(documentSnapshots => {\n     *    for (let documentSnapshot of documentSnapshots) {\n     *       if (documentSnapshot.exists) {\n     *         console.log(`Found document with data: ${documentSnapshot.id}`);\n     *       } else {\n     *         console.log(`Found missing document: ${documentSnapshot.id}`);\n     *       }\n     *    }\n     * });\n     */\n    listDocuments() {\n        const tag = util_1.requestTag();\n        return this.firestore.initializeIfNeeded(tag).then(() => {\n            const parentPath = this._queryOptions.parentPath.toQualifiedResourcePath(this.firestore.projectId);\n            const request = {\n                parent: parentPath.formattedName,\n                collectionId: this.id,\n                showMissing: true,\n                // Setting `pageSize` to an arbitrarily large value lets the backend cap\n                // the page size (currently to 300). Note that the backend rejects\n                // MAX_INT32 (b/146883794).\n                pageSize: Math.pow(2, 16) - 1,\n                mask: { fieldPaths: [] },\n            };\n            return this.firestore\n                .request('listDocuments', request, tag)\n                .then(documents => {\n                // Note that the backend already orders these documents by name,\n                // so we do not need to manually sort them.\n                return documents.map(doc => {\n                    const path = path_1.QualifiedResourcePath.fromSlashSeparatedString(doc.name);\n                    return this.doc(path.id);\n                });\n            });\n        });\n    }\n    /**\n     * Gets a [DocumentReference]{@link DocumentReference} instance that\n     * refers to the document at the specified path. If no path is specified, an\n     * automatically-generated unique ID will be used for the returned\n     * DocumentReference.\n     *\n     * @param {string=} documentPath A slash-separated path to a document.\n     * @returns {DocumentReference} The `DocumentReference`\n     * instance.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * let documentRefWithName = collectionRef.doc('doc');\n     * let documentRefWithAutoId = collectionRef.doc();\n     * console.log(`Reference with name: ${documentRefWithName.path}`);\n     * console.log(`Reference with auto-id: ${documentRefWithAutoId.path}`);\n     */\n    doc(documentPath) {\n        if (arguments.length === 0) {\n            documentPath = util_1.autoId();\n        }\n        else {\n            path_1.validateResourcePath('documentPath', documentPath);\n        }\n        const path = this._resourcePath.append(documentPath);\n        if (!path.isDocument) {\n            throw new Error(`Value for argument \"documentPath\" must point to a document, but was \"${documentPath}\". Your path does not contain an even number of components.`);\n        }\n        return new DocumentReference(this.firestore, path, this._queryOptions.converter);\n    }\n    /**\n     * Add a new document to this collection with the specified data, assigning\n     * it a document ID automatically.\n     *\n     * @param {DocumentData} data An Object containing the data for the new\n     * document.\n     * @returns {Promise.<DocumentReference>} A Promise resolved with a\n     * [DocumentReference]{@link DocumentReference} pointing to the\n     * newly created document.\n     *\n     * @example\n     * let collectionRef = firestore.collection('col');\n     * collectionRef.add({foo: 'bar'}).then(documentReference => {\n     *   console.log(`Added document with name: ${documentReference.id}`);\n     * });\n     */\n    add(data) {\n        const firestoreData = this._queryOptions.converter.toFirestore(data);\n        write_batch_1.validateDocumentData('data', firestoreData, \n        /*allowDeletes=*/ false, this._allowUndefined);\n        const documentRef = this.doc();\n        return documentRef.create(data).then(() => documentRef);\n    }\n    /**\n     * Returns true if this `CollectionReference` is equal to the provided value.\n     *\n     * @param {*} other The value to compare against.\n     * @return {boolean} true if this `CollectionReference` is equal to the\n     * provided value.\n     */\n    isEqual(other) {\n        return (this === other ||\n            (other instanceof CollectionReference && super.isEqual(other)));\n    }\n    withConverter(converter) {\n        return new CollectionReference(this.firestore, this._resourcePath, converter !== null && converter !== void 0 ? converter : types_1.defaultConverter());\n    }\n}\nexports.CollectionReference = CollectionReference;\n/**\n * Validates the input string as a field order direction.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Order direction to validate.\n * @throws when the direction is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOrder(arg, op) {\n    // For backwards compatibility, we support both lower and uppercase values.\n    op = typeof op === 'string' ? op.toLowerCase() : op;\n    validate_1.validateEnumValue(arg, op, Object.keys(directionOperators), { optional: true });\n    return op;\n}\nexports.validateQueryOrder = validateQueryOrder;\n/**\n * Validates the input string as a field comparison operator.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param op Field comparison operator to validate.\n * @param fieldValue Value that is used in the filter.\n * @throws when the comparison operation is invalid\n * @return a validated input value, which may be different from the provided\n * value.\n */\nfunction validateQueryOperator(arg, op, fieldValue) {\n    // For backwards compatibility, we support both `=` and `==` for \"equals\".\n    if (op === '=') {\n        op = '==';\n    }\n    validate_1.validateEnumValue(arg, op, Object.keys(comparisonOperators));\n    if (typeof fieldValue === 'number' &&\n        isNaN(fieldValue) &&\n        op !== '==' &&\n        op !== '!=') {\n        throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on NaN.\");\n    }\n    if (fieldValue === null && op !== '==' && op !== '!=') {\n        throw new Error(\"Invalid query. You can only perform '==' and '!=' comparisons on Null.\");\n    }\n    return op;\n}\nexports.validateQueryOperator = validateQueryOperator;\n/**\n * Validates that 'value' is a DocumentReference.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @return the DocumentReference if valid\n */\nfunction validateDocumentReference(arg, value) {\n    if (!(value instanceof DocumentReference)) {\n        throw new Error(validate_1.invalidArgumentMessage(arg, 'DocumentReference'));\n    }\n    return value;\n}\nexports.validateDocumentReference = validateDocumentReference;\n/**\n * Validates that 'value' can be used as a query value.\n *\n * @private\n * @param arg The argument name or argument index (for varargs methods).\n * @param value The argument to validate.\n * @param allowUndefined Whether to allow nested properties that are `undefined`.\n */\nfunction validateQueryValue(arg, value, allowUndefined) {\n    serializer_1.validateUserInput(arg, value, 'query constraint', {\n        allowDeletes: 'none',\n        allowTransforms: false,\n        allowUndefined,\n    });\n}\n/**\n * Verifies equality for an array of objects using the `isEqual` interface.\n *\n * @private\n * @param left Array of objects supporting `isEqual`.\n * @param right Array of objects supporting `isEqual`.\n * @return True if arrays are equal.\n */\nfunction isArrayEqual(left, right) {\n    if (left.length !== right.length) {\n        return false;\n    }\n    for (let i = 0; i < left.length; ++i) {\n        if (!left[i].isEqual(right[i])) {\n            return false;\n        }\n    }\n    return true;\n}\n/**\n * Returns the first non-undefined value or `undefined` if no such value exists.\n * @private\n */\nfunction coalesce(...values) {\n    return values.find(value => value !== undefined);\n}\n//# sourceMappingURL=reference.js.map"]},"metadata":{},"sourceType":"script"}