{"ast":null,"code":"\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PathTemplate = void 0;\n\nvar PathTemplate = /*#__PURE__*/function () {\n  /**\n   * @param {String} data the of the template\n   *\n   * @constructor\n   */\n  function PathTemplate(data) {\n    _classCallCheck(this, PathTemplate);\n\n    this.bindings = {};\n    this.data = data;\n    this.segments = this.parsePathTemplate(data);\n    this.size = this.segments.length;\n  }\n  /**\n   * Matches a fully-qualified path template string.\n   *\n   * @param {String} path a fully-qualified path template string\n   * @return {Object} contains const names matched to binding values\n   * @throws {TypeError} if path can't be matched to this template\n   */\n\n\n  _createClass(PathTemplate, [{\n    key: \"match\",\n    value: function match(path) {\n      var pathSegments = path.split('/');\n      var bindings = {};\n\n      if (pathSegments.length !== this.segments.length) {\n        // if the path contains a wildcard, then the length may differ by 1.\n        if (!this.data.includes('**')) {\n          throw new TypeError(\"This path \".concat(path, \" does not match path template \").concat(this.data, \", the number of parameters is not same.\"));\n        } else if (pathSegments.length !== this.segments.length + 1) {\n          throw new TypeError(\"This path \".concat(path, \" does not match path template \").concat(this.data, \", the number of parameters is not same with one wildcard.\"));\n        }\n      }\n\n      for (var index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n        if (this.segments[index] !== pathSegments[0]) {\n          if (!this.segments[index].includes('*')) {\n            throw new TypeError(\"segment does not match, \".concat(this.segments[index], \" and  \").concat(pathSegments[index], \".\"));\n          } else {\n            var segment = this.segments[index];\n            var variable = segment.match(/(?<={)[$0-9a-zA-Z_]+(?==.*})/g) || [];\n\n            if (segment.includes('**')) {\n              bindings[variable[0]] = pathSegments[0] + '/' + pathSegments[1];\n              pathSegments = pathSegments.slice(2);\n            } else {\n              // atomic resource\n              if (variable.length === 1) {\n                bindings[variable[0]] = pathSegments[0];\n              } else {\n                // non-slash resource\n                // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n                // split the match pathSegments[0] -> value: ['bar', 'user2']\n                // compare the length of two arrays, and compare array items\n                var value = pathSegments[0].split(/[-_.~]/);\n\n                if (value.length !== variable.length) {\n                  throw new Error(\"segment \".concat(segment, \" does not match \").concat(pathSegments[0]));\n                }\n\n                var _iterator = _createForOfIteratorHelper(variable),\n                    _step;\n\n                try {\n                  for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                    var v = _step.value;\n                    bindings[v] = value[0];\n                    segment = segment.replace(\"{\".concat(v, \"=*}\"), \"\".concat(value[0]));\n                    value.shift();\n                  } // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n\n                } catch (err) {\n                  _iterator.e(err);\n                } finally {\n                  _iterator.f();\n                }\n\n                if (segment !== pathSegments[0]) {\n                  throw new TypeError(\"non slash resource pattern \".concat(this.segments[index], \" and \").concat(pathSegments[0], \" should have same separator\"));\n                }\n              }\n\n              pathSegments.shift();\n            }\n          }\n        } else {\n          pathSegments.shift();\n        }\n      }\n\n      return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n\n  }, {\n    key: \"render\",\n    value: function render(bindings) {\n      if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n        throw new TypeError(\"The number of variables \".concat(Object.keys(bindings).length, \" does not match the number of needed variables \").concat(Object.keys(this.bindings).length));\n      }\n\n      var path = this.inspect();\n\n      for (var _i = 0, _Object$keys = Object.keys(bindings); _i < _Object$keys.length; _i++) {\n        var key = _Object$keys[_i];\n        var b = bindings[key].toString();\n\n        if (!this.bindings[key]) {\n          throw new TypeError(\"render fails for not matching \".concat(bindings[key]));\n        }\n\n        var variable = this.bindings[key];\n\n        if (variable === '*') {\n          if (!b.match(/[^/{}]+/)) {\n            throw new TypeError(\"render fails for not matching \".concat(b));\n          }\n\n          path = path.replace(\"{\".concat(key, \"=*}\"), \"\".concat(b));\n        } else if (variable === '**') {\n          if (!b.match(/[^{}]+/)) {\n            throw new TypeError(\"render fails for not matching \".concat(b));\n          }\n\n          path = path.replace(\"{\".concat(key, \"=**}\"), \"\".concat(b));\n        }\n      }\n\n      return path;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n\n  }, {\n    key: \"inspect\",\n    value: function inspect() {\n      return this.segments.join('/');\n    }\n    /**\n     * Parse the path template.\n     *\n     * @return {string[]} return segments of the input path.\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n     */\n\n  }, {\n    key: \"parsePathTemplate\",\n    value: function parsePathTemplate(data) {\n      var _this = this;\n\n      var pathSegments = splitPathTemplate(data);\n      var index = 0;\n      var wildCardCount = 0;\n      var segments = [];\n      pathSegments.forEach(function (segment) {\n        // * or ** -> segments.push('{$0=*}');\n        //         -> bindings['$0'] = '*'\n        if (segment === '*' || segment === '**') {\n          _this.bindings[\"$\".concat(index)] = segment;\n          segments.push(\"{$\".concat(index, \"=\").concat(segment, \"}\"));\n          index = index + 1;\n\n          if (segment === '**') {\n            wildCardCount = wildCardCount + 1;\n          }\n        } // {project}~{location} -> {project=*}~{location=*}\n        else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?:}[-._~]?{)[0-9a-zA-Z-.~_]+(?=})/)) {\n            // [project, location]\n            var variable = segment.match(/(?<=\\{).*?(?=(?:=.*?)?\\})/g) || [];\n\n            var _iterator2 = _createForOfIteratorHelper(variable),\n                _step2;\n\n            try {\n              for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n                var v = _step2.value;\n                _this.bindings[v] = '*';\n                segment = segment.replace(v, v + '=*');\n              }\n            } catch (err) {\n              _iterator2.e(err);\n            } finally {\n              _iterator2.f();\n            }\n\n            segments.push(segment);\n          } // {project} / {project=*} -> segments.push('{project=*}');\n          //           -> bindings['project'] = '*'\n          else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/)) {\n              var _variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/);\n\n              _this.bindings[_variable[0]] = '*';\n              segments.push(\"{\".concat(_variable[0], \"=*}\"));\n            } // {project=**} -> segments.push('{project=**}');\n            //           -> bindings['project'] = '**'\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/)) {\n                var _variable2 = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/);\n\n                _this.bindings[_variable2[0]] = '**';\n                segments.push(\"{\".concat(_variable2[0], \"=**}\"));\n                wildCardCount = wildCardCount + 1;\n              } // {hello=/what} -> segments.push('{hello=/what}');\n              //              -> no binding in this case\n              else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+=[^*]+(?=})/)) {\n                  segments.push(segment);\n                } // helloazAZ09-.~_what -> segments.push('helloazAZ09-.~_what');\n                //              -> no binding in this case\n                else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n                    segments.push(segment);\n                  }\n\n        if (wildCardCount > 1) {\n          throw new TypeError('Can not have more than one wildcard.');\n        }\n      });\n      return segments;\n    }\n  }]);\n\n  return PathTemplate;\n}();\n\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\n\nfunction splitPathTemplate(data) {\n  var left = 0;\n  var right = 0;\n  var bracketCount = 0;\n  var segments = [];\n\n  while (right >= left && right < data.length) {\n    if (data.charAt(right) === '{') {\n      bracketCount = bracketCount + 1;\n    } else if (data.charAt(right) === '}') {\n      bracketCount = bracketCount - 1;\n    } else if (data.charAt(right) === '/') {\n      if (right === data.length - 1) {\n        throw new TypeError('Invalid path, it can not be ended by /');\n      }\n\n      if (bracketCount === 0) {\n        // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n        segments.push(data.substring(left, right));\n        left = right + 1;\n      }\n    }\n\n    if (right === data.length - 1) {\n      if (bracketCount !== 0) {\n        throw new TypeError('Brackets are invalid.');\n      }\n\n      segments.push(data.substring(left));\n    }\n\n    right = right + 1;\n  }\n\n  return segments;\n}","map":{"version":3,"sources":["../../src/pathTemplate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/**\n * Copyright 2020 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PathTemplate = void 0;\nclass PathTemplate {\n    /**\n     * @param {String} data the of the template\n     *\n     * @constructor\n     */\n    constructor(data) {\n        this.bindings = {};\n        this.data = data;\n        this.segments = this.parsePathTemplate(data);\n        this.size = this.segments.length;\n    }\n    /**\n     * Matches a fully-qualified path template string.\n     *\n     * @param {String} path a fully-qualified path template string\n     * @return {Object} contains const names matched to binding values\n     * @throws {TypeError} if path can't be matched to this template\n     */\n    match(path) {\n        let pathSegments = path.split('/');\n        const bindings = {};\n        if (pathSegments.length !== this.segments.length) {\n            // if the path contains a wildcard, then the length may differ by 1.\n            if (!this.data.includes('**')) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same.`);\n            }\n            else if (pathSegments.length !== this.segments.length + 1) {\n                throw new TypeError(`This path ${path} does not match path template ${this.data}, the number of parameters is not same with one wildcard.`);\n            }\n        }\n        for (let index = 0; index < this.segments.length && pathSegments.length > 0; index++) {\n            if (this.segments[index] !== pathSegments[0]) {\n                if (!this.segments[index].includes('*')) {\n                    throw new TypeError(`segment does not match, ${this.segments[index]} and  ${pathSegments[index]}.`);\n                }\n                else {\n                    let segment = this.segments[index];\n                    const variable = segment.match(/(?<={)[$0-9a-zA-Z_]+(?==.*})/g) || [];\n                    if (segment.includes('**')) {\n                        bindings[variable[0]] = pathSegments[0] + '/' + pathSegments[1];\n                        pathSegments = pathSegments.slice(2);\n                    }\n                    else {\n                        // atomic resource\n                        if (variable.length === 1) {\n                            bindings[variable[0]] = pathSegments[0];\n                        }\n                        else {\n                            // non-slash resource\n                            // segment: {blurb_id=*}.{legacy_user=*} to match pathSegments: ['bar.user2']\n                            // split the match pathSegments[0] -> value: ['bar', 'user2']\n                            // compare the length of two arrays, and compare array items\n                            const value = pathSegments[0].split(/[-_.~]/);\n                            if (value.length !== variable.length) {\n                                throw new Error(`segment ${segment} does not match ${pathSegments[0]}`);\n                            }\n                            for (const v of variable) {\n                                bindings[v] = value[0];\n                                segment = segment.replace(`{${v}=*}`, `${value[0]}`);\n                                value.shift();\n                            }\n                            // segment: {blurb_id=*}.{legacy_user=*} matching pathSegments: ['bar~user2'] should fail\n                            if (segment !== pathSegments[0]) {\n                                throw new TypeError(`non slash resource pattern ${this.segments[index]} and ${pathSegments[0]} should have same separator`);\n                            }\n                        }\n                        pathSegments.shift();\n                    }\n                }\n            }\n            else {\n                pathSegments.shift();\n            }\n        }\n        return bindings;\n    }\n    /**\n     * Renders a path template using the provided bindings.\n     *\n     * @param {Object} bindings a mapping of const names to binding strings\n     * @return {String} a rendered representation of the path template\n     * @throws {TypeError} if a key is missing, or if a sub-template cannot be\n     *   parsed\n     */\n    render(bindings) {\n        if (Object.keys(bindings).length !== Object.keys(this.bindings).length) {\n            throw new TypeError(`The number of variables ${Object.keys(bindings).length} does not match the number of needed variables ${Object.keys(this.bindings).length}`);\n        }\n        let path = this.inspect();\n        for (const key of Object.keys(bindings)) {\n            const b = bindings[key].toString();\n            if (!this.bindings[key]) {\n                throw new TypeError(`render fails for not matching ${bindings[key]}`);\n            }\n            const variable = this.bindings[key];\n            if (variable === '*') {\n                if (!b.match(/[^/{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=*}`, `${b}`);\n            }\n            else if (variable === '**') {\n                if (!b.match(/[^{}]+/)) {\n                    throw new TypeError(`render fails for not matching ${b}`);\n                }\n                path = path.replace(`{${key}=**}`, `${b}`);\n            }\n        }\n        return path;\n    }\n    /**\n     * Renders the path template.\n     *\n     * @return {string} contains const names matched to binding values\n     */\n    inspect() {\n        return this.segments.join('/');\n    }\n    /**\n     * Parse the path template.\n     *\n     * @return {string[]} return segments of the input path.\n     * For example: 'buckets/{hello}'' will give back ['buckets', {hello=*}]\n     */\n    parsePathTemplate(data) {\n        const pathSegments = splitPathTemplate(data);\n        let index = 0;\n        let wildCardCount = 0;\n        const segments = [];\n        pathSegments.forEach(segment => {\n            // * or ** -> segments.push('{$0=*}');\n            //         -> bindings['$0'] = '*'\n            if (segment === '*' || segment === '**') {\n                this.bindings[`$${index}`] = segment;\n                segments.push(`{$${index}=${segment}}`);\n                index = index + 1;\n                if (segment === '**') {\n                    wildCardCount = wildCardCount + 1;\n                }\n            }\n            // {project}~{location} -> {project=*}~{location=*}\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?:}[-._~]?{)[0-9a-zA-Z-.~_]+(?=})/)) {\n                // [project, location]\n                const variable = segment.match(/(?<=\\{).*?(?=(?:=.*?)?\\})/g) || [];\n                for (const v of variable) {\n                    this.bindings[v] = '*';\n                    segment = segment.replace(v, v + '=*');\n                }\n                segments.push(segment);\n            }\n            // {project} / {project=*} -> segments.push('{project=*}');\n            //           -> bindings['project'] = '*'\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/)) {\n                const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*)?})/);\n                this.bindings[variable[0]] = '*';\n                segments.push(`{${variable[0]}=*}`);\n            }\n            // {project=**} -> segments.push('{project=**}');\n            //           -> bindings['project'] = '**'\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/)) {\n                const variable = segment.match(/(?<={)[0-9a-zA-Z-.~_]+(?=(=\\*\\*)})/);\n                this.bindings[variable[0]] = '**';\n                segments.push(`{${variable[0]}=**}`);\n                wildCardCount = wildCardCount + 1;\n            }\n            // {hello=/what} -> segments.push('{hello=/what}');\n            //              -> no binding in this case\n            else if (segment.match(/(?<={)[0-9a-zA-Z-.~_]+=[^*]+(?=})/)) {\n                segments.push(segment);\n            }\n            // helloazAZ09-.~_what -> segments.push('helloazAZ09-.~_what');\n            //              -> no binding in this case\n            else if (segment.match(/[0-9a-zA-Z-.~_]+/)) {\n                segments.push(segment);\n            }\n            if (wildCardCount > 1) {\n                throw new TypeError('Can not have more than one wildcard.');\n            }\n        });\n        return segments;\n    }\n}\nexports.PathTemplate = PathTemplate;\n/**\n * Split the path template by `/`.\n * It can not be simply splitted by `/` because there might be `/` in the segments.\n * For example: 'a/b/{a=hello/world}' we do not want to break the brackets pair\n * so above path will be splitted as ['a', 'b', '{a=hello/world}']\n */\nfunction splitPathTemplate(data) {\n    let left = 0;\n    let right = 0;\n    let bracketCount = 0;\n    const segments = [];\n    while (right >= left && right < data.length) {\n        if (data.charAt(right) === '{') {\n            bracketCount = bracketCount + 1;\n        }\n        else if (data.charAt(right) === '}') {\n            bracketCount = bracketCount - 1;\n        }\n        else if (data.charAt(right) === '/') {\n            if (right === data.length - 1) {\n                throw new TypeError('Invalid path, it can not be ended by /');\n            }\n            if (bracketCount === 0) {\n                // complete bracket, to avoid the case a/b/**/*/{a=hello/world}\n                segments.push(data.substring(left, right));\n                left = right + 1;\n            }\n        }\n        if (right === data.length - 1) {\n            if (bracketCount !== 0) {\n                throw new TypeError('Brackets are invalid.');\n            }\n            segments.push(data.substring(left));\n        }\n        right = right + 1;\n    }\n    return segments;\n}\n//# sourceMappingURL=pathTemplate.js.map"]},"metadata":{},"sourceType":"script"}