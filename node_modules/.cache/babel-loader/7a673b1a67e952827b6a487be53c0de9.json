{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nvar _inherits = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _createForOfIteratorHelper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createForOfIteratorHelper\");\n\nvar _regeneratorRuntime = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar assert = require(\"assert\");\n\nvar rbtree = require(\"functional-red-black-tree\");\n\nvar google_gax_1 = require(\"google-gax\");\n\nvar backoff_1 = require(\"./backoff\");\n\nvar document_1 = require(\"./document\");\n\nvar document_change_1 = require(\"./document-change\");\n\nvar logger_1 = require(\"./logger\");\n\nvar path_1 = require(\"./path\");\n\nvar timestamp_1 = require(\"./timestamp\");\n\nvar types_1 = require(\"./types\");\n\nvar util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\n\n\nvar WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\n\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\n\nvar REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\n\nvar ChangeType = {\n  added: 'added',\n  modified: 'modified',\n  removed: 'removed'\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\n\nvar DOCUMENT_WATCH_COMPARATOR = function DOCUMENT_WATCH_COMPARATOR(doc1, doc2) {\n  assert(doc1 === doc2, 'Document watches only support one document.');\n  return 0;\n};\n\nvar EMPTY_FUNCTION = function EMPTY_FUNCTION() {};\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\n\n\nvar Watch = /*#__PURE__*/function () {\n  /**\n   * @private\n   * @hideconstructor\n   *\n   * @param firestore The Firestore Database client.\n   */\n  function Watch(firestore) {\n    var _converter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : types_1.defaultConverter();\n\n    _classCallCheck(this, Watch);\n\n    this._converter = _converter;\n    /**\n     * Indicates whether we are interested in data from the stream. Set to false in the\n     * 'unsubscribe()' callback.\n     * @private\n     */\n\n    this.isActive = true;\n    /**\n     * The current stream to the backend.\n     * @private\n     */\n\n    this.currentStream = null;\n    /**\n     * The server assigns and updates the resume token.\n     * @private\n     */\n\n    this.resumeToken = undefined;\n    /**\n     * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n     * @private\n     */\n\n    this.docMap = new Map();\n    /**\n     * The accumulated map of document changes (keyed by document name) for the\n     * current snapshot.\n     * @private\n     */\n\n    this.changeMap = new Map();\n    /**\n     * The current state of the query results. *\n     * @private\n     */\n\n    this.current = false;\n    /**\n     * We need this to track whether we've pushed an initial set of changes,\n     * since we should push those even when there are no changes, if there\n     * aren't docs.\n     * @private\n     */\n\n    this.hasPushed = false;\n    this.firestore = firestore;\n    this.backoff = new backoff_1.ExponentialBackoff();\n    this.requestTag = util_1.requestTag();\n    this.onNext = EMPTY_FUNCTION;\n    this.onError = EMPTY_FUNCTION;\n  }\n  /**\n   * Starts a watch and attaches a listener for document change events.\n   *\n   * @private\n   * @param onNext A callback to be called every time a new snapshot is\n   * available.\n   * @param onError A callback to be called if the listen fails or is cancelled.\n   * No further callbacks will occur.\n   *\n   * @returns An unsubscribe function that can be called to cancel the snapshot\n   * listener.\n   */\n\n\n  _createClass(Watch, [{\n    key: \"onSnapshot\",\n    value: function onSnapshot(onNext, onError) {\n      var _this = this;\n\n      assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n      assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n      assert(this.docTree === undefined, 'docTree should not already be defined.');\n      this.onNext = onNext;\n      this.onError = onError;\n      this.docTree = rbtree(this.getComparator());\n      this.initStream();\n\n      var unsubscribe = function unsubscribe() {\n        logger_1.logger('Watch.onSnapshot', _this.requestTag, 'Unsubscribe called'); // Prevent further callbacks.\n\n        _this.onNext = function () {};\n\n        _this.onError = function () {};\n\n        _this.shutdown();\n      };\n\n      this.firestore.registerListener();\n      return unsubscribe;\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     */\n\n  }, {\n    key: \"currentSize\",\n    value: function currentSize() {\n      var changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n      return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     */\n\n  }, {\n    key: \"extractCurrentChanges\",\n    value: function extractCurrentChanges(readTime) {\n      var _this2 = this;\n\n      var deletes = [];\n      var adds = [];\n      var updates = [];\n      this.changeMap.forEach(function (value, name) {\n        if (value === REMOVED) {\n          if (_this2.docMap.has(name)) {\n            deletes.push(name);\n          }\n        } else if (_this2.docMap.has(name)) {\n          value.readTime = readTime;\n          updates.push(value.build());\n        } else {\n          value.readTime = readTime;\n          adds.push(value.build());\n        }\n      });\n      return {\n        deletes: deletes,\n        adds: adds,\n        updates: updates\n      };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     */\n\n  }, {\n    key: \"resetDocs\",\n    value: function resetDocs() {\n      var _this3 = this;\n\n      logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n      this.changeMap.clear();\n      this.resumeToken = undefined;\n      this.docTree.forEach(function (snapshot) {\n        // Mark each document as deleted. If documents are not deleted, they\n        // will be send again by the server.\n        _this3.changeMap.set(snapshot.ref.path, REMOVED);\n      });\n      this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     */\n\n  }, {\n    key: \"closeStream\",\n    value: function closeStream(err) {\n      if (this.isActive) {\n        logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n        this.onError(err);\n      }\n\n      this.shutdown();\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     */\n\n  }, {\n    key: \"maybeReopenStream\",\n    value: function maybeReopenStream(err) {\n      if (this.isActive && !this.isPermanentWatchError(err)) {\n        logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n        this.changeMap.clear();\n\n        if (this.isResourceExhaustedError(err)) {\n          this.backoff.resetToMax();\n        }\n\n        this.initStream();\n      } else {\n        this.closeStream(err);\n      }\n    }\n    /**\n     * Cancels the current idle timeout and reschedules a new timer.\n     *\n     * @private\n     */\n\n  }, {\n    key: \"resetIdleTimeout\",\n    value: function resetIdleTimeout() {\n      var _this4 = this;\n\n      if (this.idleTimeoutHandle) {\n        clearTimeout(this.idleTimeoutHandle);\n      }\n\n      this.idleTimeoutHandle = backoff_1.delayExecution(function () {\n        var _a;\n\n        logger_1.logger('Watch.resetIdleTimeout', _this4.requestTag, 'Resetting stream after idle timeout');\n        (_a = _this4.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n        _this4.currentStream = null;\n        var error = new google_gax_1.GoogleError('Watch stream idle timeout');\n        error.code = google_gax_1.Status.UNKNOWN;\n\n        _this4.maybeReopenStream(error);\n      }, exports.WATCH_IDLE_TIMEOUT_MS);\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     */\n\n  }, {\n    key: \"resetStream\",\n    value: function resetStream() {\n      logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n\n      if (this.currentStream) {\n        this.currentStream.end();\n        this.currentStream = null;\n      }\n\n      this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     */\n\n  }, {\n    key: \"initStream\",\n    value: function initStream() {\n      var _this5 = this;\n\n      this.backoff.backoffAndWait().then( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var request;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                if (_this5.isActive) {\n                  _context.next = 3;\n                  break;\n                }\n\n                logger_1.logger('Watch.initStream', _this5.requestTag, 'Not initializing inactive stream');\n                return _context.abrupt(\"return\");\n\n              case 3:\n                _context.next = 5;\n                return _this5.firestore.initializeIfNeeded(_this5.requestTag);\n\n              case 5:\n                request = {};\n                request.database = _this5.firestore.formattedName;\n                request.addTarget = _this5.getTarget(_this5.resumeToken); // Note that we need to call the internal _listen API to pass additional\n                // header values in readWriteStream.\n\n                return _context.abrupt(\"return\", _this5.firestore.requestStream('listen', request, _this5.requestTag).then(function (backendStream) {\n                  if (!_this5.isActive) {\n                    logger_1.logger('Watch.initStream', _this5.requestTag, 'Closing inactive stream');\n                    backendStream.emit('end');\n                    return;\n                  }\n\n                  logger_1.logger('Watch.initStream', _this5.requestTag, 'Opened new stream');\n                  _this5.currentStream = backendStream;\n\n                  _this5.resetIdleTimeout();\n\n                  _this5.currentStream.on('data', function (proto) {\n                    _this5.resetIdleTimeout();\n\n                    _this5.onData(proto);\n                  }).on('error', function (err) {\n                    if (_this5.currentStream === backendStream) {\n                      _this5.currentStream = null;\n\n                      _this5.maybeReopenStream(err);\n                    }\n                  }).on('end', function () {\n                    if (_this5.currentStream === backendStream) {\n                      _this5.currentStream = null;\n                      var err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n                      err.code = google_gax_1.Status.UNKNOWN;\n\n                      _this5.maybeReopenStream(err);\n                    }\n                  });\n\n                  _this5.currentStream.resume();\n                }));\n\n              case 9:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee);\n      }))).catch(function (err) {\n        _this5.closeStream(err);\n      });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     */\n\n  }, {\n    key: \"onData\",\n    value: function onData(proto) {\n      if (proto.targetChange) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n        var change = proto.targetChange;\n        var noTargetIds = !change.targetIds || change.targetIds.length === 0;\n\n        if (change.targetChangeType === 'NO_CHANGE') {\n          if (noTargetIds && change.readTime && this.current) {\n            // This means everything is up-to-date, so emit the current\n            // set of docs as a snapshot, if there were changes.\n            this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n          }\n        } else if (change.targetChangeType === 'ADD') {\n          if (WATCH_TARGET_ID !== change.targetIds[0]) {\n            this.closeStream(Error('Unexpected target ID sent by server'));\n          }\n        } else if (change.targetChangeType === 'REMOVE') {\n          var code = google_gax_1.Status.INTERNAL;\n          var message = 'internal error';\n\n          if (change.cause) {\n            code = change.cause.code;\n            message = change.cause.message;\n          } // @todo: Surface a .code property on the exception.\n\n\n          this.closeStream(new Error('Error ' + code + ': ' + message));\n        } else if (change.targetChangeType === 'RESET') {\n          // Whatever changes have happened so far no longer matter.\n          this.resetDocs();\n        } else if (change.targetChangeType === 'CURRENT') {\n          this.current = true;\n        } else {\n          this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n        }\n\n        if (change.resumeToken && this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n          this.backoff.reset();\n        }\n      } else if (proto.documentChange) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing change event'); // No other targetIds can show up here, but we still need to see\n        // if the targetId was in the added list or removed list.\n\n        var targetIds = proto.documentChange.targetIds || [];\n        var removedTargetIds = proto.documentChange.removedTargetIds || [];\n        var changed = false;\n        var removed = false;\n\n        for (var i = 0; i < targetIds.length; i++) {\n          if (targetIds[i] === WATCH_TARGET_ID) {\n            changed = true;\n          }\n        }\n\n        for (var _i = 0; _i < removedTargetIds.length; _i++) {\n          if (removedTargetIds[_i] === WATCH_TARGET_ID) {\n            removed = true;\n          }\n        }\n\n        var document = proto.documentChange.document;\n        var name = document.name;\n        var relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name).relativeName;\n\n        if (changed) {\n          logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n          var ref = this.firestore.doc(relativeName);\n          var snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n          snapshot.fieldsProto = document.fields || {};\n          snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n          snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n          this.changeMap.set(relativeName, snapshot);\n        } else if (removed) {\n          logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n          this.changeMap.set(relativeName, REMOVED);\n        }\n      } else if (proto.documentDelete || proto.documentRemove) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n        var _name = (proto.documentDelete || proto.documentRemove).document;\n        var _relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(_name).relativeName;\n        this.changeMap.set(_relativeName, REMOVED);\n      } else if (proto.filter) {\n        logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n\n        if (proto.filter.count !== this.currentSize()) {\n          // We need to remove all the current results.\n          this.resetDocs(); // The filter didn't match, so re-issue the query.\n\n          this.resetStream();\n        }\n      } else {\n        this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n      }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     */\n\n  }, {\n    key: \"affectsTarget\",\n    value: function affectsTarget(targetIds, currentId) {\n      if (targetIds === undefined || targetIds.length === 0) {\n        return true;\n      }\n\n      var _iterator = _createForOfIteratorHelper(targetIds),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var targetId = _step.value;\n\n          if (targetId === currentId) {\n            return true;\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n\n      return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     */\n\n  }, {\n    key: \"pushSnapshot\",\n    value: function pushSnapshot(readTime, nextResumeToken) {\n      var appliedChanges = this.computeSnapshot(readTime);\n\n      if (!this.hasPushed || appliedChanges.length > 0) {\n        logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length); // We pass the current set of changes, even if `docTree` is modified later.\n\n        var currentTree = this.docTree;\n        this.onNext(readTime, currentTree.length, function () {\n          return currentTree.keys;\n        }, function () {\n          return appliedChanges;\n        });\n        this.hasPushed = true;\n      }\n\n      this.changeMap.clear();\n      this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     */\n\n  }, {\n    key: \"deleteDoc\",\n    value: function deleteDoc(name) {\n      assert(this.docMap.has(name), 'Document to delete does not exist');\n      var oldDocument = this.docMap.get(name);\n      var existing = this.docTree.find(oldDocument);\n      var oldIndex = existing.index;\n      this.docTree = existing.remove();\n      this.docMap.delete(name);\n      return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     */\n\n  }, {\n    key: \"addDoc\",\n    value: function addDoc(newDocument) {\n      var name = newDocument.ref.path;\n      assert(!this.docMap.has(name), 'Document to add already exists');\n      this.docTree = this.docTree.insert(newDocument, null);\n      var newIndex = this.docTree.find(newDocument).index;\n      this.docMap.set(name, newDocument);\n      return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     */\n\n  }, {\n    key: \"modifyDoc\",\n    value: function modifyDoc(newDocument) {\n      var name = newDocument.ref.path;\n      assert(this.docMap.has(name), 'Document to modify does not exist');\n      var oldDocument = this.docMap.get(name);\n\n      if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n        var removeChange = this.deleteDoc(name);\n        var addChange = this.addDoc(newDocument);\n        return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n      }\n\n      return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     */\n\n  }, {\n    key: \"computeSnapshot\",\n    value: function computeSnapshot(readTime) {\n      var _this6 = this;\n\n      var changeSet = this.extractCurrentChanges(readTime);\n      var appliedChanges = []; // Process the sorted changes in the order that is expected by our clients\n      // (removals, additions, and then modifications). We also need to sort the\n      // individual changes to assure that oldIndex/newIndex keep incrementing.\n\n      changeSet.deletes.sort(function (name1, name2) {\n        // Deletes are sorted based on the order of the existing document.\n        return _this6.getComparator()(_this6.docMap.get(name1), _this6.docMap.get(name2));\n      });\n      changeSet.deletes.forEach(function (name) {\n        var change = _this6.deleteDoc(name);\n\n        appliedChanges.push(change);\n      });\n      changeSet.adds.sort(this.getComparator());\n      changeSet.adds.forEach(function (snapshot) {\n        var change = _this6.addDoc(snapshot);\n\n        appliedChanges.push(change);\n      });\n      changeSet.updates.sort(this.getComparator());\n      changeSet.updates.forEach(function (snapshot) {\n        var change = _this6.modifyDoc(snapshot);\n\n        if (change) {\n          appliedChanges.push(change);\n        }\n      });\n      assert(this.docTree.length === this.docMap.size, 'The update document ' + 'tree and document map should have the same number of entries.');\n      return appliedChanges;\n    }\n    /**\n     * Determines whether a watch error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n\n  }, {\n    key: \"isPermanentWatchError\",\n    value: function isPermanentWatchError(error) {\n      if (error.code === undefined) {\n        logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n        return false;\n      }\n\n      switch (error.code) {\n        case google_gax_1.Status.ABORTED:\n        case google_gax_1.Status.CANCELLED:\n        case google_gax_1.Status.UNKNOWN:\n        case google_gax_1.Status.DEADLINE_EXCEEDED:\n        case google_gax_1.Status.RESOURCE_EXHAUSTED:\n        case google_gax_1.Status.INTERNAL:\n        case google_gax_1.Status.UNAVAILABLE:\n        case google_gax_1.Status.UNAUTHENTICATED:\n          return false;\n\n        default:\n          return true;\n      }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n\n  }, {\n    key: \"isResourceExhaustedError\",\n    value: function isResourceExhaustedError(error) {\n      return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n    }\n    /** Closes the stream and clears all timeouts. */\n\n  }, {\n    key: \"shutdown\",\n    value: function shutdown() {\n      var _a;\n\n      if (this.isActive) {\n        this.isActive = false;\n\n        if (this.idleTimeoutHandle) {\n          clearTimeout(this.idleTimeoutHandle);\n          this.idleTimeoutHandle = undefined;\n        }\n\n        this.firestore.unregisterListener();\n      }\n\n      (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n      this.currentStream = null;\n    }\n  }]);\n\n  return Watch;\n}();\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\n\n\nvar DocumentWatch = /*#__PURE__*/function (_Watch) {\n  _inherits(DocumentWatch, _Watch);\n\n  var _super = _createSuper(DocumentWatch);\n\n  function DocumentWatch(firestore, ref) {\n    var _this7;\n\n    _classCallCheck(this, DocumentWatch);\n\n    _this7 = _super.call(this, firestore, ref._converter);\n    _this7.ref = ref;\n    return _this7;\n  }\n\n  _createClass(DocumentWatch, [{\n    key: \"getComparator\",\n    value: function getComparator() {\n      return DOCUMENT_WATCH_COMPARATOR;\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(resumeToken) {\n      var formattedName = this.ref.formattedName;\n      return {\n        documents: {\n          documents: [formattedName]\n        },\n        targetId: WATCH_TARGET_ID,\n        resumeToken: resumeToken\n      };\n    }\n  }]);\n\n  return DocumentWatch;\n}(Watch);\n\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\n\nvar QueryWatch = /*#__PURE__*/function (_Watch2) {\n  _inherits(QueryWatch, _Watch2);\n\n  var _super2 = _createSuper(QueryWatch);\n\n  function QueryWatch(firestore, query, converter) {\n    var _this8;\n\n    _classCallCheck(this, QueryWatch);\n\n    _this8 = _super2.call(this, firestore, converter);\n    _this8.query = query;\n    _this8.comparator = query.comparator();\n    return _this8;\n  }\n\n  _createClass(QueryWatch, [{\n    key: \"getComparator\",\n    value: function getComparator() {\n      return this.query.comparator();\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget(resumeToken) {\n      var query = this.query.toProto();\n      return {\n        query: query,\n        targetId: WATCH_TARGET_ID,\n        resumeToken: resumeToken\n      };\n    }\n  }]);\n\n  return QueryWatch;\n}(Watch);\n\nexports.QueryWatch = QueryWatch;","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/firestore/build/src/watch.js"],"names":["Object","defineProperty","exports","value","assert","require","rbtree","google_gax_1","backoff_1","document_1","document_change_1","logger_1","path_1","timestamp_1","types_1","util_1","WATCH_TARGET_ID","WATCH_IDLE_TIMEOUT_MS","REMOVED","ChangeType","added","modified","removed","DOCUMENT_WATCH_COMPARATOR","doc1","doc2","EMPTY_FUNCTION","Watch","firestore","_converter","defaultConverter","isActive","currentStream","resumeToken","undefined","docMap","Map","changeMap","current","hasPushed","backoff","ExponentialBackoff","requestTag","onNext","onError","docTree","getComparator","initStream","unsubscribe","logger","shutdown","registerListener","changes","extractCurrentChanges","Timestamp","now","size","adds","length","deletes","readTime","updates","forEach","name","has","push","build","clear","snapshot","set","ref","path","err","isPermanentWatchError","isResourceExhaustedError","resetToMax","closeStream","idleTimeoutHandle","clearTimeout","delayExecution","_a","end","error","GoogleError","code","Status","UNKNOWN","maybeReopenStream","backoffAndWait","then","initializeIfNeeded","request","database","formattedName","addTarget","getTarget","requestStream","backendStream","emit","resetIdleTimeout","on","proto","onData","resume","catch","targetChange","change","noTargetIds","targetIds","targetChangeType","pushSnapshot","fromProto","Error","INTERNAL","message","cause","resetDocs","JSON","stringify","affectsTarget","reset","documentChange","removedTargetIds","changed","i","document","relativeName","QualifiedResourcePath","fromSlashSeparatedString","doc","DocumentSnapshotBuilder","withConverter","fieldsProto","fields","createTime","updateTime","documentDelete","documentRemove","filter","count","currentSize","resetStream","currentId","targetId","nextResumeToken","appliedChanges","computeSnapshot","String","currentTree","keys","oldDocument","get","existing","find","oldIndex","index","remove","delete","DocumentChange","newDocument","insert","newIndex","isEqual","removeChange","deleteDoc","addChange","addDoc","changeSet","sort","name1","name2","modifyDoc","ABORTED","CANCELLED","DEADLINE_EXCEEDED","RESOURCE_EXHAUSTED","UNAVAILABLE","UNAUTHENTICATED","unregisterListener","DocumentWatch","documents","QueryWatch","query","converter","comparator","toProto"],"mappings":"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","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2017 Google Inc. All Rights Reserved.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nconst assert = require(\"assert\");\nconst rbtree = require(\"functional-red-black-tree\");\nconst google_gax_1 = require(\"google-gax\");\nconst backoff_1 = require(\"./backoff\");\nconst document_1 = require(\"./document\");\nconst document_change_1 = require(\"./document-change\");\nconst logger_1 = require(\"./logger\");\nconst path_1 = require(\"./path\");\nconst timestamp_1 = require(\"./timestamp\");\nconst types_1 = require(\"./types\");\nconst util_1 = require(\"./util\");\n/*!\n * Target ID used by watch. Watch uses a fixed target id since we only support\n * one target per stream.\n * @type {number}\n */\nconst WATCH_TARGET_ID = 0x1;\n/*!\n * Idle timeout used to detect Watch streams that stall (see\n * https://github.com/googleapis/nodejs-firestore/issues/1057, b/156308554).\n * Under normal load, the Watch backend will send a TARGET_CHANGE message\n * roughly every 30 seconds. As discussed with the backend team, we reset the\n * Watch stream if we do not receive any message within 120 seconds.\n */\nexports.WATCH_IDLE_TIMEOUT_MS = 120 * 1000;\n/*!\n * Sentinel value for a document remove.\n */\nconst REMOVED = {};\n/*!\n * The change type for document change events.\n */\n// tslint:disable-next-line:variable-name\nconst ChangeType = {\n    added: 'added',\n    modified: 'modified',\n    removed: 'removed',\n};\n/*!\n * The comparator used for document watches (which should always get called with\n * the same document).\n */\nconst DOCUMENT_WATCH_COMPARATOR = (doc1, doc2) => {\n    assert(doc1 === doc2, 'Document watches only support one document.');\n    return 0;\n};\nconst EMPTY_FUNCTION = () => { };\n/**\n * Watch provides listen functionality and exposes the 'onSnapshot' observer. It\n * can be used with a valid Firestore Listen target.\n *\n * @class\n * @private\n */\nclass Watch {\n    /**\n     * @private\n     * @hideconstructor\n     *\n     * @param firestore The Firestore Database client.\n     */\n    constructor(firestore, _converter = types_1.defaultConverter()) {\n        this._converter = _converter;\n        /**\n         * Indicates whether we are interested in data from the stream. Set to false in the\n         * 'unsubscribe()' callback.\n         * @private\n         */\n        this.isActive = true;\n        /**\n         * The current stream to the backend.\n         * @private\n         */\n        this.currentStream = null;\n        /**\n         * The server assigns and updates the resume token.\n         * @private\n         */\n        this.resumeToken = undefined;\n        /**\n         * A map of document names to QueryDocumentSnapshots for the last sent snapshot.\n         * @private\n         */\n        this.docMap = new Map();\n        /**\n         * The accumulated map of document changes (keyed by document name) for the\n         * current snapshot.\n         * @private\n         */\n        this.changeMap = new Map();\n        /**\n         * The current state of the query results. *\n         * @private\n         */\n        this.current = false;\n        /**\n         * We need this to track whether we've pushed an initial set of changes,\n         * since we should push those even when there are no changes, if there\n         * aren't docs.\n         * @private\n         */\n        this.hasPushed = false;\n        this.firestore = firestore;\n        this.backoff = new backoff_1.ExponentialBackoff();\n        this.requestTag = util_1.requestTag();\n        this.onNext = EMPTY_FUNCTION;\n        this.onError = EMPTY_FUNCTION;\n    }\n    /**\n     * Starts a watch and attaches a listener for document change events.\n     *\n     * @private\n     * @param onNext A callback to be called every time a new snapshot is\n     * available.\n     * @param onError A callback to be called if the listen fails or is cancelled.\n     * No further callbacks will occur.\n     *\n     * @returns An unsubscribe function that can be called to cancel the snapshot\n     * listener.\n     */\n    onSnapshot(onNext, onError) {\n        assert(this.onNext === EMPTY_FUNCTION, 'onNext should not already be defined.');\n        assert(this.onError === EMPTY_FUNCTION, 'onError should not already be defined.');\n        assert(this.docTree === undefined, 'docTree should not already be defined.');\n        this.onNext = onNext;\n        this.onError = onError;\n        this.docTree = rbtree(this.getComparator());\n        this.initStream();\n        const unsubscribe = () => {\n            logger_1.logger('Watch.onSnapshot', this.requestTag, 'Unsubscribe called');\n            // Prevent further callbacks.\n            this.onNext = () => { };\n            this.onError = () => { };\n            this.shutdown();\n        };\n        this.firestore.registerListener();\n        return unsubscribe;\n    }\n    /**\n     * Returns the current count of all documents, including the changes from\n     * the current changeMap.\n     * @private\n     */\n    currentSize() {\n        const changes = this.extractCurrentChanges(timestamp_1.Timestamp.now());\n        return this.docMap.size + changes.adds.length - changes.deletes.length;\n    }\n    /**\n     * Splits up document changes into removals, additions, and updates.\n     * @private\n     */\n    extractCurrentChanges(readTime) {\n        const deletes = [];\n        const adds = [];\n        const updates = [];\n        this.changeMap.forEach((value, name) => {\n            if (value === REMOVED) {\n                if (this.docMap.has(name)) {\n                    deletes.push(name);\n                }\n            }\n            else if (this.docMap.has(name)) {\n                value.readTime = readTime;\n                updates.push(value.build());\n            }\n            else {\n                value.readTime = readTime;\n                adds.push(value.build());\n            }\n        });\n        return { deletes, adds, updates };\n    }\n    /**\n     * Helper to clear the docs on RESET or filter mismatch.\n     * @private\n     */\n    resetDocs() {\n        logger_1.logger('Watch.resetDocs', this.requestTag, 'Resetting documents');\n        this.changeMap.clear();\n        this.resumeToken = undefined;\n        this.docTree.forEach((snapshot) => {\n            // Mark each document as deleted. If documents are not deleted, they\n            // will be send again by the server.\n            this.changeMap.set(snapshot.ref.path, REMOVED);\n        });\n        this.current = false;\n    }\n    /**\n     * Closes the stream and calls onError() if the stream is still active.\n     * @private\n     */\n    closeStream(err) {\n        if (this.isActive) {\n            logger_1.logger('Watch.closeStream', this.requestTag, 'Invoking onError: ', err);\n            this.onError(err);\n        }\n        this.shutdown();\n    }\n    /**\n     * Re-opens the stream unless the specified error is considered permanent.\n     * Clears the change map.\n     * @private\n     */\n    maybeReopenStream(err) {\n        if (this.isActive && !this.isPermanentWatchError(err)) {\n            logger_1.logger('Watch.maybeReopenStream', this.requestTag, 'Stream ended, re-opening after retryable error:', err);\n            this.changeMap.clear();\n            if (this.isResourceExhaustedError(err)) {\n                this.backoff.resetToMax();\n            }\n            this.initStream();\n        }\n        else {\n            this.closeStream(err);\n        }\n    }\n    /**\n     * Cancels the current idle timeout and reschedules a new timer.\n     *\n     * @private\n     */\n    resetIdleTimeout() {\n        if (this.idleTimeoutHandle) {\n            clearTimeout(this.idleTimeoutHandle);\n        }\n        this.idleTimeoutHandle = backoff_1.delayExecution(() => {\n            var _a;\n            logger_1.logger('Watch.resetIdleTimeout', this.requestTag, 'Resetting stream after idle timeout');\n            (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n            this.currentStream = null;\n            const error = new google_gax_1.GoogleError('Watch stream idle timeout');\n            error.code = google_gax_1.Status.UNKNOWN;\n            this.maybeReopenStream(error);\n        }, exports.WATCH_IDLE_TIMEOUT_MS);\n    }\n    /**\n     * Helper to restart the outgoing stream to the backend.\n     * @private\n     */\n    resetStream() {\n        logger_1.logger('Watch.resetStream', this.requestTag, 'Restarting stream');\n        if (this.currentStream) {\n            this.currentStream.end();\n            this.currentStream = null;\n        }\n        this.initStream();\n    }\n    /**\n     * Initializes a new stream to the backend with backoff.\n     * @private\n     */\n    initStream() {\n        this.backoff\n            .backoffAndWait()\n            .then(async () => {\n            if (!this.isActive) {\n                logger_1.logger('Watch.initStream', this.requestTag, 'Not initializing inactive stream');\n                return;\n            }\n            await this.firestore.initializeIfNeeded(this.requestTag);\n            const request = {};\n            request.database = this.firestore.formattedName;\n            request.addTarget = this.getTarget(this.resumeToken);\n            // Note that we need to call the internal _listen API to pass additional\n            // header values in readWriteStream.\n            return this.firestore\n                .requestStream('listen', request, this.requestTag)\n                .then(backendStream => {\n                if (!this.isActive) {\n                    logger_1.logger('Watch.initStream', this.requestTag, 'Closing inactive stream');\n                    backendStream.emit('end');\n                    return;\n                }\n                logger_1.logger('Watch.initStream', this.requestTag, 'Opened new stream');\n                this.currentStream = backendStream;\n                this.resetIdleTimeout();\n                this.currentStream.on('data', (proto) => {\n                    this.resetIdleTimeout();\n                    this.onData(proto);\n                })\n                    .on('error', err => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        this.maybeReopenStream(err);\n                    }\n                })\n                    .on('end', () => {\n                    if (this.currentStream === backendStream) {\n                        this.currentStream = null;\n                        const err = new google_gax_1.GoogleError('Stream ended unexpectedly');\n                        err.code = google_gax_1.Status.UNKNOWN;\n                        this.maybeReopenStream(err);\n                    }\n                });\n                this.currentStream.resume();\n            });\n        })\n            .catch(err => {\n            this.closeStream(err);\n        });\n    }\n    /**\n     * Handles 'data' events and closes the stream if the response type is\n     * invalid.\n     * @private\n     */\n    onData(proto) {\n        if (proto.targetChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing target change');\n            const change = proto.targetChange;\n            const noTargetIds = !change.targetIds || change.targetIds.length === 0;\n            if (change.targetChangeType === 'NO_CHANGE') {\n                if (noTargetIds && change.readTime && this.current) {\n                    // This means everything is up-to-date, so emit the current\n                    // set of docs as a snapshot, if there were changes.\n                    this.pushSnapshot(timestamp_1.Timestamp.fromProto(change.readTime), change.resumeToken);\n                }\n            }\n            else if (change.targetChangeType === 'ADD') {\n                if (WATCH_TARGET_ID !== change.targetIds[0]) {\n                    this.closeStream(Error('Unexpected target ID sent by server'));\n                }\n            }\n            else if (change.targetChangeType === 'REMOVE') {\n                let code = google_gax_1.Status.INTERNAL;\n                let message = 'internal error';\n                if (change.cause) {\n                    code = change.cause.code;\n                    message = change.cause.message;\n                }\n                // @todo: Surface a .code property on the exception.\n                this.closeStream(new Error('Error ' + code + ': ' + message));\n            }\n            else if (change.targetChangeType === 'RESET') {\n                // Whatever changes have happened so far no longer matter.\n                this.resetDocs();\n            }\n            else if (change.targetChangeType === 'CURRENT') {\n                this.current = true;\n            }\n            else {\n                this.closeStream(new Error('Unknown target change type: ' + JSON.stringify(change)));\n            }\n            if (change.resumeToken &&\n                this.affectsTarget(change.targetIds, WATCH_TARGET_ID)) {\n                this.backoff.reset();\n            }\n        }\n        else if (proto.documentChange) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing change event');\n            // No other targetIds can show up here, but we still need to see\n            // if the targetId was in the added list or removed list.\n            const targetIds = proto.documentChange.targetIds || [];\n            const removedTargetIds = proto.documentChange.removedTargetIds || [];\n            let changed = false;\n            let removed = false;\n            for (let i = 0; i < targetIds.length; i++) {\n                if (targetIds[i] === WATCH_TARGET_ID) {\n                    changed = true;\n                }\n            }\n            for (let i = 0; i < removedTargetIds.length; i++) {\n                if (removedTargetIds[i] === WATCH_TARGET_ID) {\n                    removed = true;\n                }\n            }\n            const document = proto.documentChange.document;\n            const name = document.name;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            if (changed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document change');\n                const ref = this.firestore.doc(relativeName);\n                const snapshot = new document_1.DocumentSnapshotBuilder(ref.withConverter(this._converter));\n                snapshot.fieldsProto = document.fields || {};\n                snapshot.createTime = timestamp_1.Timestamp.fromProto(document.createTime);\n                snapshot.updateTime = timestamp_1.Timestamp.fromProto(document.updateTime);\n                this.changeMap.set(relativeName, snapshot);\n            }\n            else if (removed) {\n                logger_1.logger('Watch.onData', this.requestTag, 'Received document remove');\n                this.changeMap.set(relativeName, REMOVED);\n            }\n        }\n        else if (proto.documentDelete || proto.documentRemove) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing remove event');\n            const name = (proto.documentDelete || proto.documentRemove).document;\n            const relativeName = path_1.QualifiedResourcePath.fromSlashSeparatedString(name)\n                .relativeName;\n            this.changeMap.set(relativeName, REMOVED);\n        }\n        else if (proto.filter) {\n            logger_1.logger('Watch.onData', this.requestTag, 'Processing filter update');\n            if (proto.filter.count !== this.currentSize()) {\n                // We need to remove all the current results.\n                this.resetDocs();\n                // The filter didn't match, so re-issue the query.\n                this.resetStream();\n            }\n        }\n        else {\n            this.closeStream(new Error('Unknown listen response type: ' + JSON.stringify(proto)));\n        }\n    }\n    /**\n     * Checks if the current target id is included in the list of target ids.\n     * If no targetIds are provided, returns true.\n     * @private\n     */\n    affectsTarget(targetIds, currentId) {\n        if (targetIds === undefined || targetIds.length === 0) {\n            return true;\n        }\n        for (const targetId of targetIds) {\n            if (targetId === currentId) {\n                return true;\n            }\n        }\n        return false;\n    }\n    /**\n     * Assembles a new snapshot from the current set of changes and invokes the\n     * user's callback. Clears the current changes on completion.\n     * @private\n     */\n    pushSnapshot(readTime, nextResumeToken) {\n        const appliedChanges = this.computeSnapshot(readTime);\n        if (!this.hasPushed || appliedChanges.length > 0) {\n            logger_1.logger('Watch.pushSnapshot', this.requestTag, 'Sending snapshot with %d changes and %d documents', String(appliedChanges.length), this.docTree.length);\n            // We pass the current set of changes, even if `docTree` is modified later.\n            const currentTree = this.docTree;\n            this.onNext(readTime, currentTree.length, () => currentTree.keys, () => appliedChanges);\n            this.hasPushed = true;\n        }\n        this.changeMap.clear();\n        this.resumeToken = nextResumeToken;\n    }\n    /**\n     * Applies a document delete to the document tree and the document map.\n     * Returns the corresponding DocumentChange event.\n     * @private\n     */\n    deleteDoc(name) {\n        assert(this.docMap.has(name), 'Document to delete does not exist');\n        const oldDocument = this.docMap.get(name);\n        const existing = this.docTree.find(oldDocument);\n        const oldIndex = existing.index;\n        this.docTree = existing.remove();\n        this.docMap.delete(name);\n        return new document_change_1.DocumentChange(ChangeType.removed, oldDocument, oldIndex, -1);\n    }\n    /**\n     * Applies a document add to the document tree and the document map. Returns\n     * the corresponding DocumentChange event.\n     * @private\n     */\n    addDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(!this.docMap.has(name), 'Document to add already exists');\n        this.docTree = this.docTree.insert(newDocument, null);\n        const newIndex = this.docTree.find(newDocument).index;\n        this.docMap.set(name, newDocument);\n        return new document_change_1.DocumentChange(ChangeType.added, newDocument, -1, newIndex);\n    }\n    /**\n     * Applies a document modification to the document tree and the document map.\n     * Returns the DocumentChange event for successful modifications.\n     * @private\n     */\n    modifyDoc(newDocument) {\n        const name = newDocument.ref.path;\n        assert(this.docMap.has(name), 'Document to modify does not exist');\n        const oldDocument = this.docMap.get(name);\n        if (!oldDocument.updateTime.isEqual(newDocument.updateTime)) {\n            const removeChange = this.deleteDoc(name);\n            const addChange = this.addDoc(newDocument);\n            return new document_change_1.DocumentChange(ChangeType.modified, newDocument, removeChange.oldIndex, addChange.newIndex);\n        }\n        return null;\n    }\n    /**\n     * Applies the mutations in changeMap to both the document tree and the\n     * document lookup map. Modified docMap in-place and returns the updated\n     * state.\n     * @private\n     */\n    computeSnapshot(readTime) {\n        const changeSet = this.extractCurrentChanges(readTime);\n        const appliedChanges = [];\n        // Process the sorted changes in the order that is expected by our clients\n        // (removals, additions, and then modifications). We also need to sort the\n        // individual changes to assure that oldIndex/newIndex keep incrementing.\n        changeSet.deletes.sort((name1, name2) => {\n            // Deletes are sorted based on the order of the existing document.\n            return this.getComparator()(this.docMap.get(name1), this.docMap.get(name2));\n        });\n        changeSet.deletes.forEach(name => {\n            const change = this.deleteDoc(name);\n            appliedChanges.push(change);\n        });\n        changeSet.adds.sort(this.getComparator());\n        changeSet.adds.forEach(snapshot => {\n            const change = this.addDoc(snapshot);\n            appliedChanges.push(change);\n        });\n        changeSet.updates.sort(this.getComparator());\n        changeSet.updates.forEach(snapshot => {\n            const change = this.modifyDoc(snapshot);\n            if (change) {\n                appliedChanges.push(change);\n            }\n        });\n        assert(this.docTree.length === this.docMap.size, 'The update document ' +\n            'tree and document map should have the same number of entries.');\n        return appliedChanges;\n    }\n    /**\n     * Determines whether a watch error is considered permanent and should not be\n     * retried. Errors that don't provide a GRPC error code are always considered\n     * transient in this context.\n     *\n     * @private\n     * @param error An error object.\n     * @return Whether the error is permanent.\n     */\n    isPermanentWatchError(error) {\n        if (error.code === undefined) {\n            logger_1.logger('Watch.isPermanentError', this.requestTag, 'Unable to determine error code: ', error);\n            return false;\n        }\n        switch (error.code) {\n            case google_gax_1.Status.ABORTED:\n            case google_gax_1.Status.CANCELLED:\n            case google_gax_1.Status.UNKNOWN:\n            case google_gax_1.Status.DEADLINE_EXCEEDED:\n            case google_gax_1.Status.RESOURCE_EXHAUSTED:\n            case google_gax_1.Status.INTERNAL:\n            case google_gax_1.Status.UNAVAILABLE:\n            case google_gax_1.Status.UNAUTHENTICATED:\n                return false;\n            default:\n                return true;\n        }\n    }\n    /**\n     * Determines whether we need to initiate a longer backoff due to system\n     * overload.\n     *\n     * @private\n     * @param error A GRPC Error object that exposes an error code.\n     * @return Whether we need to back off our retries.\n     */\n    isResourceExhaustedError(error) {\n        return error.code === google_gax_1.Status.RESOURCE_EXHAUSTED;\n    }\n    /** Closes the stream and clears all timeouts. */\n    shutdown() {\n        var _a;\n        if (this.isActive) {\n            this.isActive = false;\n            if (this.idleTimeoutHandle) {\n                clearTimeout(this.idleTimeoutHandle);\n                this.idleTimeoutHandle = undefined;\n            }\n            this.firestore.unregisterListener();\n        }\n        (_a = this.currentStream) === null || _a === void 0 ? void 0 : _a.end();\n        this.currentStream = null;\n    }\n}\n/**\n * Creates a new Watch instance to listen on DocumentReferences.\n *\n * @private\n */\nclass DocumentWatch extends Watch {\n    constructor(firestore, ref) {\n        super(firestore, ref._converter);\n        this.ref = ref;\n    }\n    getComparator() {\n        return DOCUMENT_WATCH_COMPARATOR;\n    }\n    getTarget(resumeToken) {\n        const formattedName = this.ref.formattedName;\n        return {\n            documents: {\n                documents: [formattedName],\n            },\n            targetId: WATCH_TARGET_ID,\n            resumeToken,\n        };\n    }\n}\nexports.DocumentWatch = DocumentWatch;\n/**\n * Creates a new Watch instance to listen on Queries.\n *\n * @private\n */\nclass QueryWatch extends Watch {\n    constructor(firestore, query, converter) {\n        super(firestore, converter);\n        this.query = query;\n        this.comparator = query.comparator();\n    }\n    getComparator() {\n        return this.query.comparator();\n    }\n    getTarget(resumeToken) {\n        const query = this.query.toProto();\n        return { query, targetId: WATCH_TARGET_ID, resumeToken };\n    }\n}\nexports.QueryWatch = QueryWatch;\n//# sourceMappingURL=watch.js.map"]},"metadata":{},"sourceType":"script"}