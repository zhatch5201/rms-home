{"ast":null,"code":"\"use strict\";\n/*!\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\n\nvar _regeneratorRuntime = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nvar _assertThisInitialized = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/assertThisInitialized\");\n\nvar _inherits = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\n\nvar abort_controller_1 = require(\"abort-controller\");\n\nvar ConfigStore = require(\"configstore\");\n\nvar crypto_1 = require(\"crypto\");\n\nvar extend = require(\"extend\");\n\nvar google_auth_library_1 = require(\"google-auth-library\");\n\nvar Pumpify = require(\"pumpify\");\n\nvar stream_1 = require(\"stream\");\n\nvar streamEvents = require(\"stream-events\");\n\nvar TERMINATED_UPLOAD_STATUS_CODE = 410;\nvar RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nvar RETRY_LIMIT = 5;\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\n\nvar Upload = /*#__PURE__*/function (_Pumpify) {\n  _inherits(Upload, _Pumpify);\n\n  var _super = _createSuper(Upload);\n\n  function Upload(cfg) {\n    var _this;\n\n    _classCallCheck(this, Upload);\n\n    _this = _super.call(this);\n    _this.numBytesWritten = 0;\n    _this.numRetries = 0;\n    streamEvents(_assertThisInitialized(_this));\n    cfg = cfg || {};\n\n    if (!cfg.bucket || !cfg.file) {\n      throw new Error('A bucket and file name are required');\n    }\n\n    cfg.authConfig = cfg.authConfig || {};\n    cfg.authConfig.scopes = ['https://www.googleapis.com/auth/devstorage.full_control'];\n    _this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n    _this.apiEndpoint = 'https://storage.googleapis.com';\n\n    if (cfg.apiEndpoint) {\n      _this.apiEndpoint = _this.sanitizeEndpoint(cfg.apiEndpoint);\n    }\n\n    _this.baseURI = \"\".concat(_this.apiEndpoint, \"/upload/storage/v1/b\");\n    _this.bucket = cfg.bucket;\n    var cacheKeyElements = [cfg.bucket, cfg.file];\n\n    if (typeof cfg.generation === 'number') {\n      cacheKeyElements.push(\"\".concat(cfg.generation));\n    }\n\n    _this.cacheKey = cacheKeyElements.join('/');\n    _this.customRequestOptions = cfg.customRequestOptions || {};\n    _this.file = cfg.file;\n    _this.generation = cfg.generation;\n    _this.kmsKeyName = cfg.kmsKeyName;\n    _this.metadata = cfg.metadata || {};\n    _this.offset = cfg.offset;\n    _this.origin = cfg.origin;\n    _this.params = cfg.params || {};\n    _this.userProject = cfg.userProject;\n\n    if (cfg.key) {\n      /**\n       * NOTE: This is `as string` because there appears to be some weird kind\n       * of TypeScript bug as 2.8. Tracking the issue here:\n       * https://github.com/Microsoft/TypeScript/issues/23155\n       */\n      var base64Key = Buffer.from(cfg.key).toString('base64');\n      _this.encryption = {\n        key: base64Key,\n        hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64')\n      };\n    }\n\n    _this.predefinedAcl = cfg.predefinedAcl;\n    if (cfg.private) _this.predefinedAcl = 'private';\n    if (cfg.public) _this.predefinedAcl = 'publicRead';\n    var configPath = cfg.configPath;\n    _this.configStore = new ConfigStore('gcs-resumable-upload', null, {\n      configPath: configPath\n    });\n    _this.uriProvidedManually = !!cfg.uri;\n    _this.uri = cfg.uri || _this.get('uri');\n    _this.numBytesWritten = 0;\n    _this.numRetries = 0;\n    var contentLength = cfg.metadata ? Number(cfg.metadata.contentLength) : NaN;\n    _this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n\n    _this.once('writing', function () {\n      if (_this.uri) {\n        _this.continueUploading();\n      } else {\n        _this.createURI(function (err) {\n          if (err) {\n            return _this.destroy(err);\n          }\n\n          _this.startUploading();\n        });\n      }\n    });\n\n    return _this;\n  }\n\n  _createClass(Upload, [{\n    key: \"createURI\",\n    value: function createURI(callback) {\n      if (!callback) {\n        return this.createURIAsync();\n      }\n\n      this.createURIAsync().then(function (r) {\n        return callback(null, r);\n      }, callback);\n    }\n  }, {\n    key: \"createURIAsync\",\n    value: function () {\n      var _createURIAsync = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n        var metadata, reqOpts, resp, uri;\n        return _regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                metadata = this.metadata;\n                reqOpts = {\n                  method: 'POST',\n                  url: [this.baseURI, this.bucket, 'o'].join('/'),\n                  params: Object.assign({\n                    name: this.file,\n                    uploadType: 'resumable'\n                  }, this.params),\n                  data: metadata,\n                  headers: {}\n                };\n\n                if (metadata.contentLength) {\n                  reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n                }\n\n                if (metadata.contentType) {\n                  reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n                }\n\n                if (typeof this.generation !== 'undefined') {\n                  reqOpts.params.ifGenerationMatch = this.generation;\n                }\n\n                if (this.kmsKeyName) {\n                  reqOpts.params.kmsKeyName = this.kmsKeyName;\n                }\n\n                if (this.predefinedAcl) {\n                  reqOpts.params.predefinedAcl = this.predefinedAcl;\n                }\n\n                if (this.origin) {\n                  reqOpts.headers.Origin = this.origin;\n                }\n\n                _context.next = 10;\n                return this.makeRequest(reqOpts);\n\n              case 10:\n                resp = _context.sent;\n                uri = resp.headers.location;\n                this.uri = uri;\n                this.set({\n                  uri: uri\n                });\n                this.offset = 0;\n                return _context.abrupt(\"return\", uri);\n\n              case 16:\n              case \"end\":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function createURIAsync() {\n        return _createURIAsync.apply(this, arguments);\n      }\n\n      return createURIAsync;\n    }()\n  }, {\n    key: \"continueUploading\",\n    value: function () {\n      var _continueUploading = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n        return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                if (!(typeof this.offset === 'number')) {\n                  _context2.next = 3;\n                  break;\n                }\n\n                this.startUploading();\n                return _context2.abrupt(\"return\");\n\n              case 3:\n                _context2.next = 5;\n                return this.getAndSetOffset();\n\n              case 5:\n                this.startUploading();\n\n              case 6:\n              case \"end\":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function continueUploading() {\n        return _continueUploading.apply(this, arguments);\n      }\n\n      return continueUploading;\n    }()\n  }, {\n    key: \"startUploading\",\n    value: function () {\n      var _startUploading = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n        var _this2 = this;\n\n        var bufferStream, offsetStream, delayStream, requestStreamEmbeddedStream, reqOpts;\n        return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n          while (1) {\n            switch (_context3.prev = _context3.next) {\n              case 0:\n                // The buffer stream allows us to keep chunks in memory\n                // until we are sure we can successfully resume the upload.\n                bufferStream = this.bufferStream || new stream_1.PassThrough();\n                this.bufferStream = bufferStream; // The offset stream allows us to analyze each incoming\n                // chunk to analyze it against what the upstream API already\n                // has stored for this upload.\n\n                offsetStream = this.offsetStream = new stream_1.Transform({\n                  transform: this.onChunk.bind(this)\n                }); // The delay stream gives us a chance to catch the response\n                // from the API request before we signal to the user that\n                // the upload was successful.\n\n                delayStream = new stream_1.PassThrough(); // The request library (authClient.request()) requires the\n                // stream to be sent within the request options.\n\n                requestStreamEmbeddedStream = new stream_1.PassThrough();\n                delayStream.on('prefinish', function () {\n                  // Pause the stream from finishing so we can process the\n                  // response from the API.\n                  _this2.cork();\n                }); // Process the API response to look for errors that came in\n                // the response body.\n\n                this.on('response', function (resp) {\n                  if (resp.data.error) {\n                    _this2.destroy(resp.data.error);\n\n                    return;\n                  }\n\n                  if (resp.status < 200 || resp.status > 299) {\n                    _this2.destroy(new Error('Upload failed'));\n\n                    return;\n                  }\n\n                  if (resp && resp.data) {\n                    resp.data.size = Number(resp.data.size);\n                  }\n\n                  _this2.emit('metadata', resp.data);\n\n                  _this2.deleteConfig(); // Allow the stream to continue naturally so the user's\n                  // \"finish\" event fires.\n\n\n                  _this2.uncork();\n                });\n                this.setPipeline(bufferStream, offsetStream, delayStream);\n                this.pipe(requestStreamEmbeddedStream);\n                this.once('restart', function () {\n                  // The upload is being re-attempted. Disconnect the request\n                  // stream, so it won't receive more data.\n                  _this2.unpipe(requestStreamEmbeddedStream);\n                });\n                reqOpts = {\n                  method: 'PUT',\n                  url: this.uri,\n                  headers: {\n                    'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength\n                  },\n                  body: requestStreamEmbeddedStream\n                };\n                _context3.prev = 11;\n                _context3.next = 14;\n                return this.makeRequestStream(reqOpts);\n\n              case 14:\n                _context3.next = 19;\n                break;\n\n              case 16:\n                _context3.prev = 16;\n                _context3.t0 = _context3[\"catch\"](11);\n                this.destroy(_context3.t0);\n\n              case 19:\n              case \"end\":\n                return _context3.stop();\n            }\n          }\n        }, _callee3, this, [[11, 16]]);\n      }));\n\n      function startUploading() {\n        return _startUploading.apply(this, arguments);\n      }\n\n      return startUploading;\n    }()\n  }, {\n    key: \"onChunk\",\n    value: function onChunk(chunk, enc, next) {\n      var offset = this.offset;\n      var numBytesWritten = this.numBytesWritten;\n      this.emit('progress', {\n        bytesWritten: this.numBytesWritten,\n        contentLength: this.contentLength\n      }); // check if this is the same content uploaded previously. this caches a\n      // slice of the first chunk, then compares it with the first byte of\n      // incoming data\n\n      if (numBytesWritten === 0) {\n        var cachedFirstChunk = this.get('firstChunk');\n        var firstChunk = chunk.slice(0, 16).valueOf();\n\n        if (!cachedFirstChunk) {\n          // This is a new upload. Cache the first chunk.\n          this.set({\n            uri: this.uri,\n            firstChunk: firstChunk\n          });\n        } else {\n          // this continues an upload in progress. check if the bytes are the same\n          cachedFirstChunk = Buffer.from(cachedFirstChunk);\n          var nextChunk = Buffer.from(firstChunk);\n\n          if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n            // this data is not the same. start a new upload\n            this.bufferStream.unshift(chunk);\n            this.bufferStream.unpipe(this.offsetStream);\n            this.restart();\n            return;\n          }\n        }\n      }\n\n      var length = chunk.length;\n      if (typeof chunk === 'string') length = Buffer.byteLength(chunk, enc);\n      if (numBytesWritten < offset) chunk = chunk.slice(offset - numBytesWritten);\n      this.numBytesWritten += length; // only push data from the byte after the one we left off on\n\n      next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n    }\n  }, {\n    key: \"getAndSetOffset\",\n    value: function () {\n      var _getAndSetOffset = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n        var opts, resp, range, _resp;\n\n        return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n          while (1) {\n            switch (_context4.prev = _context4.next) {\n              case 0:\n                opts = {\n                  method: 'PUT',\n                  url: this.uri,\n                  headers: {\n                    'Content-Length': 0,\n                    'Content-Range': 'bytes */*'\n                  }\n                };\n                _context4.prev = 1;\n                _context4.next = 4;\n                return this.makeRequest(opts);\n\n              case 4:\n                resp = _context4.sent;\n\n                if (!(resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE)) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                if (!resp.headers.range) {\n                  _context4.next = 10;\n                  break;\n                }\n\n                range = resp.headers.range;\n                this.offset = Number(range.split('-')[1]) + 1;\n                return _context4.abrupt(\"return\");\n\n              case 10:\n                this.offset = 0;\n                _context4.next = 23;\n                break;\n\n              case 13:\n                _context4.prev = 13;\n                _context4.t0 = _context4[\"catch\"](1);\n                _resp = _context4.t0.response; // we don't return a 404 to the user if they provided the resumable\n                // URI. if we're just using the configstore file to tell us that this\n                // file exists, and it turns out that it doesn't (the 404), that's\n                // probably stale config data.\n\n                if (!(_resp && _resp.status === 404 && !this.uriProvidedManually)) {\n                  _context4.next = 19;\n                  break;\n                }\n\n                this.restart();\n                return _context4.abrupt(\"return\");\n\n              case 19:\n                if (!(_resp && _resp.status === TERMINATED_UPLOAD_STATUS_CODE)) {\n                  _context4.next = 22;\n                  break;\n                }\n\n                this.restart();\n                return _context4.abrupt(\"return\");\n\n              case 22:\n                this.destroy(_context4.t0);\n\n              case 23:\n              case \"end\":\n                return _context4.stop();\n            }\n          }\n        }, _callee4, this, [[1, 13]]);\n      }));\n\n      function getAndSetOffset() {\n        return _getAndSetOffset.apply(this, arguments);\n      }\n\n      return getAndSetOffset;\n    }()\n  }, {\n    key: \"makeRequest\",\n    value: function () {\n      var _makeRequest = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee5(reqOpts) {\n        var combinedReqOpts, res;\n        return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n          while (1) {\n            switch (_context5.prev = _context5.next) {\n              case 0:\n                if (this.encryption) {\n                  reqOpts.headers = reqOpts.headers || {};\n                  reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n                  reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n                  reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n                }\n\n                if (this.userProject) {\n                  reqOpts.params = reqOpts.params || {};\n                  reqOpts.params.userProject = this.userProject;\n                } // Let gaxios know we will handle a 308 error code ourselves.\n\n\n                reqOpts.validateStatus = function (status) {\n                  return status >= 200 && status < 300 || status === RESUMABLE_INCOMPLETE_STATUS_CODE;\n                };\n\n                combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n                _context5.next = 6;\n                return this.authClient.request(combinedReqOpts);\n\n              case 6:\n                res = _context5.sent;\n\n                if (!(res.data && res.data.error)) {\n                  _context5.next = 9;\n                  break;\n                }\n\n                throw res.data.error;\n\n              case 9:\n                return _context5.abrupt(\"return\", res);\n\n              case 10:\n              case \"end\":\n                return _context5.stop();\n            }\n          }\n        }, _callee5, this);\n      }));\n\n      function makeRequest(_x) {\n        return _makeRequest.apply(this, arguments);\n      }\n\n      return makeRequest;\n    }()\n  }, {\n    key: \"makeRequestStream\",\n    value: function () {\n      var _makeRequestStream = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee6(reqOpts) {\n        var controller, combinedReqOpts, res;\n        return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n          while (1) {\n            switch (_context6.prev = _context6.next) {\n              case 0:\n                controller = new abort_controller_1.default();\n                this.once('error', function () {\n                  return controller.abort();\n                });\n\n                if (this.userProject) {\n                  reqOpts.params = reqOpts.params || {};\n                  reqOpts.params.userProject = this.userProject;\n                }\n\n                reqOpts.signal = controller.signal;\n\n                reqOpts.validateStatus = function () {\n                  return true;\n                };\n\n                combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n                _context6.next = 8;\n                return this.authClient.request(combinedReqOpts);\n\n              case 8:\n                res = _context6.sent;\n                this.onResponse(res);\n                return _context6.abrupt(\"return\", res);\n\n              case 11:\n              case \"end\":\n                return _context6.stop();\n            }\n          }\n        }, _callee6, this);\n      }));\n\n      function makeRequestStream(_x2) {\n        return _makeRequestStream.apply(this, arguments);\n      }\n\n      return makeRequestStream;\n    }()\n  }, {\n    key: \"restart\",\n    value: function restart() {\n      var _this3 = this;\n\n      this.emit('restart');\n      this.numBytesWritten = 0;\n      this.deleteConfig();\n      this.createURI(function (err) {\n        if (err) {\n          return _this3.destroy(err);\n        }\n\n        _this3.startUploading();\n      });\n    }\n  }, {\n    key: \"get\",\n    value: function get(prop) {\n      var store = this.configStore.get(this.cacheKey);\n      return store && store[prop];\n    } // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n  }, {\n    key: \"set\",\n    value: function set(props) {\n      this.configStore.set(this.cacheKey, props);\n    }\n  }, {\n    key: \"deleteConfig\",\n    value: function deleteConfig() {\n      this.configStore.delete(this.cacheKey);\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n\n  }, {\n    key: \"onResponse\",\n    value: function onResponse(resp) {\n      if (resp.status === 404) {\n        if (this.numRetries < RETRY_LIMIT) {\n          this.numRetries++;\n          this.startUploading();\n        } else {\n          this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n\n        return false;\n      }\n\n      if (resp.status > 499 && resp.status < 600) {\n        if (this.numRetries < RETRY_LIMIT) {\n          var randomMs = Math.round(Math.random() * 1000);\n          var waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n          this.numRetries++;\n          setTimeout(this.continueUploading.bind(this), waitTime);\n        } else {\n          this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n        }\n\n        return false;\n      }\n\n      this.emit('response', resp);\n      return true;\n    }\n    /*\n     * Prepare user-defined API endpoint for compatibility with our API.\n     */\n\n  }, {\n    key: \"sanitizeEndpoint\",\n    value: function sanitizeEndpoint(url) {\n      if (!exports.PROTOCOL_REGEX.test(url)) {\n        url = \"https://\".concat(url);\n      }\n\n      return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n  }]);\n\n  return Upload;\n}(Pumpify);\n\nexports.Upload = Upload;\n\nfunction upload(cfg) {\n  return new Upload(cfg);\n}\n\nexports.upload = upload;\n\nfunction createURI(cfg, callback) {\n  var up = new Upload(cfg);\n\n  if (!callback) {\n    return up.createURI();\n  }\n\n  up.createURI().then(function (r) {\n    return callback(null, r);\n  }, callback);\n}\n\nexports.createURI = createURI;","map":{"version":3,"sources":["../../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\n/*!\n * Copyright 2018 Google LLC\n *\n * Use of this source code is governed by an MIT-style\n * license that can be found in the LICENSE file or at\n * https://opensource.org/licenses/MIT.\n */\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createURI = exports.upload = exports.Upload = exports.PROTOCOL_REGEX = void 0;\nconst abort_controller_1 = require(\"abort-controller\");\nconst ConfigStore = require(\"configstore\");\nconst crypto_1 = require(\"crypto\");\nconst extend = require(\"extend\");\nconst google_auth_library_1 = require(\"google-auth-library\");\nconst Pumpify = require(\"pumpify\");\nconst stream_1 = require(\"stream\");\nconst streamEvents = require(\"stream-events\");\nconst TERMINATED_UPLOAD_STATUS_CODE = 410;\nconst RESUMABLE_INCOMPLETE_STATUS_CODE = 308;\nconst RETRY_LIMIT = 5;\nexports.PROTOCOL_REGEX = /^(\\w*):\\/\\//;\nclass Upload extends Pumpify {\n    constructor(cfg) {\n        super();\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        streamEvents(this);\n        cfg = cfg || {};\n        if (!cfg.bucket || !cfg.file) {\n            throw new Error('A bucket and file name are required');\n        }\n        cfg.authConfig = cfg.authConfig || {};\n        cfg.authConfig.scopes = [\n            'https://www.googleapis.com/auth/devstorage.full_control',\n        ];\n        this.authClient = cfg.authClient || new google_auth_library_1.GoogleAuth(cfg.authConfig);\n        this.apiEndpoint = 'https://storage.googleapis.com';\n        if (cfg.apiEndpoint) {\n            this.apiEndpoint = this.sanitizeEndpoint(cfg.apiEndpoint);\n        }\n        this.baseURI = `${this.apiEndpoint}/upload/storage/v1/b`;\n        this.bucket = cfg.bucket;\n        const cacheKeyElements = [cfg.bucket, cfg.file];\n        if (typeof cfg.generation === 'number') {\n            cacheKeyElements.push(`${cfg.generation}`);\n        }\n        this.cacheKey = cacheKeyElements.join('/');\n        this.customRequestOptions = cfg.customRequestOptions || {};\n        this.file = cfg.file;\n        this.generation = cfg.generation;\n        this.kmsKeyName = cfg.kmsKeyName;\n        this.metadata = cfg.metadata || {};\n        this.offset = cfg.offset;\n        this.origin = cfg.origin;\n        this.params = cfg.params || {};\n        this.userProject = cfg.userProject;\n        if (cfg.key) {\n            /**\n             * NOTE: This is `as string` because there appears to be some weird kind\n             * of TypeScript bug as 2.8. Tracking the issue here:\n             * https://github.com/Microsoft/TypeScript/issues/23155\n             */\n            const base64Key = Buffer.from(cfg.key).toString('base64');\n            this.encryption = {\n                key: base64Key,\n                hash: crypto_1.createHash('sha256').update(cfg.key).digest('base64'),\n            };\n        }\n        this.predefinedAcl = cfg.predefinedAcl;\n        if (cfg.private)\n            this.predefinedAcl = 'private';\n        if (cfg.public)\n            this.predefinedAcl = 'publicRead';\n        const configPath = cfg.configPath;\n        this.configStore = new ConfigStore('gcs-resumable-upload', null, {\n            configPath,\n        });\n        this.uriProvidedManually = !!cfg.uri;\n        this.uri = cfg.uri || this.get('uri');\n        this.numBytesWritten = 0;\n        this.numRetries = 0;\n        const contentLength = cfg.metadata\n            ? Number(cfg.metadata.contentLength)\n            : NaN;\n        this.contentLength = isNaN(contentLength) ? '*' : contentLength;\n        this.once('writing', () => {\n            if (this.uri) {\n                this.continueUploading();\n            }\n            else {\n                this.createURI(err => {\n                    if (err) {\n                        return this.destroy(err);\n                    }\n                    this.startUploading();\n                });\n            }\n        });\n    }\n    createURI(callback) {\n        if (!callback) {\n            return this.createURIAsync();\n        }\n        this.createURIAsync().then(r => callback(null, r), callback);\n    }\n    async createURIAsync() {\n        const metadata = this.metadata;\n        const reqOpts = {\n            method: 'POST',\n            url: [this.baseURI, this.bucket, 'o'].join('/'),\n            params: Object.assign({\n                name: this.file,\n                uploadType: 'resumable',\n            }, this.params),\n            data: metadata,\n            headers: {},\n        };\n        if (metadata.contentLength) {\n            reqOpts.headers['X-Upload-Content-Length'] = metadata.contentLength.toString();\n        }\n        if (metadata.contentType) {\n            reqOpts.headers['X-Upload-Content-Type'] = metadata.contentType;\n        }\n        if (typeof this.generation !== 'undefined') {\n            reqOpts.params.ifGenerationMatch = this.generation;\n        }\n        if (this.kmsKeyName) {\n            reqOpts.params.kmsKeyName = this.kmsKeyName;\n        }\n        if (this.predefinedAcl) {\n            reqOpts.params.predefinedAcl = this.predefinedAcl;\n        }\n        if (this.origin) {\n            reqOpts.headers.Origin = this.origin;\n        }\n        const resp = await this.makeRequest(reqOpts);\n        const uri = resp.headers.location;\n        this.uri = uri;\n        this.set({ uri });\n        this.offset = 0;\n        return uri;\n    }\n    async continueUploading() {\n        if (typeof this.offset === 'number') {\n            this.startUploading();\n            return;\n        }\n        await this.getAndSetOffset();\n        this.startUploading();\n    }\n    async startUploading() {\n        // The buffer stream allows us to keep chunks in memory\n        // until we are sure we can successfully resume the upload.\n        const bufferStream = this.bufferStream || new stream_1.PassThrough();\n        this.bufferStream = bufferStream;\n        // The offset stream allows us to analyze each incoming\n        // chunk to analyze it against what the upstream API already\n        // has stored for this upload.\n        const offsetStream = (this.offsetStream = new stream_1.Transform({\n            transform: this.onChunk.bind(this),\n        }));\n        // The delay stream gives us a chance to catch the response\n        // from the API request before we signal to the user that\n        // the upload was successful.\n        const delayStream = new stream_1.PassThrough();\n        // The request library (authClient.request()) requires the\n        // stream to be sent within the request options.\n        const requestStreamEmbeddedStream = new stream_1.PassThrough();\n        delayStream.on('prefinish', () => {\n            // Pause the stream from finishing so we can process the\n            // response from the API.\n            this.cork();\n        });\n        // Process the API response to look for errors that came in\n        // the response body.\n        this.on('response', (resp) => {\n            if (resp.data.error) {\n                this.destroy(resp.data.error);\n                return;\n            }\n            if (resp.status < 200 || resp.status > 299) {\n                this.destroy(new Error('Upload failed'));\n                return;\n            }\n            if (resp && resp.data) {\n                resp.data.size = Number(resp.data.size);\n            }\n            this.emit('metadata', resp.data);\n            this.deleteConfig();\n            // Allow the stream to continue naturally so the user's\n            // \"finish\" event fires.\n            this.uncork();\n        });\n        this.setPipeline(bufferStream, offsetStream, delayStream);\n        this.pipe(requestStreamEmbeddedStream);\n        this.once('restart', () => {\n            // The upload is being re-attempted. Disconnect the request\n            // stream, so it won't receive more data.\n            this.unpipe(requestStreamEmbeddedStream);\n        });\n        const reqOpts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: {\n                'Content-Range': 'bytes ' + this.offset + '-*/' + this.contentLength,\n            },\n            body: requestStreamEmbeddedStream,\n        };\n        try {\n            await this.makeRequestStream(reqOpts);\n        }\n        catch (e) {\n            this.destroy(e);\n        }\n    }\n    onChunk(chunk, enc, next) {\n        const offset = this.offset;\n        const numBytesWritten = this.numBytesWritten;\n        this.emit('progress', {\n            bytesWritten: this.numBytesWritten,\n            contentLength: this.contentLength,\n        });\n        // check if this is the same content uploaded previously. this caches a\n        // slice of the first chunk, then compares it with the first byte of\n        // incoming data\n        if (numBytesWritten === 0) {\n            let cachedFirstChunk = this.get('firstChunk');\n            const firstChunk = chunk.slice(0, 16).valueOf();\n            if (!cachedFirstChunk) {\n                // This is a new upload. Cache the first chunk.\n                this.set({ uri: this.uri, firstChunk });\n            }\n            else {\n                // this continues an upload in progress. check if the bytes are the same\n                cachedFirstChunk = Buffer.from(cachedFirstChunk);\n                const nextChunk = Buffer.from(firstChunk);\n                if (Buffer.compare(cachedFirstChunk, nextChunk) !== 0) {\n                    // this data is not the same. start a new upload\n                    this.bufferStream.unshift(chunk);\n                    this.bufferStream.unpipe(this.offsetStream);\n                    this.restart();\n                    return;\n                }\n            }\n        }\n        let length = chunk.length;\n        if (typeof chunk === 'string')\n            length = Buffer.byteLength(chunk, enc);\n        if (numBytesWritten < offset)\n            chunk = chunk.slice(offset - numBytesWritten);\n        this.numBytesWritten += length;\n        // only push data from the byte after the one we left off on\n        next(undefined, this.numBytesWritten > offset ? chunk : undefined);\n    }\n    async getAndSetOffset() {\n        const opts = {\n            method: 'PUT',\n            url: this.uri,\n            headers: { 'Content-Length': 0, 'Content-Range': 'bytes */*' },\n        };\n        try {\n            const resp = await this.makeRequest(opts);\n            if (resp.status === RESUMABLE_INCOMPLETE_STATUS_CODE) {\n                if (resp.headers.range) {\n                    const range = resp.headers.range;\n                    this.offset = Number(range.split('-')[1]) + 1;\n                    return;\n                }\n            }\n            this.offset = 0;\n        }\n        catch (err) {\n            const resp = err.response;\n            // we don't return a 404 to the user if they provided the resumable\n            // URI. if we're just using the configstore file to tell us that this\n            // file exists, and it turns out that it doesn't (the 404), that's\n            // probably stale config data.\n            if (resp && resp.status === 404 && !this.uriProvidedManually) {\n                this.restart();\n                return;\n            }\n            // this resumable upload is unrecoverable (bad data or service error).\n            //  -\n            //  https://github.com/stephenplusplus/gcs-resumable-upload/issues/15\n            //  -\n            //  https://github.com/stephenplusplus/gcs-resumable-upload/pull/16#discussion_r80363774\n            if (resp && resp.status === TERMINATED_UPLOAD_STATUS_CODE) {\n                this.restart();\n                return;\n            }\n            this.destroy(err);\n        }\n    }\n    async makeRequest(reqOpts) {\n        if (this.encryption) {\n            reqOpts.headers = reqOpts.headers || {};\n            reqOpts.headers['x-goog-encryption-algorithm'] = 'AES256';\n            reqOpts.headers['x-goog-encryption-key'] = this.encryption.key.toString();\n            reqOpts.headers['x-goog-encryption-key-sha256'] = this.encryption.hash.toString();\n        }\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        // Let gaxios know we will handle a 308 error code ourselves.\n        reqOpts.validateStatus = (status) => {\n            return ((status >= 200 && status < 300) ||\n                status === RESUMABLE_INCOMPLETE_STATUS_CODE);\n        };\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        if (res.data && res.data.error) {\n            throw res.data.error;\n        }\n        return res;\n    }\n    async makeRequestStream(reqOpts) {\n        const controller = new abort_controller_1.default();\n        this.once('error', () => controller.abort());\n        if (this.userProject) {\n            reqOpts.params = reqOpts.params || {};\n            reqOpts.params.userProject = this.userProject;\n        }\n        reqOpts.signal = controller.signal;\n        reqOpts.validateStatus = () => true;\n        const combinedReqOpts = extend(true, {}, this.customRequestOptions, reqOpts);\n        const res = await this.authClient.request(combinedReqOpts);\n        this.onResponse(res);\n        return res;\n    }\n    restart() {\n        this.emit('restart');\n        this.numBytesWritten = 0;\n        this.deleteConfig();\n        this.createURI(err => {\n            if (err) {\n                return this.destroy(err);\n            }\n            this.startUploading();\n        });\n    }\n    get(prop) {\n        const store = this.configStore.get(this.cacheKey);\n        return store && store[prop];\n    }\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    set(props) {\n        this.configStore.set(this.cacheKey, props);\n    }\n    deleteConfig() {\n        this.configStore.delete(this.cacheKey);\n    }\n    /**\n     * @return {bool} is the request good?\n     */\n    onResponse(resp) {\n        if (resp.status === 404) {\n            if (this.numRetries < RETRY_LIMIT) {\n                this.numRetries++;\n                this.startUploading();\n            }\n            else {\n                this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n            }\n            return false;\n        }\n        if (resp.status > 499 && resp.status < 600) {\n            if (this.numRetries < RETRY_LIMIT) {\n                const randomMs = Math.round(Math.random() * 1000);\n                const waitTime = Math.pow(2, this.numRetries) * 1000 + randomMs;\n                this.numRetries++;\n                setTimeout(this.continueUploading.bind(this), waitTime);\n            }\n            else {\n                this.destroy(new Error('Retry limit exceeded - ' + resp.data));\n            }\n            return false;\n        }\n        this.emit('response', resp);\n        return true;\n    }\n    /*\n     * Prepare user-defined API endpoint for compatibility with our API.\n     */\n    sanitizeEndpoint(url) {\n        if (!exports.PROTOCOL_REGEX.test(url)) {\n            url = `https://${url}`;\n        }\n        return url.replace(/\\/+$/, ''); // Remove trailing slashes\n    }\n}\nexports.Upload = Upload;\nfunction upload(cfg) {\n    return new Upload(cfg);\n}\nexports.upload = upload;\nfunction createURI(cfg, callback) {\n    const up = new Upload(cfg);\n    if (!callback) {\n        return up.createURI();\n    }\n    up.createURI().then(r => callback(null, r), callback);\n}\nexports.createURI = createURI;\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"script"}