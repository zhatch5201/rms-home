{"ast":null,"code":"\"use strict\"; // Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\n\nvar _inherits = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\n\nvar _createSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createSuper\");\n\nvar _wrapNativeSuper = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/wrapNativeSuper\");\n\nvar _slicedToArray = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/slicedToArray\");\n\nvar _objectSpread = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/objectSpread2\");\n\nvar _regeneratorRuntime = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\");\n\nvar _asyncToGenerator = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/asyncToGenerator\");\n\nvar _classCallCheck = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\n\nvar _createClass = require(\"C:/Users/Zack/Desktop/rms-home/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\n\nvar crypto = require(\"crypto\");\n\nvar dateFormat = require(\"date-and-time\");\n\nvar url = require(\"url\");\n\nvar util_1 = require(\"./util\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\n\n\nvar DEFAULT_SIGNING_VERSION = 'v2';\nvar SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\n\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\n\nvar URLSigner = /*#__PURE__*/function () {\n  function URLSigner(authClient, bucket, file) {\n    _classCallCheck(this, URLSigner);\n\n    this.bucket = bucket;\n    this.file = file;\n    this.authClient = authClient;\n  }\n\n  _createClass(URLSigner, [{\n    key: \"getSignedUrl\",\n    value: function getSignedUrl(cfg) {\n      var _this = this;\n\n      var expiresInSeconds = this.parseExpires(cfg.expires);\n      var method = cfg.method;\n      var accessibleAtInSeconds = this.parseAccessibleAt(cfg.accessibleAt);\n\n      if (expiresInSeconds < accessibleAtInSeconds) {\n        throw new Error('An expiration date cannot be before accessible date.');\n      }\n\n      var customHost; // Default style is `path`.\n\n      var isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n\n      if (cfg.cname) {\n        customHost = cfg.cname;\n      } else if (isVirtualHostedStyle) {\n        customHost = \"https://\".concat(this.bucket.name, \".storage.googleapis.com\");\n      }\n\n      var secondsToMilliseconds = 1000;\n      var config = Object.assign({}, cfg, {\n        method: method,\n        expiration: expiresInSeconds,\n        accessibleAt: new Date(secondsToMilliseconds * accessibleAtInSeconds),\n        bucket: this.bucket.name,\n        file: this.file ? util_1.encodeURI(this.file.name, false) : undefined\n      });\n\n      if (customHost) {\n        config.cname = customHost;\n      }\n\n      var version = cfg.version || DEFAULT_SIGNING_VERSION;\n      var promise;\n\n      if (version === 'v2') {\n        promise = this.getSignedUrlV2(config);\n      } else if (version === 'v4') {\n        promise = this.getSignedUrlV4(config);\n      } else {\n        throw new Error(\"Invalid signed URL version: \".concat(version, \". Supported versions are 'v2' and 'v4'.\"));\n      }\n\n      return promise.then(function (query) {\n        query = Object.assign(query, cfg.queryParams);\n        var signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        signedUrl.pathname = _this.getResourcePath(!!config.cname, _this.bucket.name, config.file); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n        signedUrl.search = util_1.qsStringify(query);\n        return signedUrl.href;\n      });\n    }\n  }, {\n    key: \"getSignedUrlV2\",\n    value: function getSignedUrlV2(config) {\n      var _this2 = this;\n\n      var canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n      var resourcePath = this.getResourcePath(false, config.bucket, config.file);\n      var blobToSign = [config.method, config.contentMd5 || '', config.contentType || '', config.expiration, canonicalHeadersString + resourcePath].join('\\n');\n\n      var sign = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n          var authClient, signature, credentials, signingErr;\n          return _regeneratorRuntime.wrap(function _callee$(_context) {\n            while (1) {\n              switch (_context.prev = _context.next) {\n                case 0:\n                  authClient = _this2.authClient;\n                  _context.prev = 1;\n                  _context.next = 4;\n                  return authClient.sign(blobToSign);\n\n                case 4:\n                  signature = _context.sent;\n                  _context.next = 7;\n                  return authClient.getCredentials();\n\n                case 7:\n                  credentials = _context.sent;\n                  return _context.abrupt(\"return\", {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature\n                  });\n\n                case 11:\n                  _context.prev = 11;\n                  _context.t0 = _context[\"catch\"](1);\n                  signingErr = new SigningError(_context.t0.message);\n                  signingErr.stack = _context.t0.stack;\n                  throw signingErr;\n\n                case 16:\n                case \"end\":\n                  return _context.stop();\n              }\n            }\n          }, _callee, null, [[1, 11]]);\n        }));\n\n        return function sign() {\n          return _ref.apply(this, arguments);\n        };\n      }();\n\n      return sign();\n    }\n  }, {\n    key: \"getSignedUrlV4\",\n    value: function getSignedUrlV4(config) {\n      var _this3 = this;\n\n      config.accessibleAt = config.accessibleAt ? config.accessibleAt : new Date();\n      var millisecondsToSeconds = 1.0 / 1000.0;\n      var expiresPeriodInSeconds = config.expiration - config.accessibleAt.valueOf() * millisecondsToSeconds; // v4 limit expiration to be 7 days maximum\n\n      if (expiresPeriodInSeconds > SEVEN_DAYS) {\n        throw new Error(\"Max allowed expiration is seven days (\".concat(SEVEN_DAYS, \" seconds).\"));\n      }\n\n      var extensionHeaders = Object.assign({}, config.extensionHeaders);\n      var fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n      extensionHeaders.host = fqdn.host;\n\n      if (config.contentMd5) {\n        extensionHeaders['content-md5'] = config.contentMd5;\n      }\n\n      if (config.contentType) {\n        extensionHeaders['content-type'] = config.contentType;\n      }\n\n      var contentSha256;\n      var sha256Header = extensionHeaders['x-goog-content-sha256'];\n\n      if (sha256Header) {\n        if (typeof sha256Header !== 'string' || !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n          throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n        }\n\n        contentSha256 = sha256Header;\n      }\n\n      var signedHeaders = Object.keys(extensionHeaders).map(function (header) {\n        return header.toLowerCase();\n      }).sort().join(';');\n      var extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n      var datestamp = dateFormat.format(config.accessibleAt, 'YYYYMMDD', true);\n      var credentialScope = \"\".concat(datestamp, \"/auto/storage/goog4_request\");\n\n      var sign = /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n          var credentials, credential, dateISO, queryParams, canonicalQueryParams, canonicalRequest, hash, blobToSign, signature, signatureHex, signedQuery, signingErr;\n          return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n            while (1) {\n              switch (_context2.prev = _context2.next) {\n                case 0:\n                  _context2.next = 2;\n                  return _this3.authClient.getCredentials();\n\n                case 2:\n                  credentials = _context2.sent;\n                  credential = \"\".concat(credentials.client_email, \"/\").concat(credentialScope);\n                  dateISO = dateFormat.format(config.accessibleAt ? config.accessibleAt : new Date(), 'YYYYMMDD[T]HHmmss[Z]', true);\n                  queryParams = _objectSpread({\n                    'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n                    'X-Goog-Credential': credential,\n                    'X-Goog-Date': dateISO,\n                    'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n                    'X-Goog-SignedHeaders': signedHeaders\n                  }, config.queryParams || {}); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n                  canonicalQueryParams = _this3.getCanonicalQueryParams(queryParams);\n                  canonicalRequest = _this3.getCanonicalRequest(config.method, _this3.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n                  hash = crypto.createHash('sha256').update(canonicalRequest).digest('hex');\n                  blobToSign = ['GOOG4-RSA-SHA256', dateISO, credentialScope, hash].join('\\n');\n                  _context2.prev = 10;\n                  _context2.next = 13;\n                  return _this3.authClient.sign(blobToSign);\n\n                case 13:\n                  signature = _context2.sent;\n                  signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                  signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex\n                  });\n                  return _context2.abrupt(\"return\", signedQuery);\n\n                case 19:\n                  _context2.prev = 19;\n                  _context2.t0 = _context2[\"catch\"](10);\n                  signingErr = new SigningError(_context2.t0.message);\n                  signingErr.stack = _context2.t0.stack;\n                  throw signingErr;\n\n                case 24:\n                case \"end\":\n                  return _context2.stop();\n              }\n            }\n          }, _callee2, null, [[10, 19]]);\n        }));\n\n        return function sign() {\n          return _ref2.apply(this, arguments);\n        };\n      }();\n\n      return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n\n  }, {\n    key: \"getCanonicalHeaders\",\n    value: function getCanonicalHeaders(headers) {\n      // Sort headers by their lowercased names\n      var sortedHeaders = util_1.objectEntries(headers) // Convert header names to lowercase\n      .map(function (_ref3) {\n        var _ref4 = _slicedToArray(_ref3, 2),\n            headerName = _ref4[0],\n            value = _ref4[1];\n\n        return [headerName.toLowerCase(), value];\n      }).sort(function (a, b) {\n        return a[0].localeCompare(b[0]);\n      });\n      return sortedHeaders.filter(function (_ref5) {\n        var _ref6 = _slicedToArray(_ref5, 2),\n            value = _ref6[1];\n\n        return value !== undefined;\n      }).map(function (_ref7) {\n        var _ref8 = _slicedToArray(_ref7, 2),\n            headerName = _ref8[0],\n            value = _ref8[1];\n\n        // - Convert Array (multi-valued header) into string, delimited by\n        //      ',' (no space).\n        // - Trim leading and trailing spaces.\n        // - Convert sequential (2+) spaces into a single space\n        var canonicalValue = \"\".concat(value).trim().replace(/\\s{2,}/g, ' ');\n        return \"\".concat(headerName, \":\").concat(canonicalValue, \"\\n\");\n      }).join('');\n    }\n  }, {\n    key: \"getCanonicalRequest\",\n    value: function getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n      return [method, path, query, headers, signedHeaders, contentSha256 || 'UNSIGNED-PAYLOAD'].join('\\n');\n    }\n  }, {\n    key: \"getCanonicalQueryParams\",\n    value: function getCanonicalQueryParams(query) {\n      return util_1.objectEntries(query).map(function (_ref9) {\n        var _ref10 = _slicedToArray(_ref9, 2),\n            key = _ref10[0],\n            value = _ref10[1];\n\n        return [util_1.encodeURI(key, true), util_1.encodeURI(value, true)];\n      }).sort(function (a, b) {\n        return a[0] < b[0] ? -1 : 1;\n      }).map(function (_ref11) {\n        var _ref12 = _slicedToArray(_ref11, 2),\n            key = _ref12[0],\n            value = _ref12[1];\n\n        return \"\".concat(key, \"=\").concat(value);\n      }).join('&');\n    }\n  }, {\n    key: \"getResourcePath\",\n    value: function getResourcePath(cname, bucket, file) {\n      if (cname) {\n        return '/' + (file || '');\n      } else if (file) {\n        return \"/\".concat(bucket, \"/\").concat(file);\n      } else {\n        return \"/\".concat(bucket);\n      }\n    }\n  }, {\n    key: \"parseExpires\",\n    value: function parseExpires(expires) {\n      var current = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Date();\n      var expiresInMSeconds = new Date(expires).valueOf();\n\n      if (isNaN(expiresInMSeconds)) {\n        throw new Error('The expiration date provided was invalid.');\n      }\n\n      if (expiresInMSeconds < current.valueOf()) {\n        throw new Error('An expiration date cannot be in the past.');\n      }\n\n      return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n  }, {\n    key: \"parseAccessibleAt\",\n    value: function parseAccessibleAt(accessibleAt) {\n      var accessibleAtInMSeconds = new Date(accessibleAt || new Date()).valueOf();\n\n      if (isNaN(accessibleAtInMSeconds)) {\n        throw new Error('The accessible at date provided was invalid.');\n      }\n\n      return Math.floor(accessibleAtInMSeconds / 1000); // The API expects seconds.\n    }\n  }]);\n\n  return URLSigner;\n}();\n\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\n\nvar SigningError = /*#__PURE__*/function (_Error) {\n  _inherits(SigningError, _Error);\n\n  var _super = _createSuper(SigningError);\n\n  function SigningError() {\n    var _this4;\n\n    _classCallCheck(this, SigningError);\n\n    _this4 = _super.apply(this, arguments);\n    _this4.name = 'SigningError';\n    return _this4;\n  }\n\n  return SigningError;\n}( /*#__PURE__*/_wrapNativeSuper(Error));\n\nexports.SigningError = SigningError;","map":{"version":3,"sources":["C:/Users/Zack/Desktop/rms-home/node_modules/@google-cloud/storage/build/src/signer.js"],"names":["Object","defineProperty","exports","value","SigningError","URLSigner","PATH_STYLED_HOST","crypto","require","dateFormat","url","util_1","DEFAULT_SIGNING_VERSION","SEVEN_DAYS","authClient","bucket","file","cfg","expiresInSeconds","parseExpires","expires","method","accessibleAtInSeconds","parseAccessibleAt","accessibleAt","Error","customHost","isVirtualHostedStyle","virtualHostedStyle","cname","name","secondsToMilliseconds","config","assign","expiration","Date","encodeURI","undefined","version","promise","getSignedUrlV2","getSignedUrlV4","then","query","queryParams","signedUrl","URL","pathname","getResourcePath","search","qsStringify","href","canonicalHeadersString","getCanonicalHeaders","extensionHeaders","resourcePath","blobToSign","contentMd5","contentType","join","sign","signature","getCredentials","credentials","GoogleAccessId","client_email","Expires","Signature","signingErr","message","stack","millisecondsToSeconds","expiresPeriodInSeconds","valueOf","fqdn","host","contentSha256","sha256Header","test","signedHeaders","keys","map","header","toLowerCase","sort","extensionHeadersString","datestamp","format","credentialScope","credential","dateISO","toString","canonicalQueryParams","getCanonicalQueryParams","canonicalRequest","getCanonicalRequest","hash","createHash","update","digest","signatureHex","Buffer","from","signedQuery","headers","sortedHeaders","objectEntries","headerName","a","b","localeCompare","filter","canonicalValue","trim","replace","path","key","current","expiresInMSeconds","isNaN","Math","round","accessibleAtInMSeconds","floor","arguments"],"mappings":"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","sourcesContent":["\"use strict\";\n// Copyright 2020 Google LLC\n//\n// Licensed under the Apache License, Version 2.0 (the \"License\");\n// you may not use this file except in compliance with the License.\n// You may obtain a copy of the License at\n//\n//      http://www.apache.org/licenses/LICENSE-2.0\n//\n// Unless required by applicable law or agreed to in writing, software\n// distributed under the License is distributed on an \"AS IS\" BASIS,\n// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n// See the License for the specific language governing permissions and\n// limitations under the License.\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.SigningError = exports.URLSigner = exports.PATH_STYLED_HOST = void 0;\nconst crypto = require(\"crypto\");\nconst dateFormat = require(\"date-and-time\");\nconst url = require(\"url\");\nconst util_1 = require(\"./util\");\n/*\n * Default signing version for getSignedUrl is 'v2'.\n */\nconst DEFAULT_SIGNING_VERSION = 'v2';\nconst SEVEN_DAYS = 604800;\n/**\n * @const {string}\n * @private\n */\nexports.PATH_STYLED_HOST = 'https://storage.googleapis.com';\nclass URLSigner {\n    constructor(authClient, bucket, file) {\n        this.bucket = bucket;\n        this.file = file;\n        this.authClient = authClient;\n    }\n    getSignedUrl(cfg) {\n        const expiresInSeconds = this.parseExpires(cfg.expires);\n        const method = cfg.method;\n        const accessibleAtInSeconds = this.parseAccessibleAt(cfg.accessibleAt);\n        if (expiresInSeconds < accessibleAtInSeconds) {\n            throw new Error('An expiration date cannot be before accessible date.');\n        }\n        let customHost;\n        // Default style is `path`.\n        const isVirtualHostedStyle = cfg.virtualHostedStyle || false;\n        if (cfg.cname) {\n            customHost = cfg.cname;\n        }\n        else if (isVirtualHostedStyle) {\n            customHost = `https://${this.bucket.name}.storage.googleapis.com`;\n        }\n        const secondsToMilliseconds = 1000;\n        const config = Object.assign({}, cfg, {\n            method,\n            expiration: expiresInSeconds,\n            accessibleAt: new Date(secondsToMilliseconds * accessibleAtInSeconds),\n            bucket: this.bucket.name,\n            file: this.file ? util_1.encodeURI(this.file.name, false) : undefined,\n        });\n        if (customHost) {\n            config.cname = customHost;\n        }\n        const version = cfg.version || DEFAULT_SIGNING_VERSION;\n        let promise;\n        if (version === 'v2') {\n            promise = this.getSignedUrlV2(config);\n        }\n        else if (version === 'v4') {\n            promise = this.getSignedUrlV4(config);\n        }\n        else {\n            throw new Error(`Invalid signed URL version: ${version}. Supported versions are 'v2' and 'v4'.`);\n        }\n        return promise.then(query => {\n            query = Object.assign(query, cfg.queryParams);\n            const signedUrl = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n            signedUrl.pathname = this.getResourcePath(!!config.cname, this.bucket.name, config.file);\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            signedUrl.search = util_1.qsStringify(query);\n            return signedUrl.href;\n        });\n    }\n    getSignedUrlV2(config) {\n        const canonicalHeadersString = this.getCanonicalHeaders(config.extensionHeaders || {});\n        const resourcePath = this.getResourcePath(false, config.bucket, config.file);\n        const blobToSign = [\n            config.method,\n            config.contentMd5 || '',\n            config.contentType || '',\n            config.expiration,\n            canonicalHeadersString + resourcePath,\n        ].join('\\n');\n        const sign = async () => {\n            const authClient = this.authClient;\n            try {\n                const signature = await authClient.sign(blobToSign);\n                const credentials = await authClient.getCredentials();\n                return {\n                    GoogleAccessId: credentials.client_email,\n                    Expires: config.expiration,\n                    Signature: signature,\n                };\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    getSignedUrlV4(config) {\n        config.accessibleAt = config.accessibleAt\n            ? config.accessibleAt\n            : new Date();\n        const millisecondsToSeconds = 1.0 / 1000.0;\n        const expiresPeriodInSeconds = config.expiration - config.accessibleAt.valueOf() * millisecondsToSeconds;\n        // v4 limit expiration to be 7 days maximum\n        if (expiresPeriodInSeconds > SEVEN_DAYS) {\n            throw new Error(`Max allowed expiration is seven days (${SEVEN_DAYS} seconds).`);\n        }\n        const extensionHeaders = Object.assign({}, config.extensionHeaders);\n        const fqdn = new url.URL(config.cname || exports.PATH_STYLED_HOST);\n        extensionHeaders.host = fqdn.host;\n        if (config.contentMd5) {\n            extensionHeaders['content-md5'] = config.contentMd5;\n        }\n        if (config.contentType) {\n            extensionHeaders['content-type'] = config.contentType;\n        }\n        let contentSha256;\n        const sha256Header = extensionHeaders['x-goog-content-sha256'];\n        if (sha256Header) {\n            if (typeof sha256Header !== 'string' ||\n                !/[A-Fa-f0-9]{40}/.test(sha256Header)) {\n                throw new Error('The header X-Goog-Content-SHA256 must be a hexadecimal string.');\n            }\n            contentSha256 = sha256Header;\n        }\n        const signedHeaders = Object.keys(extensionHeaders)\n            .map(header => header.toLowerCase())\n            .sort()\n            .join(';');\n        const extensionHeadersString = this.getCanonicalHeaders(extensionHeaders);\n        const datestamp = dateFormat.format(config.accessibleAt, 'YYYYMMDD', true);\n        const credentialScope = `${datestamp}/auto/storage/goog4_request`;\n        const sign = async () => {\n            const credentials = await this.authClient.getCredentials();\n            const credential = `${credentials.client_email}/${credentialScope}`;\n            const dateISO = dateFormat.format(config.accessibleAt ? config.accessibleAt : new Date(), 'YYYYMMDD[T]HHmmss[Z]', true);\n            const queryParams = {\n                'X-Goog-Algorithm': 'GOOG4-RSA-SHA256',\n                'X-Goog-Credential': credential,\n                'X-Goog-Date': dateISO,\n                'X-Goog-Expires': expiresPeriodInSeconds.toString(10),\n                'X-Goog-SignedHeaders': signedHeaders,\n                ...(config.queryParams || {}),\n            };\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            const canonicalQueryParams = this.getCanonicalQueryParams(queryParams);\n            const canonicalRequest = this.getCanonicalRequest(config.method, this.getResourcePath(!!config.cname, config.bucket, config.file), canonicalQueryParams, extensionHeadersString, signedHeaders, contentSha256);\n            const hash = crypto\n                .createHash('sha256')\n                .update(canonicalRequest)\n                .digest('hex');\n            const blobToSign = [\n                'GOOG4-RSA-SHA256',\n                dateISO,\n                credentialScope,\n                hash,\n            ].join('\\n');\n            try {\n                const signature = await this.authClient.sign(blobToSign);\n                const signatureHex = Buffer.from(signature, 'base64').toString('hex');\n                const signedQuery = Object.assign({}, queryParams, {\n                    'X-Goog-Signature': signatureHex,\n                });\n                return signedQuery;\n            }\n            catch (err) {\n                const signingErr = new SigningError(err.message);\n                signingErr.stack = err.stack;\n                throw signingErr;\n            }\n        };\n        return sign();\n    }\n    /**\n     * Create canonical headers for signing v4 url.\n     *\n     * The canonical headers for v4-signing a request demands header names are\n     * first lowercased, followed by sorting the header names.\n     * Then, construct the canonical headers part of the request:\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *  ..\n     *  <lowercasedHeaderName> + \":\" + Trim(<value>) + \"\\n\"\n     *\n     * @param headers\n     * @private\n     */\n    getCanonicalHeaders(headers) {\n        // Sort headers by their lowercased names\n        const sortedHeaders = util_1.objectEntries(headers)\n            // Convert header names to lowercase\n            .map(([headerName, value]) => [\n            headerName.toLowerCase(),\n            value,\n        ])\n            .sort((a, b) => a[0].localeCompare(b[0]));\n        return sortedHeaders\n            .filter(([, value]) => value !== undefined)\n            .map(([headerName, value]) => {\n            // - Convert Array (multi-valued header) into string, delimited by\n            //      ',' (no space).\n            // - Trim leading and trailing spaces.\n            // - Convert sequential (2+) spaces into a single space\n            const canonicalValue = `${value}`.trim().replace(/\\s{2,}/g, ' ');\n            return `${headerName}:${canonicalValue}\\n`;\n        })\n            .join('');\n    }\n    getCanonicalRequest(method, path, query, headers, signedHeaders, contentSha256) {\n        return [\n            method,\n            path,\n            query,\n            headers,\n            signedHeaders,\n            contentSha256 || 'UNSIGNED-PAYLOAD',\n        ].join('\\n');\n    }\n    getCanonicalQueryParams(query) {\n        return util_1.objectEntries(query)\n            .map(([key, value]) => [util_1.encodeURI(key, true), util_1.encodeURI(value, true)])\n            .sort((a, b) => (a[0] < b[0] ? -1 : 1))\n            .map(([key, value]) => `${key}=${value}`)\n            .join('&');\n    }\n    getResourcePath(cname, bucket, file) {\n        if (cname) {\n            return '/' + (file || '');\n        }\n        else if (file) {\n            return `/${bucket}/${file}`;\n        }\n        else {\n            return `/${bucket}`;\n        }\n    }\n    parseExpires(expires, current = new Date()) {\n        const expiresInMSeconds = new Date(expires).valueOf();\n        if (isNaN(expiresInMSeconds)) {\n            throw new Error('The expiration date provided was invalid.');\n        }\n        if (expiresInMSeconds < current.valueOf()) {\n            throw new Error('An expiration date cannot be in the past.');\n        }\n        return Math.round(expiresInMSeconds / 1000); // The API expects seconds.\n    }\n    parseAccessibleAt(accessibleAt) {\n        const accessibleAtInMSeconds = new Date(accessibleAt || new Date()).valueOf();\n        if (isNaN(accessibleAtInMSeconds)) {\n            throw new Error('The accessible at date provided was invalid.');\n        }\n        return Math.floor(accessibleAtInMSeconds / 1000); // The API expects seconds.\n    }\n}\nexports.URLSigner = URLSigner;\n/**\n * Custom error type for errors related to getting signed errors and policies.\n *\n * @private\n */\nclass SigningError extends Error {\n    constructor() {\n        super(...arguments);\n        this.name = 'SigningError';\n    }\n}\nexports.SigningError = SigningError;\n//# sourceMappingURL=signer.js.map"]},"metadata":{},"sourceType":"script"}